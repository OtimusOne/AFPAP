/*! The file full_ui_all.js contains the following files: Detector.js,
 * CanvasRenderer.js, TrackballControls.js, OrthographicTrackballControls.js,
 * Projector.js, marchingcube.js, ProteinSurface4.js, setupsurface.js, icn3d.js,
 * and full_ui.js.
 * The file simple_ui_all.js contains the following files: Detector.js,
 * CanvasRenderer.js, TrackballControls.js, OrthographicTrackballControls.js,
 * Projector.js, marchingcube.js, ProteinSurface4.js, setupsurface.js, icn3d.js,
 * and simple_ui.js.
 */

/*! Detector.js from http://threejs.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */

var Detector = {

    canvas: !!window.CanvasRenderingContext2D,
    webgl: (function () {

        try {

            var canvas = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));

        } catch (e) {

            return false;

        }

    })(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,

    getWebGLErrorMessage: function () {

        var element = document.createElement('div');
        element.id = 'webgl-error-message';
        element.style.fontFamily = 'monospace';
        element.style.fontSize = '13px';
        element.style.fontWeight = 'normal';
        element.style.textAlign = 'center';
        element.style.background = '#fff';
        element.style.color = '#000';
        element.style.padding = '1.5em';
        element.style.width = '400px';
        element.style.margin = '5em auto 0';

        if (!this.webgl) {

            element.innerHTML = window.WebGLRenderingContext ? [
                'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />',
                'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
            ].join('\n') : [
                'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>',
                'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
            ].join('\n');

        }

        return element;

    },

    addGetWebGLMessage: function (parameters) {

        var parent, id, element;

        parameters = parameters || {};

        parent = parameters.parent !== undefined ? parameters.parent : document.body;
        id = parameters.id !== undefined ? parameters.id : 'oldie';

        element = Detector.getWebGLErrorMessage();
        element.id = id;

        parent.appendChild(element);

    }

};

// browserify support
if (typeof module === 'object') {

    module.exports = Detector;

}

/*! TrackballControls.js from http://threejs.org/
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * modified by Jiyao Wang
 */

THREE.TrackballControls = function (object, domElement, icn3d) {

    var _this = this;

    this.STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

    this.object = object;
    this.domElement = (domElement !== undefined) ? domElement : document;

    // API
    this.enabled = true;

    this.screen = { left: 0, top: 0, width: 0, height: 0 };

    this.rotateSpeed = 1.0;
    this.zoomSpeed = 1.2;
    this.panSpeed = 0.3;

    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.noRoll = false;

    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;

    this.minDistance = 0;
    this.maxDistance = Infinity;

    this.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];

    // internals

    this.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    this._state = this.STATE.NONE;
    var _prevState = this.STATE.NONE;

    var _eye = new THREE.Vector3();

    this._rotateStart = new THREE.Vector3();
    this._rotateEnd = new THREE.Vector3();

    this._zoomStart = new THREE.Vector2();
    this._zoomEnd = new THREE.Vector2();

    var _touchZoomDistanceStart = 0;
    var _touchZoomDistanceEnd = 0;

    this._panStart = new THREE.Vector2();
    this._panEnd = new THREE.Vector2();

    // for reset

    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.up0 = this.object.up.clone();

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };


    // methods

    this.handleResize = function () {

        if (this.domElement === document) {

            this.screen.left = 0;
            this.screen.top = 0;
            this.screen.width = window.innerWidth;
            this.screen.height = window.innerHeight;

        } else {

            var box = this.domElement.getBoundingClientRect();
            // adjustments come from similar code in the jquery offset() function
            var d = this.domElement.ownerDocument.documentElement;
            this.screen.left = box.left + window.pageXOffset - d.clientLeft;
            this.screen.top = box.top + window.pageYOffset - d.clientTop;
            this.screen.width = box.width;
            this.screen.height = box.height;

        }

    };

    this.handleEvent = function (event) {

        if (typeof this[event.type] === 'function') {

            this[event.type](event);

        }

    };

    var getMouseOnScreen = (function () {

        var vector = new THREE.Vector2();

        return function (pageX, pageY) {

            vector.set(
                (pageX - _this.screen.left) / _this.screen.width,
                (pageY - _this.screen.top) / _this.screen.height
            );

            return vector;

        };

    }());

    var getMouseProjectionOnBall = (function () {

        var vector = new THREE.Vector3();
        var objectUp = new THREE.Vector3();
        var mouseOnBall = new THREE.Vector3();

        return function (pageX, pageY) {

            mouseOnBall.set(
                (pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * .5),
                (_this.screen.height * 0.5 + _this.screen.top - pageY) / (_this.screen.height * .5),
                0.0
            );

            var length = mouseOnBall.length();

            if (_this.noRoll) {

                if (length < Math.SQRT1_2) {

                    mouseOnBall.z = Math.sqrt(1.0 - length * length);

                } else {

                    mouseOnBall.z = .5 / length;

                }

            } else if (length > 1.0) {

                mouseOnBall.normalize();

            } else {

                mouseOnBall.z = Math.sqrt(1.0 - length * length);

            }

            _eye.copy(_this.object.position).sub(_this.target);

            vector.copy(_this.object.up).setLength(mouseOnBall.y)
            vector.add(objectUp.copy(_this.object.up).cross(_eye).setLength(mouseOnBall.x));
            vector.add(_eye.setLength(mouseOnBall.z));

            return vector;

        };

    }());

    this.rotateCamera = (function (quaternionIn, bUpdate) {

        var axis = new THREE.Vector3(),
            quaternion = new THREE.Quaternion();


        return function (quaternionIn, bUpdate) {

            var angle;
            if (quaternionIn === undefined) {
                angle = Math.acos(_this._rotateStart.dot(_this._rotateEnd) / _this._rotateStart.length() / _this._rotateEnd.length());
            }

            //var angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );

            if (angle || quaternionIn !== undefined) {
                if (quaternionIn === undefined) {
                    axis.crossVectors(_this._rotateStart, _this._rotateEnd).normalize();

                    angle *= _this.rotateSpeed;

                    quaternion.setFromAxisAngle(axis, -angle);
                }
                else {
                    quaternion.copy(quaternionIn);
                }

                // order matters in quaernion multiplication: http://www.cprogramming.com/tutorial/3d/quaternions.html
                if (bUpdate === undefined || bUpdate === true) icn3d.quaternion.multiplyQuaternions(quaternion, icn3d.quaternion);

                _eye.applyQuaternion(quaternion);
                _this.object.up.applyQuaternion(quaternion);

                _this._rotateEnd.applyQuaternion(quaternion);

                if (_this.staticMoving) {

                    _this._rotateStart.copy(_this._rotateEnd);

                } else {

                    quaternion.setFromAxisAngle(axis, angle * (_this.dynamicDampingFactor - 1.0));
                    _this._rotateStart.applyQuaternion(quaternion);

                }
            }

        }

    }());

    this.zoomCamera = function (zoomFactor, bUpdate) {
        if (_this._state === _this.STATE.TOUCH_ZOOM_PAN) {

            var factor;

            if (zoomFactor !== undefined) {
                factor = zoomFactor;
            }
            else {

                factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
                _touchZoomDistanceStart = _touchZoomDistanceEnd;
            }

            _eye.multiplyScalar(factor);

            if (bUpdate === undefined || bUpdate === true) icn3d._zoomFactor *= factor;

        } else {

            var factor;

            if (zoomFactor !== undefined) {
                factor = zoomFactor;
            }
            else {
                factor = 1.0 + (_this._zoomEnd.y - _this._zoomStart.y) * _this.zoomSpeed;
            }

            if (bUpdate === undefined || bUpdate === true) icn3d._zoomFactor *= factor;

            //if ( factor !== 1.0 && factor > 0.0 ) {
            if (factor !== 1.0) {

                _eye.multiplyScalar(factor);

                if (_this.staticMoving) {

                    _this._zoomStart.copy(_this._zoomEnd);

                } else {

                    _this._zoomStart.y += (_this._zoomEnd.y - _this._zoomStart.y) * this.dynamicDampingFactor;
                }
            }

        }

    };

    this.panCamera = (function (mouseChangeIn, bUpdate) {

        var mouseChange = new THREE.Vector2(),
            objectUp = new THREE.Vector3(),
            pan = new THREE.Vector3();

        return function (mouseChangeIn, bUpdate) {

            if (mouseChangeIn !== undefined) {
                mouseChange = mouseChangeIn;

                if (bUpdate === undefined || bUpdate === true) icn3d.mouseChange.add(mouseChangeIn);
            }
            else {
                mouseChange.copy(_this._panEnd).sub(_this._panStart);

                if (bUpdate === undefined || bUpdate === true) icn3d.mouseChange.add(_this._panEnd).sub(_this._panStart);
            }

            if (mouseChange.lengthSq()) {
                mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);

                pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
                pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

                _this.object.position.add(pan);
                _this.target.add(pan);

                if (_this.staticMoving) {

                    _this._panStart.copy(_this._panEnd);

                } else {

                    _this._panStart.add(mouseChange.subVectors(_this._panEnd, _this._panStart).multiplyScalar(_this.dynamicDampingFactor));

                }

            }
        }

    }());

    this.checkDistances = function () {

        if (!_this.noZoom || !_this.noPan) {

            if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {

                _this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));

            }

            if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {

                _this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));

            }

        }

    };

    this.update = function (para) {

        _eye.subVectors(_this.object.position, _this.target);

        if (!_this.noRotate) {

            if (para !== undefined && para.quaternion !== undefined) {
                _this.rotateCamera(para.quaternion, para.update);
            }
            else {
                _this.rotateCamera();
            }

        }

        if (!_this.noZoom) {

            if (para !== undefined && para._zoomFactor !== undefined) {
                _this.zoomCamera(para._zoomFactor, para.update);
            }
            else {
                _this.zoomCamera();
            }

        }

        if (!_this.noPan) {

            if (para !== undefined && para.mouseChange !== undefined) {
                _this.panCamera(para.mouseChange, para.update);
            }
            else {
                _this.panCamera();
            }

        }

        _this.object.position.addVectors(_this.target, _eye);

        _this.checkDistances();

        _this.object.lookAt(_this.target);

        if (lastPosition.distanceToSquared(_this.object.position) > EPS) {

            _this.dispatchEvent(changeEvent);

            lastPosition.copy(_this.object.position);

        }

    };

    this.reset = function () {

        _this._state = _this.STATE.NONE;
        _prevState = _this.STATE.NONE;

        _this.target.copy(_this.target0);
        _this.object.position.copy(_this.position0);
        _this.object.up.copy(_this.up0);

        _eye.subVectors(_this.object.position, _this.target);

        _this.object.lookAt(_this.target);

        _this.dispatchEvent(changeEvent);

        lastPosition.copy(_this.object.position);

    };

    // listeners

    function keydown(event) {
        //console.log("keydown");

        if (_this.enabled === false) return;

        window.removeEventListener('keydown', keydown);

        _prevState = _this._state;


        if (_this._state !== _this.STATE.NONE) {

            return;

        } else if (event.keyCode === _this.keys[_this.STATE.ROTATE] && !_this.noRotate) {

            _this._state = _this.STATE.ROTATE;

        } else if ((event.keyCode === _this.keys[_this.STATE.ZOOM]) && !_this.noZoom) {

            _this._state = _this.STATE.ZOOM;

        } else if ((event.keyCode === _this.keys[_this.STATE.PAN]) && !_this.noPan) {

            _this._state = _this.STATE.PAN;

        }


    }

    function keyup(event) {
        //console.log("keyup");

        if (_this.enabled === false) return;

        _this._state = _prevState;

        window.addEventListener('keydown', keydown, false);

    }

    function mousedown(event) {

        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        if (_this._state === _this.STATE.NONE) {

            _this._state = event.button;

        }

        if (_this._state === _this.STATE.ROTATE && !_this.noRotate) {

            _this._rotateStart.copy(getMouseProjectionOnBall(event.pageX, event.pageY));
            _this._rotateEnd.copy(_this._rotateStart);

        } else if (_this._state === _this.STATE.ZOOM && !_this.noZoom) {

            _this._zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
            _this._zoomEnd.copy(_this._zoomStart);

        } else if (_this._state === _this.STATE.PAN && !_this.noPan) {

            _this._panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
            _this._panEnd.copy(_this._panStart)

        }

        document.addEventListener('mousemove', mousemove, false);
        document.addEventListener('mouseup', mouseup, false);

        _this.dispatchEvent(startEvent);

    }

    function mousemove(event) {

        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        if (_this._state === _this.STATE.ROTATE && !_this.noRotate) {

            //console.log("ROTATE");
            _this._rotateEnd.copy(getMouseProjectionOnBall(event.pageX, event.pageY));

        } else if (_this._state === _this.STATE.ZOOM && !_this.noZoom) {

            _this._zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));

        } else if (_this._state === _this.STATE.PAN && !_this.noPan) {

            _this._panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));

        }

    }

    function mouseup(event) {
        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        _this._state = _this.STATE.NONE;

        document.removeEventListener('mousemove', mousemove);
        document.removeEventListener('mouseup', mouseup);
        _this.dispatchEvent(endEvent);

    }

    function mousewheel(event) {

        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        var delta = 0;

        if (event.wheelDelta) { // WebKit / Opera / Explorer 9

            delta = event.wheelDelta / 40;

        } else if (event.detail) { // Firefox

            delta = - event.detail / 3;

        }

        //_this._zoomStart.y += delta * 0.01;
        //_this._zoomStart.y = delta * 0.01;
        _this._zoomStart.y = delta * 0.005;
        _this.dispatchEvent(startEvent);
        _this.dispatchEvent(endEvent);

    }

    function touchstart(event) {

        if (_this.enabled === false) return;

        switch (event.touches.length) {
            case 1:
                _this._state = _this.STATE.TOUCH_ROTATE;
                _this._rotateStart.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));
                _this._rotateEnd.copy(_this._rotateStart);
                break;

            case 2:
                _this._state = _this.STATE.TOUCH_ZOOM_PAN;
                var dx = event.touches[0].pageX - event.touches[1].pageX;
                var dy = event.touches[0].pageY - event.touches[1].pageY;
                _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                _this._panStart.copy(getMouseOnScreen(x, y));
                _this._panEnd.copy(_this._panStart);
                break;

            default:
                _this._state = _this.STATE.NONE;

        }
        _this.dispatchEvent(startEvent);


    }

    function touchmove(event) {

        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        switch (event.touches.length) {

            case 1:
                _this._rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));
                break;

            case 2:
                var dx = event.touches[0].pageX - event.touches[1].pageX;
                var dy = event.touches[0].pageY - event.touches[1].pageY;
                _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                _this._panEnd.copy(getMouseOnScreen(x, y));
                break;

            default:
                _this._state = _this.STATE.NONE;

        }

    }

    function touchend(event) {

        if (_this.enabled === false) return;

        switch (event.touches.length) {

            case 1:
                _this._rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));
                _this._rotateStart.copy(_this._rotateEnd);
                break;

            case 2:
                _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                _this._panEnd.copy(getMouseOnScreen(x, y));
                _this._panStart.copy(_this._panEnd);
                break;

        }

        _this._state = _this.STATE.NONE;
        _this.dispatchEvent(endEvent);

    }

    this.domElement.addEventListener('contextmn', function (event) { event.preventDefault(); }, false);

    this.domElement.addEventListener('mousedown', mousedown, false);

    this.domElement.addEventListener('mousewheel', mousewheel, false);
    this.domElement.addEventListener('DOMMouseScroll', mousewheel, false); // firefox

    this.domElement.addEventListener('touchstart', touchstart, false);
    this.domElement.addEventListener('touchend', touchend, false);
    this.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    this.handleResize();

    // force an update at start
    this.update();

};

THREE.TrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.TrackballControls.prototype.constructor = THREE.TrackballControls;

/*! OrthographicTrackballControls.js from http://threejs.org/
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Patrick Fuller / http://patrick-fuller.com
 * modified by Jiyao Wang
 */

THREE.OrthographicTrackballControls = function (object, domElement, icn3d) {

    var _this = this;
    var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

    this.object = object;
    this.domElement = (domElement !== undefined) ? domElement : document;

    // API
    this.enabled = true;

    this.screen = { left: 0, top: 0, width: 0, height: 0 };

    // JW: the rotation speed of orthographic should be much less than that of perspective
    //this.rotateSpeed = 1.0;
    this.rotateSpeed = 0.5;
    this.zoomSpeed = 1.2;

    var zoomSpeedAdjust = 0.01;
    this.zoomSpeed *= zoomSpeedAdjust;

    //this.panSpeed = 0.3;
    this.panSpeed = 0.03;

    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.noRoll = false;

    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;

    this.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];

    // internals

    this.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    this._state = STATE.NONE;
    var _prevState = STATE.NONE;

    var _eye = new THREE.Vector3();

    this._rotateStart = new THREE.Vector3();
    this._rotateEnd = new THREE.Vector3();

    this._zoomStart = new THREE.Vector2();
    this._zoomEnd = new THREE.Vector2();
    var _zoomFactor = 1;

    var _touchZoomDistanceStart = 0;
    var _touchZoomDistanceEnd = 0;

    this._panStart = new THREE.Vector2();
    this._panEnd = new THREE.Vector2();

    // for reset

    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.up0 = this.object.up.clone();

    this.left0 = this.object.left;
    this.right0 = this.object.right;
    this.top0 = this.object.top;
    this.bottom0 = this.object.bottom;
    this.center0 = new THREE.Vector2((this.left0 + this.right0) / 2.0, (this.top0 + this.bottom0) / 2.0);

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };


    // methods

    this.handleResize = function () {

        if (this.domElement === document) {

            this.screen.left = 0;
            this.screen.top = 0;
            this.screen.width = window.innerWidth;
            this.screen.height = window.innerHeight;

        } else {

            var box = this.domElement.getBoundingClientRect();
            // adjustments come from similar code in the jquery offset() function
            var d = this.domElement.ownerDocument.documentElement;
            this.screen.left = box.left + window.pageXOffset - d.clientLeft;
            this.screen.top = box.top + window.pageYOffset - d.clientTop;
            this.screen.width = box.width;
            this.screen.height = box.height;
        }

        this.left0 = this.object.left;
        this.right0 = this.object.right;
        this.top0 = this.object.top;
        this.bottom0 = this.object.bottom;
        this.center0.set((this.left0 + this.right0) / 2.0, (this.top0 + this.bottom0) / 2.0);

    };

    this.handleEvent = function (event) {

        if (typeof this[event.type] === 'function') {

            this[event.type](event);

        }

    };

    var getMouseOnScreen = (function () {

        var vector = new THREE.Vector2();

        return function (pageX, pageY) {

            vector.set(
                (pageX - _this.screen.left) / _this.screen.width,
                (pageY - _this.screen.top) / _this.screen.height
            );

            return vector;

        };

    }());

    var getMouseProjectionOnBall = (function () {

        var vector = new THREE.Vector3();
        var objectUp = new THREE.Vector3();
        var mouseOnBall = new THREE.Vector3();

        return function (pageX, pageY) {

            mouseOnBall.set(
                (pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * .5),
                (_this.screen.height * 0.5 + _this.screen.top - pageY) / (_this.screen.height * .5),
                0.0
            );

            var length = mouseOnBall.length();

            if (_this.noRoll) {

                if (length < Math.SQRT1_2) {

                    mouseOnBall.z = Math.sqrt(1.0 - length * length);

                } else {

                    mouseOnBall.z = .5 / length;

                }

            } else if (length > 1.0) {

                mouseOnBall.normalize();

            } else {

                mouseOnBall.z = Math.sqrt(1.0 - length * length);

            }

            _eye.copy(_this.object.position).sub(_this.target);

            vector.copy(_this.object.up).setLength(mouseOnBall.y)
            vector.add(objectUp.copy(_this.object.up).cross(_eye).setLength(mouseOnBall.x));
            vector.add(_eye.setLength(mouseOnBall.z));

            return vector;

        };

    }());

    this.rotateCamera = (function (quaternionIn, bUpdate) {

        var axis = new THREE.Vector3(),
            quaternion = new THREE.Quaternion();

        return function (quaternionIn, bUpdate) {

            var angle;
            if (quaternionIn === undefined) {
                angle = Math.acos(_this._rotateStart.dot(_this._rotateEnd) / _this._rotateStart.length() / _this._rotateEnd.length());
            }

            //var angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );

            if (angle || quaternionIn !== undefined) {
                if (quaternionIn === undefined) {
                    axis.crossVectors(_this._rotateStart, _this._rotateEnd).normalize();

                    angle *= _this.rotateSpeed;

                    quaternion.setFromAxisAngle(axis, -angle);
                }
                else {
                    quaternion.copy(quaternionIn);
                }

                // order matters in quaernion multiplication: http://www.cprogramming.com/tutorial/3d/quaternions.html
                if (bUpdate === undefined || bUpdate === true) icn3d.quaternion.multiplyQuaternions(quaternion, icn3d.quaternion);

                _eye.applyQuaternion(quaternion);
                _this.object.up.applyQuaternion(quaternion);

                _this._rotateEnd.applyQuaternion(quaternion);

                if (_this.staticMoving) {

                    _this._rotateStart.copy(_this._rotateEnd);

                } else {

                    quaternion.setFromAxisAngle(axis, angle * (_this.dynamicDampingFactor - 1.0));
                    _this._rotateStart.applyQuaternion(quaternion);

                }

            }
        }

    }());

    this.zoomCamera = function (zoomFactor, bUpdate) {

        var factor;
        if (_this._state === STATE.TOUCH_ZOOM_PAN) {

            if (zoomFactor !== undefined) {
                factor = zoomFactor;
            }
            else {

                factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
                _touchZoomDistanceStart = _touchZoomDistanceEnd;
            }

        } else {

            if (zoomFactor !== undefined) {
                factor = zoomFactor;
            }
            else {

                factor = 1.0 + (_this._zoomEnd.y - _this._zoomStart.y) * _this.zoomSpeed / zoomSpeedAdjust;
            }
        }

        if (bUpdate === undefined || bUpdate === true) icn3d._zoomFactor *= factor;

        //if ( factor !== 1.0 && factor > 0.0 ) {
        if (factor !== 1.0) {

            //_zoomFactor *= factor;
            _zoomFactor = factor;

            _this.object.left = _zoomFactor * _this.left0 + (1 - _zoomFactor) * _this.center0.x;
            _this.object.right = _zoomFactor * _this.right0 + (1 - _zoomFactor) * _this.center0.x;
            _this.object.top = _zoomFactor * _this.top0 + (1 - _zoomFactor) * _this.center0.y;
            _this.object.bottom = _zoomFactor * _this.bottom0 + (1 - _zoomFactor) * _this.center0.y;

            if (_this.staticMoving) {

                _this._zoomStart.copy(_this._zoomEnd);

            } else {

                _this._zoomStart.y += (_this._zoomEnd.y - _this._zoomStart.y) * this.dynamicDampingFactor;

            }

        }

    };

    this.panCamera = (function (mouseChangeIn, bUpdate) {

        var mouseChange = new THREE.Vector2(),
            objectUp = new THREE.Vector3(),
            pan = new THREE.Vector3();

        return function (mouseChangeIn, bUpdate) {

            if (mouseChangeIn !== undefined) {
                mouseChange = mouseChangeIn;

                if (bUpdate === undefined || bUpdate === true) icn3d.mouseChange.add(mouseChangeIn);
            }
            else {
                mouseChange.copy(_this._panEnd).sub(_this._panStart);

                if (bUpdate === undefined || bUpdate === true) icn3d.mouseChange.add(_this._panEnd).sub(_this._panStart);
            }

            if (mouseChange.lengthSq()) {

                mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);

                pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
                pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

                _this.object.position.add(pan);
                _this.target.add(pan);

                if (_this.staticMoving) {

                    _this._panStart.copy(_this._panEnd);

                } else {

                    _this._panStart.add(mouseChange.subVectors(_this._panEnd, _this._panStart).multiplyScalar(_this.dynamicDampingFactor));

                }

            }
        }

    }());

    this.update = function (para) {

        _eye.subVectors(_this.object.position, _this.target);

        if (!_this.noRotate) {

            if (para !== undefined && para.quaternion !== undefined) {
                _this.rotateCamera(para.quaternion, para.update);
            }
            else {
                _this.rotateCamera();
            }

        }

        if (!_this.noZoom) {

            if (para !== undefined && para._zoomFactor !== undefined) {
                _this.zoomCamera(para._zoomFactor, para.update);
            }
            else {
                _this.zoomCamera();
            }

            _this.object.updateProjectionMatrix();

        }

        if (!_this.noPan) {

            if (para !== undefined && para.mouseChange !== undefined) {
                _this.panCamera(para.mouseChange, para.update);
            }
            else {
                _this.panCamera();
            }

        }

        _this.object.position.addVectors(_this.target, _eye);

        _this.object.lookAt(_this.target);

        if (lastPosition.distanceToSquared(_this.object.position) > EPS) {

            _this.dispatchEvent(changeEvent);

            lastPosition.copy(_this.object.position);

        }

    };

    this.reset = function () {

        _this._state = STATE.NONE;
        _prevState = STATE.NONE;

        _this.target.copy(_this.target0);
        _this.object.position.copy(_this.position0);
        _this.object.up.copy(_this.up0);

        _eye.subVectors(_this.object.position, _this.target);

        _this.object.left = _this.left0;
        _this.object.right = _this.right0;
        _this.object.top = _this.top0;
        _this.object.bottom = _this.bottom0;

        _this.object.lookAt(_this.target);

        _this.dispatchEvent(changeEvent);

        lastPosition.copy(_this.object.position);

    };

    // listeners

    function keydown(event) {

        if (_this.enabled === false) return;

        window.removeEventListener('keydown', keydown);

        _prevState = _this._state;

        if (_this._state !== STATE.NONE) {

            return;

        } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {

            _this._state = STATE.ROTATE;

        } else if ((event.keyCode === _this.keys[STATE.ZOOM]) && !_this.noZoom) {

            _this._state = STATE.ZOOM;

        } else if ((event.keyCode === _this.keys[STATE.PAN]) && !_this.noPan) {

            _this._state = STATE.PAN;

        }

    }

    function keyup(event) {

        if (_this.enabled === false) return;

        _this._state = _prevState;

        window.addEventListener('keydown', keydown, false);

    }

    function mousedown(event) {

        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        if (_this._state === STATE.NONE) {

            _this._state = event.button;

        }

        if (_this._state === STATE.ROTATE && !_this.noRotate) {

            _this._rotateStart.copy(getMouseProjectionOnBall(event.pageX, event.pageY));
            _this._rotateEnd.copy(_this._rotateStart);

        } else if (_this._state === STATE.ZOOM && !_this.noZoom) {

            _this._zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
            _this._zoomEnd.copy(_this._zoomStart);

        } else if (_this._state === STATE.PAN && !_this.noPan) {

            _this._panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
            _this._panEnd.copy(_this._panStart)

        }

        document.addEventListener('mousemove', mousemove, false);
        document.addEventListener('mouseup', mouseup, false);

        _this.dispatchEvent(startEvent);

    }

    function mousemove(event) {

        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        if (_this._state === STATE.ROTATE && !_this.noRotate) {

            _this._rotateEnd.copy(getMouseProjectionOnBall(event.pageX, event.pageY));

        } else if (_this._state === STATE.ZOOM && !_this.noZoom) {

            _this._zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));

        } else if (_this._state === STATE.PAN && !_this.noPan) {

            _this._panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));

        }

    }

    function mouseup(event) {

        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        _this._state = STATE.NONE;

        document.removeEventListener('mousemove', mousemove);
        document.removeEventListener('mouseup', mouseup);
        _this.dispatchEvent(endEvent);

    }

    function mousewheel(event) {

        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        var delta = 0;

        if (event.wheelDelta) { // WebKit / Opera / Explorer 9

            delta = event.wheelDelta / 40;

        } else if (event.detail) { // Firefox

            delta = - event.detail / 3;

        }

        //_this._zoomStart.y += delta * 0.01;
        _this._zoomStart.y = delta * 0.01;
        _this.dispatchEvent(startEvent);
        _this.dispatchEvent(endEvent);

    }

    function touchstart(event) {

        if (_this.enabled === false) return;

        switch (event.touches.length) {

            case 1:
                _this._state = STATE.TOUCH_ROTATE;
                _this._rotateStart.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));
                _this._rotateEnd.copy(_this._rotateStart);
                break;

            case 2:
                _this._state = STATE.TOUCH_ZOOM_PAN;
                var dx = event.touches[0].pageX - event.touches[1].pageX;
                var dy = event.touches[0].pageY - event.touches[1].pageY;
                _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                _this._panStart.copy(getMouseOnScreen(x, y));
                _this._panEnd.copy(_this._panStart);
                break;

            default:
                _this._state = STATE.NONE;

        }
        _this.dispatchEvent(startEvent);


    }

    function touchmove(event) {

        if (_this.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        switch (event.touches.length) {

            case 1:
                _this._rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));
                break;

            case 2:
                var dx = event.touches[0].pageX - event.touches[1].pageX;
                var dy = event.touches[0].pageY - event.touches[1].pageY;
                _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                _this._panEnd.copy(getMouseOnScreen(x, y));
                break;

            default:
                _this._state = STATE.NONE;

        }

    }

    function touchend(event) {

        if (_this.enabled === false) return;

        switch (event.touches.length) {

            case 1:
                _this._rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));
                _this._rotateStart.copy(_this._rotateEnd);
                break;

            case 2:
                _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                _this._panEnd.copy(getMouseOnScreen(x, y));
                _this._panStart.copy(_this._panEnd);
                break;

        }

        _this._state = STATE.NONE;
        _this.dispatchEvent(endEvent);

    }

    this.domElement.addEventListener('contextmn', function (event) { event.preventDefault(); }, false);

    this.domElement.addEventListener('mousedown', mousedown, false);

    this.domElement.addEventListener('mousewheel', mousewheel, false);
    this.domElement.addEventListener('DOMMouseScroll', mousewheel, false); // firefox

    this.domElement.addEventListener('touchstart', touchstart, false);
    this.domElement.addEventListener('touchend', touchend, false);
    this.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    this.handleResize();

    // force an update at start
    this.update();

};

THREE.OrthographicTrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.OrthographicTrackballControls.prototype.constructor = THREE.OrthographicTrackballControls;

/*! Projector.js from http://threejs.org/
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */

THREE.RenderableObject = function () {

    this.id = 0;

    this.object = null;
    this.z = 0;

};

//

THREE.RenderableFace = function () {

    this.id = 0;

    this.v1 = new THREE.RenderableVertex();
    this.v2 = new THREE.RenderableVertex();
    this.v3 = new THREE.RenderableVertex();

    this.normalModel = new THREE.Vector3();

    this.vertexNormalsModel = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
    this.vertexNormalsLength = 0;

    this.color = new THREE.Color();
    this.material = null;
    this.uvs = [new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()];

    this.z = 0;

};

//

THREE.RenderableVertex = function () {

    this.position = new THREE.Vector3();
    this.positionWorld = new THREE.Vector3();
    this.positionScreen = new THREE.Vector4();

    this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function (vertex) {

    this.positionWorld.copy(vertex.positionWorld);
    this.positionScreen.copy(vertex.positionScreen);

};

//

THREE.RenderableLine = function () {

    this.id = 0;

    this.v1 = new THREE.RenderableVertex();
    this.v2 = new THREE.RenderableVertex();

    this.vertexColors = [new THREE.Color(), new THREE.Color()];
    this.material = null;

    this.z = 0;

};

//

THREE.RenderableSprite = function () {

    this.id = 0;

    this.object = null;

    this.x = 0;
    this.y = 0;
    this.z = 0;

    this.rotation = 0;
    this.scale = new THREE.Vector2();

    this.material = null;

};

//

THREE.Projector = function () {

    var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
        _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
        _face, _faceCount, _facePool = [], _facePoolLength = 0,
        _line, _lineCount, _linePool = [], _linePoolLength = 0,
        _sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,

        _renderData = { objects: [], lights: [], elements: [] },

        _vA = new THREE.Vector3(),
        _vB = new THREE.Vector3(),
        _vC = new THREE.Vector3(),

        _vector3 = new THREE.Vector3(),
        _vector4 = new THREE.Vector4(),

        _clipBox = new THREE.Box3(new THREE.Vector3(- 1, - 1, - 1), new THREE.Vector3(1, 1, 1)),
        _boundingBox = new THREE.Box3(),
        _pnts3 = new Array(3),
        _pnts4 = new Array(4),

        _viewMatrix = new THREE.Matrix4(),
        _viewProjectionMatrix = new THREE.Matrix4(),

        _modelMatrix,
        _modelViewProjectionMatrix = new THREE.Matrix4(),

        _normalMatrix = new THREE.Matrix3(),

        _frustum = new THREE.Frustum(),

        _clippedVertex1PositionScreen = new THREE.Vector4(),
        _clippedVertex2PositionScreen = new THREE.Vector4();

    //

    this.projectVector = function (vector, camera) {

        console.warn('THREE.Projector: .projectVector() is now vector.project().');
        vector.project(camera);

    };

    this.unprojectVector = function (vector, camera) {

        console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
        vector.unproject(camera);

    };

    this.pkRay = function (vector, camera) {

        console.error('THREE.Projector: .pkRay() is now raycaster.setFromCamera().');

    };

    //

    var RenderList = function () {

        var normals = [];
        var uvs = [];

        var object = null;
        var material = null;

        var normalMatrix = new THREE.Matrix3();

        var setObject = function (value) {

            object = value;
            material = object.material;

            normalMatrix.getNormalMatrix(object.matrixWorld);

            normals.length = 0;
            uvs.length = 0;

        };

        var projectVertex = function (vertex) {

            var position = vertex.position;
            var positionWorld = vertex.positionWorld;
            var positionScreen = vertex.positionScreen;

            positionWorld.copy(position).applyMatrix4(_modelMatrix);
            positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);

            var invW = 1 / positionScreen.w;

            positionScreen.x *= invW;
            positionScreen.y *= invW;
            positionScreen.z *= invW;

            vertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&
                positionScreen.y >= - 1 && positionScreen.y <= 1 &&
                positionScreen.z >= - 1 && positionScreen.z <= 1;

        };

        var pushVertex = function (x, y, z) {

            _vertex = getNextVertexInPool();
            _vertex.position.set(x, y, z);

            projectVertex(_vertex);

        };

        var pushNormal = function (x, y, z) {

            normals.push(x, y, z);

        };

        var pushUv = function (x, y) {

            uvs.push(x, y);

        };

        var checkTriangleVisibility = function (v1, v2, v3) {

            if (v1.visible === true || v2.visible === true || v3.visible === true) return true;

            _pnts3[0] = v1.positionScreen;
            _pnts3[1] = v2.positionScreen;
            _pnts3[2] = v3.positionScreen;

            return _clipBox.isIntersectionBox(_boundingBox.setFromPoints(_pnts3));

        };

        var checkBackfaceCulling = function (v1, v2, v3) {

            return ((v3.positionScreen.x - v1.positionScreen.x) *
                (v2.positionScreen.y - v1.positionScreen.y) -
                (v3.positionScreen.y - v1.positionScreen.y) *
                (v2.positionScreen.x - v1.positionScreen.x)) < 0;

        };

        var pushLine = function (a, b) {

            var v1 = _vertexPool[a];
            var v2 = _vertexPool[b];

            _line = getNextLineInPool();

            _line.id = object.id;
            _line.v1.copy(v1);
            _line.v2.copy(v2);
            _line.z = (v1.positionScreen.z + v2.positionScreen.z) / 2;

            _line.material = object.material;

            _renderData.elements.push(_line);

        };

        var pushTriangle = function (a, b, c) {

            var v1 = _vertexPool[a];
            var v2 = _vertexPool[b];
            var v3 = _vertexPool[c];

            if (checkTriangleVisibility(v1, v2, v3) === false) return;

            if (material.side === THREE.DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {

                _face = getNextFaceInPool();

                _face.id = object.id;
                _face.v1.copy(v1);
                _face.v2.copy(v2);
                _face.v3.copy(v3);
                _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;

                for (var i = 0; i < 3; i++) {

                    var offset = arguments[i] * 3;
                    var normal = _face.vertexNormalsModel[i];

                    normal.set(normals[offset], normals[offset + 1], normals[offset + 2]);
                    normal.applyMatrix3(normalMatrix).normalize();

                    var offset2 = arguments[i] * 2;

                    var uv = _face.uvs[i];
                    uv.set(uvs[offset2], uvs[offset2 + 1]);

                }

                _face.vertexNormalsLength = 3;

                _face.material = object.material;

                _renderData.elements.push(_face);

            }

        };

        return {
            setObject: setObject,
            projectVertex: projectVertex,
            checkTriangleVisibility: checkTriangleVisibility,
            checkBackfaceCulling: checkBackfaceCulling,
            pushVertex: pushVertex,
            pushNormal: pushNormal,
            pushUv: pushUv,
            pushLine: pushLine,
            pushTriangle: pushTriangle
        }

    };

    var renderList = new RenderList();

    this.projectScene = function (scene, camera, sortObjects, sortElements) {

        _faceCount = 0;
        _lineCount = 0;
        _spriteCount = 0;

        _renderData.elements.length = 0;

        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        if (camera.parent === undefined) camera.updateMatrixWorld();

        _viewMatrix.copy(camera.matrixWorldInverse.getInverse(camera.matrixWorld));
        _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);

        _frustum.setFromMatrix(_viewProjectionMatrix);

        //

        _objectCount = 0;

        _renderData.objects.length = 0;
        _renderData.lights.length = 0;

        scene.traverseVisible(function (object) {

            if (object instanceof THREE.Light) {

                _renderData.lights.push(object);

            } else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite) {

                if (object.material.visible === false) return;

                if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {

                    _object = getNextObjectInPool();
                    _object.id = object.id;
                    _object.object = object;

                    _vector3.setFromMatrixPosition(object.matrixWorld);
                    _vector3.applyProjection(_viewProjectionMatrix);
                    _object.z = _vector3.z;

                    _renderData.objects.push(_object);

                }

            }

        });

        if (sortObjects === true) {

            _renderData.objects.sort(painterSort);

        }

        //

        for (var o = 0, ol = _renderData.objects.length; o < ol; o++) {

            var object = _renderData.objects[o].object;
            var geometry = object.geometry;

            renderList.setObject(object);

            _modelMatrix = object.matrixWorld;

            _vertexCount = 0;

            if (object instanceof THREE.Mesh) {

                if (geometry instanceof THREE.BufferGeometry) {

                    var attributes = geometry.attributes;
                    var offsets = geometry.offsets;

                    if (attributes.position === undefined) continue;

                    var positions = attributes.position.array;

                    for (var i = 0, l = positions.length; i < l; i += 3) {

                        renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);

                    }

                    if (attributes.normal !== undefined) {

                        var normals = attributes.normal.array;

                        for (var i = 0, l = normals.length; i < l; i += 3) {

                            renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);

                        }

                    }

                    if (attributes.uv !== undefined) {

                        var uvs = attributes.uv.array;

                        for (var i = 0, l = uvs.length; i < l; i += 2) {

                            renderList.pushUv(uvs[i], uvs[i + 1]);

                        }

                    }

                    if (attributes.index !== undefined) {

                        var indices = attributes.index.array;

                        if (offsets.length > 0) {

                            for (var o = 0; o < offsets.length; o++) {

                                var offset = offsets[o];
                                var index = offset.index;

                                for (var i = offset.start, l = offset.start + offset.count; i < l; i += 3) {

                                    renderList.pushTriangle(indices[i] + index, indices[i + 1] + index, indices[i + 2] + index);

                                }

                            }

                        } else {

                            for (var i = 0, l = indices.length; i < l; i += 3) {

                                renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2]);

                            }

                        }

                    } else {

                        for (var i = 0, l = positions.length / 3; i < l; i += 3) {

                            renderList.pushTriangle(i, i + 1, i + 2);

                        }

                    }

                } else if (geometry instanceof THREE.Geometry) {

                    var vertices = geometry.vertices;
                    var faces = geometry.faces;
                    var faceVertexUvs = geometry.faceVertexUvs[0];

                    _normalMatrix.getNormalMatrix(_modelMatrix);

                    var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
                    var objectMaterials = isFaceMaterial === true ? object.material : null;

                    for (var v = 0, vl = vertices.length; v < vl; v++) {

                        var vertex = vertices[v];
                        renderList.pushVertex(vertex.x, vertex.y, vertex.z);

                    }

                    for (var f = 0, fl = faces.length; f < fl; f++) {

                        var face = faces[f];

                        var material = isFaceMaterial === true
                            ? objectMaterials.materials[face.materialIndex]
                            : object.material;

                        if (material === undefined) continue;

                        var side = material.side;

                        var v1 = _vertexPool[face.a];
                        var v2 = _vertexPool[face.b];
                        var v3 = _vertexPool[face.c];

                        if (material.morphTargets === true) {

                            var morphTargets = geometry.morphTargets;
                            var morphInfluences = object.morphTargetInfluences;

                            var v1p = v1.position;
                            var v2p = v2.position;
                            var v3p = v3.position;

                            _vA.set(0, 0, 0);
                            _vB.set(0, 0, 0);
                            _vC.set(0, 0, 0);

                            for (var t = 0, tl = morphTargets.length; t < tl; t++) {

                                var influence = morphInfluences[t];

                                if (influence === 0) continue;

                                var targets = morphTargets[t].vertices;

                                _vA.x += (targets[face.a].x - v1p.x) * influence;
                                _vA.y += (targets[face.a].y - v1p.y) * influence;
                                _vA.z += (targets[face.a].z - v1p.z) * influence;

                                _vB.x += (targets[face.b].x - v2p.x) * influence;
                                _vB.y += (targets[face.b].y - v2p.y) * influence;
                                _vB.z += (targets[face.b].z - v2p.z) * influence;

                                _vC.x += (targets[face.c].x - v3p.x) * influence;
                                _vC.y += (targets[face.c].y - v3p.y) * influence;
                                _vC.z += (targets[face.c].z - v3p.z) * influence;

                            }

                            v1.position.add(_vA);
                            v2.position.add(_vB);
                            v3.position.add(_vC);

                            renderList.projectVertex(v1);
                            renderList.projectVertex(v2);
                            renderList.projectVertex(v3);

                        }

                        if (renderList.checkTriangleVisibility(v1, v2, v3) === false) continue;

                        var visible = renderList.checkBackfaceCulling(v1, v2, v3);

                        if (side !== THREE.DoubleSide) {
                            if (side === THREE.FrontSide && visible === false) continue;
                            if (side === THREE.BackSide && visible === true) continue;
                        }

                        _face = getNextFaceInPool();

                        _face.id = object.id;
                        _face.v1.copy(v1);
                        _face.v2.copy(v2);
                        _face.v3.copy(v3);

                        _face.normalModel.copy(face.normal);

                        if (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) {

                            _face.normalModel.negate();

                        }

                        _face.normalModel.applyMatrix3(_normalMatrix).normalize();

                        var faceVertexNormals = face.vertexNormals;

                        for (var n = 0, nl = Math.min(faceVertexNormals.length, 3); n < nl; n++) {

                            var normalModel = _face.vertexNormalsModel[n];
                            normalModel.copy(faceVertexNormals[n]);

                            if (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) {

                                normalModel.negate();

                            }

                            normalModel.applyMatrix3(_normalMatrix).normalize();

                        }

                        _face.vertexNormalsLength = faceVertexNormals.length;

                        var vertexUvs = faceVertexUvs[f];

                        if (vertexUvs !== undefined) {

                            for (var u = 0; u < 3; u++) {

                                _face.uvs[u].copy(vertexUvs[u]);

                            }

                        }

                        _face.color = face.color;
                        _face.material = material;

                        _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;

                        _renderData.elements.push(_face);

                    }

                }

            } else if (object instanceof THREE.Line) {

                if (geometry instanceof THREE.BufferGeometry) {

                    var attributes = geometry.attributes;

                    if (attributes.position !== undefined) {

                        var positions = attributes.position.array;

                        for (var i = 0, l = positions.length; i < l; i += 3) {

                            renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);

                        }

                        if (attributes.index !== undefined) {

                            var indices = attributes.index.array;

                            for (var i = 0, l = indices.length; i < l; i += 2) {

                                renderList.pushLine(indices[i], indices[i + 1]);

                            }

                        } else {

                            var step = object.mode === THREE.LinePieces ? 2 : 1;

                            for (var i = 0, l = (positions.length / 3) - 1; i < l; i += step) {

                                renderList.pushLine(i, i + 1);

                            }

                        }

                    }

                } else if (geometry instanceof THREE.Geometry) {

                    _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);

                    var vertices = object.geometry.vertices;

                    if (vertices.length === 0) continue;

                    v1 = getNextVertexInPool();
                    v1.positionScreen.copy(vertices[0]).applyMatrix4(_modelViewProjectionMatrix);

                    // Handle LineStrip and LinePieces
                    var step = object.mode === THREE.LinePieces ? 2 : 1;

                    for (var v = 1, vl = vertices.length; v < vl; v++) {

                        v1 = getNextVertexInPool();
                        v1.positionScreen.copy(vertices[v]).applyMatrix4(_modelViewProjectionMatrix);

                        if ((v + 1) % step > 0) continue;

                        v2 = _vertexPool[_vertexCount - 2];

                        _clippedVertex1PositionScreen.copy(v1.positionScreen);
                        _clippedVertex2PositionScreen.copy(v2.positionScreen);

                        if (clipLine(_clippedVertex1PositionScreen, _clippedVertex2PositionScreen) === true) {

                            // Perform the perspective divide
                            _clippedVertex1PositionScreen.multiplyScalar(1 / _clippedVertex1PositionScreen.w);
                            _clippedVertex2PositionScreen.multiplyScalar(1 / _clippedVertex2PositionScreen.w);

                            _line = getNextLineInPool();

                            _line.id = object.id;
                            _line.v1.positionScreen.copy(_clippedVertex1PositionScreen);
                            _line.v2.positionScreen.copy(_clippedVertex2PositionScreen);

                            _line.z = Math.max(_clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z);

                            _line.material = object.material;

                            if (object.material.vertexColors === THREE.VertexColors) {

                                _line.vertexColors[0].copy(object.geometry.colors[v]);
                                _line.vertexColors[1].copy(object.geometry.colors[v - 1]);

                            }

                            _renderData.elements.push(_line);

                        }

                    }

                }

            } else if (object instanceof THREE.Sprite) {

                _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);
                _vector4.applyMatrix4(_viewProjectionMatrix);

                var invW = 1 / _vector4.w;

                _vector4.z *= invW;

                if (_vector4.z >= - 1 && _vector4.z <= 1) {

                    _sprite = getNextSpriteInPool();
                    _sprite.id = object.id;
                    _sprite.x = _vector4.x * invW;
                    _sprite.y = _vector4.y * invW;
                    _sprite.z = _vector4.z;
                    _sprite.object = object;

                    _sprite.rotation = object.rotation;

                    _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));
                    _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));

                    _sprite.material = object.material;

                    _renderData.elements.push(_sprite);

                }

            }

        }

        if (sortElements === true) {

            _renderData.elements.sort(painterSort);

        }

        return _renderData;

    };

    // Pools

    function getNextObjectInPool() {

        if (_objectCount === _objectPoolLength) {

            var object = new THREE.RenderableObject();
            _objectPool.push(object);
            _objectPoolLength++;
            _objectCount++;
            return object;

        }

        return _objectPool[_objectCount++];

    }

    function getNextVertexInPool() {

        if (_vertexCount === _vertexPoolLength) {

            var vertex = new THREE.RenderableVertex();
            _vertexPool.push(vertex);
            _vertexPoolLength++;
            _vertexCount++;
            return vertex;

        }

        return _vertexPool[_vertexCount++];

    }

    function getNextFaceInPool() {

        if (_faceCount === _facePoolLength) {

            var face = new THREE.RenderableFace();
            _facePool.push(face);
            _facePoolLength++;
            _faceCount++;
            return face;

        }

        return _facePool[_faceCount++];


    }

    function getNextLineInPool() {

        if (_lineCount === _linePoolLength) {

            var line = new THREE.RenderableLine();
            _linePool.push(line);
            _linePoolLength++;
            _lineCount++
            return line;

        }

        return _linePool[_lineCount++];

    }

    function getNextSpriteInPool() {

        if (_spriteCount === _spritePoolLength) {

            var sprite = new THREE.RenderableSprite();
            _spritePool.push(sprite);
            _spritePoolLength++;
            _spriteCount++
            return sprite;

        }

        return _spritePool[_spriteCount++];

    }

    //

    function painterSort(a, b) {

        if (a.z !== b.z) {

            return b.z - a.z;

        } else if (a.id !== b.id) {

            return a.id - b.id;

        } else {

            return 0;

        }

    }

    function clipLine(s1, s2) {

        var alpha1 = 0, alpha2 = 1,

            // Calculate the boundary coordinate of each vertex for the near and far clip planes,
            // Z = -1 and Z = +1, respectively.
            bc1near = s1.z + s1.w,
            bc2near = s2.z + s2.w,
            bc1far = - s1.z + s1.w,
            bc2far = - s2.z + s2.w;

        if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {

            // Both vertices lie entirely within all clip planes.
            return true;

        } else if ((bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0)) {

            // Both vertices lie entirely outside one of the clip planes.
            return false;

        } else {

            // The line segment spans at least one clip plane.

            if (bc1near < 0) {

                // v1 lies outside the near plane, v2 inside
                alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));

            } else if (bc2near < 0) {

                // v2 lies outside the near plane, v1 inside
                alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));

            }

            if (bc1far < 0) {

                // v1 lies outside the far plane, v2 inside
                alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));

            } else if (bc2far < 0) {

                // v2 lies outside the far plane, v2 inside
                alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));

            }

            if (alpha2 < alpha1) {

                // The line segment spans two boundaries, but is outside both of them.
                // (This can't happen when we're only clipping against just near/far but good
                //  to leave the check here for future usage if other clip planes are added.)
                return false;

            } else {

                // Update the s1 and s2 vertices to match the clipped line segment.
                s1.lerp(s2, alpha1);
                s2.lerp(s1, 1 - alpha2);

                return true;

            }

        }

    }

};

!function (r, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t(r.MMTF = r.MMTF || {}) }(this, function (r) { "use strict"; function t(r, t, n) { for (var e = (r.byteLength, 0), i = n.length; i > e; e++) { var o = n.charCodeAt(e); if (128 > o) r.setUint8(t++, o >>> 0 & 127 | 0); else if (2048 > o) r.setUint8(t++, o >>> 6 & 31 | 192), r.setUint8(t++, o >>> 0 & 63 | 128); else if (65536 > o) r.setUint8(t++, o >>> 12 & 15 | 224), r.setUint8(t++, o >>> 6 & 63 | 128), r.setUint8(t++, o >>> 0 & 63 | 128); else { if (!(1114112 > o)) throw new Error("bad codepoint " + o); r.setUint8(t++, o >>> 18 & 7 | 240), r.setUint8(t++, o >>> 12 & 63 | 128), r.setUint8(t++, o >>> 6 & 63 | 128), r.setUint8(t++, o >>> 0 & 63 | 128) } } } function n(r) { for (var t = 0, n = 0, e = r.length; e > n; n++) { var i = r.charCodeAt(n); if (128 > i) t += 1; else if (2048 > i) t += 2; else if (65536 > i) t += 3; else { if (!(1114112 > i)) throw new Error("bad codepoint " + i); t += 4 } } return t } function e(r, i, o) { var a = typeof r; if ("string" === a) { var u = n(r); if (32 > u) return i.setUint8(o, 160 | u), t(i, o + 1, r), 1 + u; if (256 > u) return i.setUint8(o, 217), i.setUint8(o + 1, u), t(i, o + 2, r), 2 + u; if (65536 > u) return i.setUint8(o, 218), i.setUint16(o + 1, u), t(i, o + 3, r), 3 + u; if (4294967296 > u) return i.setUint8(o, 219), i.setUint32(o + 1, u), t(i, o + 5, r), 5 + u } if (r instanceof Uint8Array) { var u = r.byteLength, s = new Uint8Array(i.buffer); if (256 > u) return i.setUint8(o, 196), i.setUint8(o + 1, u), s.set(r, o + 2), 2 + u; if (65536 > u) return i.setUint8(o, 197), i.setUint16(o + 1, u), s.set(r, o + 3), 3 + u; if (4294967296 > u) return i.setUint8(o, 198), i.setUint32(o + 1, u), s.set(r, o + 5), 5 + u } if ("number" === a) { if (!isFinite(r)) throw new Error("Number not finite: " + r); if (Math.floor(r) !== r) return i.setUint8(o, 203), i.setFloat64(o + 1, r), 9; if (r >= 0) { if (128 > r) return i.setUint8(o, r), 1; if (256 > r) return i.setUint8(o, 204), i.setUint8(o + 1, r), 2; if (65536 > r) return i.setUint8(o, 205), i.setUint16(o + 1, r), 3; if (4294967296 > r) return i.setUint8(o, 206), i.setUint32(o + 1, r), 5; throw new Error("Number too big 0x" + r.toString(16)) } if (r >= -32) return i.setInt8(o, r), 1; if (r >= -128) return i.setUint8(o, 208), i.setInt8(o + 1, r), 2; if (r >= -32768) return i.setUint8(o, 209), i.setInt16(o + 1, r), 3; if (r >= -2147483648) return i.setUint8(o, 210), i.setInt32(o + 1, r), 5; throw new Error("Number too small -0x" + (-r).toString(16).substr(1)) } if (null === r) return i.setUint8(o, 192), 1; if ("boolean" === a) return i.setUint8(o, r ? 195 : 194), 1; if ("object" === a) { var u, f = 0, c = Array.isArray(r); if (c) u = r.length; else { var d = Object.keys(r); u = d.length } var f; if (16 > u ? (i.setUint8(o, u | (c ? 144 : 128)), f = 1) : 65536 > u ? (i.setUint8(o, c ? 220 : 222), i.setUint16(o + 1, u), f = 3) : 4294967296 > u && (i.setUint8(o, c ? 221 : 223), i.setUint32(o + 1, u), f = 5), c) for (var l = 0; u > l; l++)f += e(r[l], i, o + f); else for (var l = 0; u > l; l++) { var g = d[l]; f += e(g, i, o + f), f += e(r[g], i, o + f) } return f } throw new Error("Unknown type " + a) } function i(r) { var t = typeof r; if ("string" === t) { var e = n(r); if (32 > e) return 1 + e; if (256 > e) return 2 + e; if (65536 > e) return 3 + e; if (4294967296 > e) return 5 + e } if (r instanceof Uint8Array) { var e = r.byteLength; if (256 > e) return 2 + e; if (65536 > e) return 3 + e; if (4294967296 > e) return 5 + e } if ("number" === t) { if (Math.floor(r) !== r) return 9; if (r >= 0) { if (128 > r) return 1; if (256 > r) return 2; if (65536 > r) return 3; if (4294967296 > r) return 5; throw new Error("Number too big 0x" + r.toString(16)) } if (r >= -32) return 1; if (r >= -128) return 2; if (r >= -32768) return 3; if (r >= -2147483648) return 5; throw new Error("Number too small -0x" + r.toString(16).substr(1)) } if ("boolean" === t || null === r) return 1; if ("object" === t) { var e, o = 0; if (Array.isArray(r)) { e = r.length; for (var a = 0; e > a; a++)o += i(r[a]) } else { var u = Object.keys(r); e = u.length; for (var a = 0; e > a; a++) { var s = u[a]; o += i(s) + i(r[s]) } } if (16 > e) return 1 + o; if (65536 > e) return 3 + o; if (4294967296 > e) return 5 + o; throw new Error("Array or object too long 0x" + e.toString(16)) } throw new Error("Unknown type " + t) } function o(r) { var t = new ArrayBuffer(i(r)), n = new DataView(t); return e(r, n, 0), new Uint8Array(t) } function a(r, t, n) { return t ? new r(t.buffer, t.byteOffset, t.byteLength / (n || 1)) : void 0 } function u(r) { return a(DataView, r) } function s(r) { return a(Uint8Array, r) } function f(r) { return a(Int8Array, r) } function c(r) { return a(Int32Array, r, 4) } function d(r) { return a(Float32Array, r, 4) } function l(r, t) { var n = r.length / 2; t || (t = new Int16Array(n)); for (var e = 0, i = 0; n > e; ++e, i += 2)t[e] = r[i] << 8 ^ r[i + 1] << 0; return t } function g(r, t) { var n = r.length; t || (t = new Uint8Array(2 * n)); for (var e = u(t), i = 0; n > i; ++i)e.setInt16(2 * i, r[i]); return s(t) } function v(r, t) { var n = r.length / 4; t || (t = new Int32Array(n)); for (var e = 0, i = 0; n > e; ++e, i += 4)t[e] = r[i] << 24 ^ r[i + 1] << 16 ^ r[i + 2] << 8 ^ r[i + 3] << 0; return t } function L(r, t) { var n = r.length; t || (t = new Uint8Array(4 * n)); for (var e = u(t), i = 0; n > i; ++i)e.setInt32(4 * i, r[i]); return s(t) } function h(r, t) { var n = r.length; t || (t = new Float32Array(n / 4)); for (var e = u(t), i = u(r), o = 0, a = 0, s = n / 4; s > o; ++o, a += 4)e.setFloat32(a, i.getFloat32(a), !0); return t } function y(r, t, n) { var e = r.length, i = 1 / t; n || (n = new Float32Array(e)); for (var o = 0; e > o; ++o)n[o] = r[o] * i; return n } function m(r, t, n) { var e = r.length; n || (n = new Int32Array(e)); for (var i = 0; e > i; ++i)n[i] = Math.round(r[i] * t); return n } function p(r, t) { var n, e; if (!t) { var i = 0; for (n = 0, e = r.length; e > n; n += 2)i += r[n + 1]; t = new r.constructor(i) } var o = 0; for (n = 0, e = r.length; e > n; n += 2)for (var a = r[n], u = r[n + 1], s = 0; u > s; ++s)t[o] = a, ++o; return t } function U(r) { if (0 === r.length) return new Int32Array; var t, n, e = 2; for (t = 1, n = r.length; n > t; ++t)r[t - 1] !== r[t] && (e += 2); var i = new Int32Array(e), o = 0, a = 1; for (t = 1, n = r.length; n > t; ++t)r[t - 1] !== r[t] ? (i[o] = r[t - 1], i[o + 1] = a, a = 1, o += 2) : ++a; return i[o] = r[r.length - 1], i[o + 1] = a, i } function b(r, t) { var n = r.length; t || (t = new r.constructor(n)), n && (t[0] = r[0]); for (var e = 1; n > e; ++e)t[e] = r[e] + t[e - 1]; return t } function I(r, t) { var n = r.length; t || (t = new r.constructor(n)), t[0] = r[0]; for (var e = 1; n > e; ++e)t[e] = r[e] - r[e - 1]; return t } function w(r, t) { var n, e, i = r instanceof Int8Array ? 127 : 32767, o = -i - 1, a = r.length; if (!t) { var u = 0; for (n = 0; a > n; ++n)r[n] < i && r[n] > o && ++u; t = new Int32Array(u) } for (n = 0, e = 0; a > n;) { for (var s = 0; r[n] === i || r[n] === o;)s += r[n], ++n; s += r[n], ++n, t[e] = s, ++e } return t } function C(r, t) { var n, e = t ? 127 : 32767, i = -e - 1, o = r.length, a = 0; for (n = 0; o > n; ++n) { var u = r[n]; 0 === u ? ++a : u > 0 ? (a += Math.ceil(u / e), u % e === 0 && (a += 1)) : (a += Math.ceil(u / i), u % i === 0 && (a += 1)) } var s = t ? new Int8Array(a) : new Int16Array(a), f = 0; for (n = 0; o > n; ++n) { var u = r[n]; if (u >= 0) for (; u >= e;)s[f] = e, ++f, u -= e; else for (; i >= u;)s[f] = i, ++f, u -= i; s[f] = u, ++f } return s } function A(r, t) { return b(p(r), t) } function x(r) { return U(I(r)) } function M(r, t, n) { return y(p(r, c(n)), t, n) } function F(r, t) { return U(m(r, t)) } function S(r, t, n) { return y(b(r, c(n)), t, n) } function E(r, t, n) { return I(m(r, t), n) } function N(r, t, n) { return y(w(r, c(n)), t, n) } function O(r, t, n) { var e = w(r, c(n)); return S(e, t, d(e)) } function T(r, t, n) { return C(E(r, t), n) } function k(r) { var t = u(r), n = t.getInt32(0), e = t.getInt32(4), i = r.subarray(8, 12), r = r.subarray(12); return [n, r, e, i] } function j(r, t, n, e) { var i = new ArrayBuffer(12 + e.byteLength), o = new Uint8Array(i), a = new DataView(i); return a.setInt32(0, r), a.setInt32(4, t), n && o.set(n, 8), o.set(e, 12), o } function q(r) { var t = r.length, n = s(r); return j(2, t, void 0, n) } function D(r) { var t = r.length, n = L(r); return j(4, t, void 0, n) } function P(r, t) { var n = r.length / t, e = L([t]), i = s(r); return j(5, n, e, i) } function z(r) { var t = r.length, n = L(U(r)); return j(6, t, void 0, n) } function B(r) { var t = r.length, n = L(x(r)); return j(8, t, void 0, n) } function V(r, t) { var n = r.length, e = L([t]), i = L(F(r, t)); return j(9, n, e, i) } function G(r, t) { var n = r.length, e = L([t]), i = g(T(r, t)); return j(10, n, e, i) } function R(r) { var t = {}; return rr.forEach(function (n) { void 0 !== r[n] && (t[n] = r[n]) }), r.bondAtomList && (t.bondAtomList = D(r.bondAtomList)), r.bondOrderList && (t.bondOrderList = q(r.bondOrderList)), t.xCoordList = G(r.xCoordList, 1e3), t.yCoordList = G(r.yCoordList, 1e3), t.zCoordList = G(r.zCoordList, 1e3), r.bFactorList && (t.bFactorList = G(r.bFactorList, 100)), r.atomIdList && (t.atomIdList = B(r.atomIdList)), r.altLocList && (t.altLocList = z(r.altLocList)), r.occupancyList && (t.occupancyList = V(r.occupancyList, 100)), t.groupIdList = B(r.groupIdList), t.groupTypeList = D(r.groupTypeList), r.secStructList && (t.secStructList = q(r.secStructList)), r.insCodeList && (t.insCodeList = z(r.insCodeList)), r.sequenceIndexList && (t.sequenceIndexList = B(r.sequenceIndexList)), t.chainIdList = P(r.chainIdList, 4), r.chainNameList && (t.chainNameList = P(r.chainNameList, 4)), t } function H(r) { function t(r) { for (var t = {}, n = 0; r > n; n++) { var e = o(); t[e] = o() } return t } function n(t) { var n = r.subarray(a, a + t); return a += t, n } function e(t) { var n = r.subarray(a, a + t); a += t; var e = 65535; if (t > e) { for (var i = [], o = 0; o < n.length; o += e)i.push(String.fromCharCode.apply(null, n.subarray(o, o + e))); return i.join("") } return String.fromCharCode.apply(null, n) } function i(r) { for (var t = new Array(r), n = 0; r > n; n++)t[n] = o(); return t } function o() { var o, s, f = r[a]; if (0 === (128 & f)) return a++, f; if (128 === (240 & f)) return s = 15 & f, a++, t(s); if (144 === (240 & f)) return s = 15 & f, a++, i(s); if (160 === (224 & f)) return s = 31 & f, a++, e(s); if (224 === (224 & f)) return o = u.getInt8(a), a++, o; switch (f) { case 192: return a++, null; case 194: return a++, !1; case 195: return a++, !0; case 196: return s = u.getUint8(a + 1), a += 2, n(s); case 197: return s = u.getUint16(a + 1), a += 3, n(s); case 198: return s = u.getUint32(a + 1), a += 5, n(s); case 202: return o = u.getFloat32(a + 1), a += 5, o; case 203: return o = u.getFloat64(a + 1), a += 9, o; case 204: return o = r[a + 1], a += 2, o; case 205: return o = u.getUint16(a + 1), a += 3, o; case 206: return o = u.getUint32(a + 1), a += 5, o; case 208: return o = u.getInt8(a + 1), a += 2, o; case 209: return o = u.getInt16(a + 1), a += 3, o; case 210: return o = u.getInt32(a + 1), a += 5, o; case 217: return s = u.getUint8(a + 1), a += 2, e(s); case 218: return s = u.getUint16(a + 1), a += 3, e(s); case 219: return s = u.getUint32(a + 1), a += 5, e(s); case 220: return s = u.getUint16(a + 1), a += 3, i(s); case 221: return s = u.getUint32(a + 1), a += 5, i(s); case 222: return s = u.getUint16(a + 1), a += 3, t(s); case 223: return s = u.getUint32(a + 1), a += 5, t(s) }throw new Error("Unknown type 0x" + f.toString(16)) } var a = 0, u = new DataView(r.buffer); return o() } function W(r, t, n, e) { switch (r) { case 1: return h(t); case 2: return f(t); case 3: return l(t); case 4: return v(t); case 5: return s(t); case 6: return p(v(t), new Uint8Array(n)); case 7: return p(v(t)); case 8: return A(v(t)); case 9: return M(v(t), v(e)[0]); case 10: return O(l(t), v(e)[0]); case 11: return y(l(t), v(e)[0]); case 12: return N(l(t), v(e)[0]); case 13: return N(f(t), v(e)[0]); case 14: return w(l(t)); case 15: return w(f(t)) } } function X(r, t) { t = t || {}; var n = t.ignoreFields, e = {}; return nr.forEach(function (t) { var i = n ? -1 !== n.indexOf(t) : !1, o = r[t]; i || void 0 === o || (o instanceof Uint8Array ? e[t] = W.apply(null, k(o)) : e[t] = o) }), e } function J(r) { return String.fromCharCode.apply(null, r).replace(/\0/g, "") } function K(r, t, n) { n = n || {}; var e, i, o, a, u, s, f = n.firstModelOnly, c = t.onModel, d = t.onChain, l = t.onGroup, g = t.onAtom, v = t.onBond, L = 0, h = 0, y = 0, m = 0, p = 0, U = -1, b = r.chainNameList, I = r.secStructList, w = r.insCodeList, C = r.sequenceIndexList, A = r.atomIdList, x = r.bFactorList, M = r.altLocList, F = r.occupancyList, S = r.bondAtomList, E = r.bondOrderList; for (e = 0, i = r.chainsPerModel.length; i > e && !(f && L > 0); ++e) { var N = r.chainsPerModel[L]; for (c && c({ chainCount: N, modelIndex: L }), o = 0; N > o; ++o) { var O = r.groupsPerChain[h]; if (d) { var T = J(r.chainIdList.subarray(4 * h, 4 * h + 4)), k = null; b && (k = J(b.subarray(4 * h, 4 * h + 4))), d({ groupCount: O, chainIndex: h, modelIndex: L, chainId: T, chainName: k }) } for (a = 0; O > a; ++a) { var j = r.groupList[r.groupTypeList[y]], q = j.atomNameList.length; if (l) { var D = null; I && (D = I[y]); var P = null; r.insCodeList && (P = String.fromCharCode(w[y])); var z = null; C && (z = C[y]), l({ atomCount: q, groupIndex: y, chainIndex: h, modelIndex: L, groupId: r.groupIdList[y], groupType: r.groupTypeList[y], groupName: j.groupName, singleLetterCode: j.singleLetterCode, chemCompType: j.chemCompType, secStruct: D, insCode: P, sequenceIndex: z }) } for (u = 0; q > u; ++u) { if (g) { var B = null; A && (B = A[m]); var V = null; x && (V = x[m]); var G = null; M && (G = String.fromCharCode(M[m])); var R = null; F && (R = F[m]), g({ atomIndex: m, groupIndex: y, chainIndex: h, modelIndex: L, atomId: B, element: j.elementList[u], atomName: j.atomNameList[u], formalCharge: j.formalChargeList[u], xCoord: r.xCoordList[m], yCoord: r.yCoordList[m], zCoord: r.zCoordList[m], bFactor: V, altLoc: G, occupancy: R }) } m += 1 } if (v) { var H = j.bondAtomList; for (u = 0, s = j.bondOrderList.length; s > u; ++u)v({ atomIndex1: m - q + H[2 * u], atomIndex2: m - q + H[2 * u + 1], bondOrder: j.bondOrderList[u] }) } y += 1 } h += 1 } if (p = U + 1, U = m - 1, v && S) for (u = 0, s = S.length; s > u; u += 2) { var W = S[u], X = S[u + 1]; (W >= p && U >= W || X >= p && U >= X) && v({ atomIndex1: W, atomIndex2: X, bondOrder: E ? E[u / 2] : null }) } L += 1 } } function Q(r) { return o(R(r)) } function Y(r, t) { r instanceof ArrayBuffer && (r = new Uint8Array(r)); var n; return n = r instanceof Uint8Array ? H(r) : r, X(n, t) } function Z(r, t, n, e) { function i() { try { var r = Y(o.response); n(r) } catch (t) { e(t) } } var o = new XMLHttpRequest; o.addEventListener("load", i, !0), o.addEventListener("error", e, !0), o.responseType = "arraybuffer", o.open("GET", t + r.toUpperCase()), o.send() } function $(r, t, n) { Z(r, or, t, n) } function _(r, t, n) { Z(r, ar, t, n) } var rr = ["mmtfVersion", "mmtfProducer", "unitCell", "spaceGroup", "structureId", "title", "depositionDate", "releaseDate", "experimentalMethods", "resolution", "rFree", "rWork", "bioAssemblyList", "ncsOperatorList", "entityList", "groupList", "numBonds", "numAtoms", "numGroups", "numChains", "numModels", "groupsPerChain", "chainsPerModel"], tr = ["xCoordList", "yCoordList", "zCoordList", "groupIdList", "groupTypeList", "chainIdList", "bFactorList", "atomIdList", "altLocList", "occupancyList", "secStructList", "insCodeList", "sequenceIndexList", "chainNameList", "bondAtomList", "bondOrderList"], nr = rr.concat(tr), er = "v1.0.1", ir = "//mmtf.rcsb.org/v1.0/", or = ir + "full/", ar = ir + "reduced/"; r.encode = Q, r.decode = Y, r.traverse = K, r.fetch = $, r.fetchReduced = _, r.version = er, r.fetchUrl = or, r.fetchReducedUrl = ar, r.encodeMsgpack = o, r.encodeMmtf = R, r.decodeMsgpack = H, r.decodeMmtf = X });
var $NGL_shaderTextHash = {};

$NGL_shaderTextHash['SphereImpostor.frag'] = ["#define STANDARD",
    "#define IMPOSTOR",
    "",
    "uniform vec3 diffuse;",
    "uniform vec3 emissive;",
    "uniform float roughness;",
    "uniform float metalness;",
    "uniform float opacity;",
    "uniform float nearClip;",
    "uniform mat4 projectionMatrix;",
    "uniform float ortho;",
    "",
    "varying float vRadius;",
    "varying float vRadiusSq;",
    "varying vec3 vPoint;",
    "varying vec3 vPointViewPosition;",
    "",
    "#ifdef PICKING",
    "    uniform float objectId;",
    "    varying vec3 vPickingColor;",
    "#else",
    "    #include common",
    "    #include color_pars_fragment",
    "    #include fog_pars_fragment",
    "    #include bsdfs",
    "    #include lights_pars",
    "    #include lights_physical_pars_fragment",
    "#endif",
    "",
    "bool flag2 = false;",
    "bool interior = false;",
    "vec3 cameraPos;",
    "vec3 cameraNormal;",
    "",
    "// Calculate depth based on the given camera position.",
    "float calcDepth( in vec3 cameraPos ){",
    "    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;",
    "    return 0.5 + 0.5 * clipZW.x / clipZW.y;",
    "}",
    "",
    "float calcClip( vec3 cameraPos ){",
    "    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );",
    "}",
    "",
    "bool Impostor( out vec3 cameraPos, out vec3 cameraNormal ){",
    "",
    "    vec3 cameraSpherePos = -vPointViewPosition;",
    "    cameraSpherePos.z += vRadius;",
    "",
    "    vec3 rayOrigin = mix( vec3( 0.0, 0.0, 0.0 ), vPoint, ortho );",
    "    vec3 rayDirection = mix( normalize( vPoint ), vec3( 0.0, 0.0, 1.0 ), ortho );",
    "    vec3 cameraSphereDir = mix( cameraSpherePos, rayOrigin - cameraSpherePos, ortho );",
    "",
    "    float B = dot( rayDirection, cameraSphereDir );",
    "    float det = B * B + vRadiusSq - dot( cameraSphereDir, cameraSphereDir );",
    "",
    "    if( det < 0.0 ){",
    "        discard;",
    "        return false;",
    "    }else{",
    "        float sqrtDet = sqrt( det );",
    "        float posT = mix( B + sqrtDet, B + sqrtDet, ortho );",
    "        float negT = mix( B - sqrtDet, sqrtDet - B, ortho );",
    "",
    "        cameraPos = rayDirection * negT + rayOrigin;",
    "",
    "        #ifdef NEAR_CLIP",
    "if( calcDepth( cameraPos ) <= 0.0 ){",
    "    cameraPos = rayDirection * posT + rayOrigin;",
    "    interior = true;",
    "    return false;",
    "}else if( calcClip( cameraPos ) > 0.0 ){",
    "    cameraPos = rayDirection * posT + rayOrigin;",
    "    interior = true;",
    "    flag2 = true;",
    "    return false;",
    "}else{",
    "    cameraNormal = normalize( cameraPos - cameraSpherePos );",
    "}",
    "        #else",
    "if( calcDepth( cameraPos ) <= 0.0 ){",
    "    cameraPos = rayDirection * posT + rayOrigin;",
    "    interior = true;",
    "    return false;",
    "}else{",
    "    cameraNormal = normalize( cameraPos - cameraSpherePos );",
    "}",
    "        #endif",
    "",
    "        return true;",
    "    }",
    "",
    "    return false; // ensure that each control flow has a return",
    "",
    "}",
    "",
    "void main(void){",
    "",
    "    bool flag = Impostor( cameraPos, cameraNormal );",
    "",
    "    #ifdef NEAR_CLIP",
    "        if( calcClip( cameraPos ) > 0.0 )",
    "            discard;",
    "    #endif",
    "",
    "    // FIXME not compatible with custom clipping plane",
    "    //Set the depth based on the new cameraPos.",
    "    gl_FragDepthEXT = calcDepth( cameraPos );",
    "    if( !flag ){",
    "",
    "        // clamp to near clipping plane and add a tiny value to",
    "        // make spheres with a greater radius occlude smaller ones",
    "        #ifdef NEAR_CLIP",
    "if( flag2 ){",
    "    gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );",
    "}else if( gl_FragDepthEXT >= 0.0 ){",
    "    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
    "}",
    "        #else",
    "if( gl_FragDepthEXT >= 0.0 ){",
    "    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
    "}",
    "        #endif",
    "",
    "    }",
    "",
    "    // bugfix (mac only?)",
    "    if (gl_FragDepthEXT < 0.0)",
    "        discard;",
    "    if (gl_FragDepthEXT > 1.0)",
    "        discard;",
    "",
    "    #ifdef PICKING",
    "",
    "        gl_FragColor = vec4( vPickingColor, objectId );",
    "",
    "    #else",
    "",
    "        vec3 vNormal = cameraNormal;",
    "        vec3 vViewPosition = -cameraPos;",
    "",
    "        vec4 diffuseColor = vec4( diffuse, opacity );",
    "        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
    "        vec3 totalEmissiveLight = emissive;",
    "",
    "        #include color_fragment",
    "        #include roughnessmap_fragment",
    "        #include metalnessmap_fragment",
    "        #include normal_flip",
    "        #include normal_fragment",
    "        if( interior ){",
    "            normal = vec3( 0.0, 0.0, 0.4 );",
    "        }",
    "",
    "        // include lights_phong_fragment",
    "        #include lights_physical_fragment",
    "        #include lights_template",
    "",
    "        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
    "",
    "        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );",
    "",
    "        #include premultiplied_alpha_fragment",
    "        #include tonemapping_fragment",
    "        #include encodings_fragment",
    "        #include fog_fragment",
    "",
    "    #endif",
    "",
    "}"
].join("\n");

$NGL_shaderTextHash['SphereImpostor.vert'] = ["uniform mat4 projectionMatrixInverse;",
    "uniform float nearClip;",
    "",
    "varying float vRadius;",
    "varying float vRadiusSq;",
    "varying vec3 vPoint;",
    "varying vec3 vPointViewPosition;",
    "",
    "attribute vec2 mapping;",
    "//attribute vec3 position;",
    "attribute float radius;",
    "",
    "#ifdef PICKING",
    "    #include unpack_clr",
    "    attribute float primitiveId;",
    "    varying vec3 vPickingColor;",
    "#else",
    "    #include color_pars_vertex",
    "#endif",
    "",
    "//include matrix_scale",
    "float matrixScale( in mat4 m ){",
    "    vec4 r = m[ 0 ];",
    "    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
    "}",
    "",
    "const mat4 D = mat4(",
    "    1.0, 0.0, 0.0, 0.0,",
    "    0.0, 1.0, 0.0, 0.0,",
    "    0.0, 0.0, 1.0, 0.0,",
    "    0.0, 0.0, 0.0, -1.0",
    ");",
    "",
    "mat4 transpose( in mat4 inMatrix ) {",
    "    vec4 i0 = inMatrix[0];",
    "    vec4 i1 = inMatrix[1];",
    "    vec4 i2 = inMatrix[2];",
    "    vec4 i3 = inMatrix[3];",
    "",
    "    mat4 outMatrix = mat4(",
    "        vec4(i0.x, i1.x, i2.x, i3.x),",
    "        vec4(i0.y, i1.y, i2.y, i3.y),",
    "        vec4(i0.z, i1.z, i2.z, i3.z),",
    "        vec4(i0.w, i1.w, i2.w, i3.w)",
    "    );",
    "    return outMatrix;",
    "}",
    "",
    "//------------------------------------------------------------------------------",
    "// Compute point size and center using the technique described in:",
    "// 'GPU-Based Ray-Casting of Quadratic Surfaces'",
    "// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.",
    "//",
    "// Code based on",
    "/*=========================================================================",
    "",
    " Program:   Visualization Toolkit",
    " Module:    Quadrics_fs.glsl and Quadrics_vs.glsl",
    "",
    " Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen",
    " All rights reserved.",
    " See Copyright.txt or http://www.kitware.com/Copyright.htm for details.",
    "",
    " This software is distributed WITHOUT ANY WARRANTY; without even",
    " the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR",
    " PURPOSE.  See the above copyright notice for more information.",
    "",
    " =========================================================================*/",
    "",
    "// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl",
    "// .SECTION Thanks",
    "// <verbatim>",
    "//",
    "//  This file is part of the PointSprites plugin developed and contributed by",
    "//",
    "//  Copyright (c) CSCS - Swiss National Supercomputing Centre",
    "//                EDF - Electricite de France",
    "//",
    "//  John Biddiscombe, Ugo Varetto (CSCS)",
    "//  Stephane Ploix (EDF)",
    "//",
    "// </verbatim>",
    "//",
    "// Contributions by Alexander Rose",
    "// - ported to WebGL",
    "// - adapted to work with quads",
    "void ComputePointSizeAndPositionInClipCoordSphere(){",
    "",
    "    vec2 xbc;",
    "    vec2 ybc;",
    "",
    "    mat4 T = mat4(",
    "        radius, 0.0, 0.0, 0.0,",
    "        0.0, radius, 0.0, 0.0,",
    "        0.0, 0.0, radius, 0.0,",
    "        position.x, position.y, position.z, 1.0",
    "    );",
    "",
    "    mat4 R = transpose( projectionMatrix * modelViewMatrix * T );",
    "    float A = dot( R[ 3 ], D * R[ 3 ] );",
    "    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );",
    "    float C = dot( R[ 0 ], D * R[ 0 ] );",
    "    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
    "    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
    "    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;",
    "",
    "    A = dot( R[ 3 ], D * R[ 3 ] );",
    "    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );",
    "    C = dot( R[ 1 ], D * R[ 1 ] );",
    "    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
    "    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
    "    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;",
    "",
    "    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );",
    "    gl_Position.xy -= mapping * vec2( sx, sy );",
    "    gl_Position.xy *= gl_Position.w;",
    "",
    "}",
    "",
    "void main(void){",
    "",
    "    #ifdef PICKING",
    "        vPickingColor = unpackColor( primitiveId );",
    "    #else",
    "        #include color_vertex",
    "    #endif",
    "",
    "    vRadius = radius * matrixScale( modelViewMatrix );",
    "",
    "    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
    "    // avoid clipping, added again in fragment shader",
    "    mvPosition.z -= vRadius;",
    "",
    "    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );",
    "    ComputePointSizeAndPositionInClipCoordSphere();",
    "",
    "",
    "    vRadiusSq = vRadius * vRadius;",
    "    vec4 vPoint4 = projectionMatrixInverse * gl_Position;",
    "    vPoint = vPoint4.xyz / vPoint4.w;",
    "    vPointViewPosition = -mvPosition.xyz / mvPosition.w;",
    "",
    "}"
].join("\n");

$NGL_shaderTextHash['CylinderImpostor.frag'] = ["#define STANDARD",
    "#define IMPOSTOR",
    "",
    "// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
    "//",
    "//  All Rights Reserved",
    "//",
    "//  Permission to use, copy, modify, distribute, and distribute modified",
    "//  versions of this software and its built-in documentation for any",
    "//  purpose and without fee is hereby granted, provided that the above",
    "//  copyright notice appears in all copies and that both the copyright",
    "//  notice and this permission notice appear in supporting documentation,",
    "//  and that the name of Schrodinger, LLC not be used in advertising or",
    "//  publicity pertaining to distribution of the software without specific,",
    "//  written prior permission.",
    "//",
    "//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
    "//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
    "//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
    "//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
    "//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
    "//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
    "//  USE OR PERFORMANCE OF THIS SOFTWARE.",
    "",
    "// Contributions by Alexander Rose",
    "// - ported to WebGL",
    "// - dual color",
    "// - pk color",
    "// - custom clipping",
    "// - three.js lighting",
    "",
    "uniform vec3 diffuse;",
    "uniform vec3 emissive;",
    "uniform float roughness;",
    "uniform float metalness;",
    "uniform float opacity;",
    "uniform float nearClip;",
    "uniform mat4 projectionMatrix;",
    "uniform float ortho;",
    "",
    "varying vec3 axis;",
    "varying vec4 base_radius;",
    "varying vec4 end_b;",
    "varying vec3 U;",
    "varying vec3 V;",
    "varying vec4 w;",
    "",
    "#ifdef PICKING",
    "    uniform float objectId;",
    "    varying vec3 vPickingColor;",
    "#else",
    "    varying vec3 vColor1;",
    "    varying vec3 vColor2;",
    "    #include common",
    "    #include fog_pars_fragment",
    "    #include bsdfs",
    "    #include lights_pars",
    "    #include lights_physical_pars_fragment",
    "#endif",
    "",
    "bool interior = false;",
    "",
    "float distSq3( vec3 v3a, vec3 v3b ){",
    "    return (",
    "        ( v3a.x - v3b.x ) * ( v3a.x - v3b.x ) +",
    "        ( v3a.y - v3b.y ) * ( v3a.y - v3b.y ) +",
    "        ( v3a.z - v3b.z ) * ( v3a.z - v3b.z )",
    "    );",
    "}",
    "",
    "// Calculate depth based on the given camera position.",
    "float calcDepth( in vec3 cameraPos ){",
    "    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;",
    "    return 0.5 + 0.5 * clipZW.x / clipZW.y;",
    "}",
    "",
    "float calcClip( vec3 cameraPos ){",
    "    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );",
    "}",
    "",
    "void main(){",
    "",
    "    vec3 point = w.xyz / w.w;",
    "",
    "    // unpacking",
    "    vec3 base = base_radius.xyz;",
    "    float vRadius = base_radius.w;",
    "    vec3 end = end_b.xyz;",
    "    float b = end_b.w;",
    "",
    "    vec3 end_cyl = end;",
    "    vec3 surface_point = point;",
    "",
    "    vec3 ray_target = surface_point;",
    "    vec3 ray_origin = vec3(0.0);",
    "    vec3 ray_direction = mix(normalize(ray_origin - ray_target), vec3(0.0, 0.0, 1.0), ortho);",
    "    mat3 basis = mat3( U, V, axis );",
    "",
    "    vec3 diff = ray_target - 0.5 * (base + end_cyl);",
    "    vec3 P = diff * basis;",
    "",
    "    // angle (cos) between cylinder cylinder_axis and ray direction",
    "    float dz = dot( axis, ray_direction );",
    "",
    "    float radius2 = vRadius*vRadius;",
    "",
    "    // calculate distance to the cylinder from ray origin",
    "    vec3 D = vec3(dot(U, ray_direction),",
    "                dot(V, ray_direction),",
    "                dz);",
    "    float a0 = P.x*P.x + P.y*P.y - radius2;",
    "    float a1 = P.x*D.x + P.y*D.y;",
    "    float a2 = D.x*D.x + D.y*D.y;",
    "",
    "    // calculate a dicriminant of the above quadratic equation",
    "    float d = a1*a1 - a0*a2;",
    "    if (d < 0.0)",
    "        // outside of the cylinder",
    "        discard;",
    "",
    "    float dist = (-a1 + sqrt(d)) / a2;",
    "",
    "    // point of intersection on cylinder surface",
    "    vec3 new_point = ray_target + dist * ray_direction;",
    "",
    "    vec3 tmp_point = new_point - base;",
    "    vec3 _normal = normalize( tmp_point - axis * dot(tmp_point, axis) );",
    "",
    "    ray_origin = mix( ray_origin, surface_point, ortho );",
    "",
    "    // test caps",
    "    float front_cap_test = dot( tmp_point, axis );",
    "    float end_cap_test = dot((new_point - end_cyl), axis);",
    "",
    "    // to calculate caps, simply check the angle between",
    "    // the point of intersection - cylinder end vector",
    "    // and a cap plane normal (which is the cylinder cylinder_axis)",
    "    // if the angle < 0, the point is outside of cylinder",
    "    // test front cap",
    "",
    "    #ifndef CAP",
    "        vec3 new_point2 = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
    "        vec3 tmp_point2 = new_point2 - base;",
    "    #endif",
    "",
    "    // flat",
    "    if (front_cap_test < 0.0)",
    "    {",
    "        // ray-plane intersection",
    "        float dNV = dot(-axis, ray_direction);",
    "        if (dNV < 0.0)",
    "            discard;",
    "        float near = dot(-axis, (base)) / dNV;",
    "        vec3 front_point = ray_direction * near + ray_origin;",
    "        // within the cap radius?",
    "        if (dot(front_point - base, front_point-base) > radius2)",
    "            discard;",
    "",
    "        #ifdef CAP",
    "            new_point = front_point;",
    "            _normal = axis;",
    "        #else",
    "            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
    "            dNV = dot(-axis, ray_direction);",
    "            near = dot(axis, end_cyl) / dNV;",
    "            new_point2 = ray_direction * near + ray_origin;",
    "            if (dot(new_point2 - end_cyl, new_point2-base) < radius2)",
    "                discard;",
    "            interior = true;",
    "        #endif",
    "    }",
    "",
    "    // test end cap",
    "",
    "",
    "    // flat",
    "    if( end_cap_test > 0.0 )",
    "    {",
    "        // ray-plane intersection",
    "        float dNV = dot(axis, ray_direction);",
    "        if (dNV < 0.0)",
    "            discard;",
    "        float near = dot(axis, end_cyl) / dNV;",
    "        vec3 end_point = ray_direction * near + ray_origin;",
    "        // within the cap radius?",
    "        if( dot(end_point - end_cyl, end_point-base) > radius2 )",
    "            discard;",
    "",
    "        #ifdef CAP",
    "            new_point = end_point;",
    "            _normal = axis;",
    "        #else",
    "            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
    "            dNV = dot(-axis, ray_direction);",
    "            near = dot(-axis, (base)) / dNV;",
    "            new_point2 = ray_direction * near + ray_origin;",
    "            if (dot(new_point2 - base, new_point2-base) < radius2)",
    "                discard;",
    "            interior = true;",
    "        #endif",
    "    }",
    "",
    "    gl_FragDepthEXT = calcDepth( new_point );",
    "",
    "    #ifdef NEAR_CLIP",
    "        if( calcClip( new_point ) > 0.0 ){",
    "            dist = (-a1 - sqrt(d)) / a2;",
    "            new_point = ray_target + dist * ray_direction;",
    "            if( calcClip( new_point ) > 0.0 )",
    "                discard;",
    "            interior = true;",
    "            gl_FragDepthEXT = calcDepth( new_point );",
    "            if( gl_FragDepthEXT >= 0.0 ){",
    "                gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );",
    "            }",
    "        }else if( gl_FragDepthEXT <= 0.0 ){",
    "            dist = (-a1 - sqrt(d)) / a2;",
    "            new_point = ray_target + dist * ray_direction;",
    "            interior = true;",
    "            gl_FragDepthEXT = calcDepth( new_point );",
    "            if( gl_FragDepthEXT >= 0.0 ){",
    "                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
    "            }",
    "        }",
    "    #else",
    "        if( gl_FragDepthEXT <= 0.0 ){",
    "            dist = (-a1 - sqrt(d)) / a2;",
    "            new_point = ray_target + dist * ray_direction;",
    "            interior = true;",
    "            gl_FragDepthEXT = calcDepth( new_point );",
    "            if( gl_FragDepthEXT >= 0.0 ){",
    "                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
    "            }",
    "        }",
    "    #endif",
    "",
    "    // this is a workaround necessary for Mac",
    "    // otherwise the modified fragment won't clip properly",
    "    if (gl_FragDepthEXT < 0.0)",
    "        discard;",
    "    if (gl_FragDepthEXT > 1.0)",
    "        discard;",
    "",
    "    #ifdef PICKING",
    "",
    "        gl_FragColor = vec4( vPickingColor, objectId );",
    "",
    "    #else",
    "",
    "        vec3 vViewPosition = -new_point;",
    "        vec3 vNormal = _normal;",
    "        vec3 vColor;",
    "",
    "        if( distSq3( new_point, end_cyl ) < distSq3( new_point, base ) ){",
    "            if( b < 0.0 ){",
    "                vColor = vColor1;",
    "            }else{",
    "                vColor = vColor2;",
    "            }",
    "        }else{",
    "            if( b > 0.0 ){",
    "                vColor = vColor1;",
    "            }else{",
    "                vColor = vColor2;",
    "            }",
    "        }",
    "",
    "        vec4 diffuseColor = vec4( diffuse, opacity );",
    "        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
    "        vec3 totalEmissiveLight = emissive;",
    "",
    "        //include color_fragment",
    "         #ifdef USE_COLOR",
    "     diffuseColor.r *= vColor[0];",
    "     diffuseColor.g *= vColor[1];",
    "     diffuseColor.b *= vColor[2];",
    "     #endif",
    "        #include roughnessmap_fragment",
    "        #include metalnessmap_fragment",
    "",
    "        // don't use include normal_fragment",
    "        vec3 normal = normalize( vNormal );",
    "        if( interior ){",
    "            normal = vec3( 0.0, 0.0, 0.4 );",
    "        }",
    "",
    "        #include lights_physical_fragment",
    "        #include lights_template",
    "",
    "        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
    "",
    "        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );",
    "",
    "        #include premultiplied_alpha_fragment",
    "        #include tonemapping_fragment",
    "        #include encodings_fragment",
    "        #include fog_fragment",
    "    #endif",
    "",
    "}"
].join("\n");

$NGL_shaderTextHash['CylinderImpostor.vert'] = ["// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
    "//",
    "//  All Rights Reserved",
    "//",
    "//  Permission to use, copy, modify, distribute, and distribute modified",
    "//  versions of this software and its built-in documentation for any",
    "//  purpose and without fee is hereby granted, provided that the above",
    "//  copyright notice appears in all copies and that both the copyright",
    "//  notice and this permission notice appear in supporting documentation,",
    "//  and that the name of Schrodinger, LLC not be used in advertising or",
    "//  publicity pertaining to distribution of the software without specific,",
    "//  written prior permission.",
    "//",
    "//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
    "//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
    "//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
    "//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
    "//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
    "//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
    "//  USE OR PERFORMANCE OF THIS SOFTWARE.",
    "",
    "// Contributions by Alexander Rose",
    "// - ported to WebGL",
    "// - dual color",
    "// - pk color",
    "// - shift",
    "",
    "attribute vec3 mapping;",
    "attribute vec3 position1;",
    "attribute vec3 position2;",
    "attribute float radius;",
    "",
    "varying vec3 axis;",
    "varying vec4 base_radius;",
    "varying vec4 end_b;",
    "varying vec3 U;",
    "varying vec3 V;",
    "varying vec4 w;",
    "",
    "#ifdef PICKING",
    "    #include unpack_clr",
    "    attribute float primitiveId;",
    "    varying vec3 vPickingColor;",
    "#else",
    "    //attribute vec3 color;",
    "    attribute vec3 color2;",
    "    varying vec3 vColor1;",
    "    varying vec3 vColor2;",
    "#endif",
    "",
    "uniform mat4 modelViewMatrixInverse;",
    "uniform float ortho;",
    "",
    "//include matrix_scale",
    "float matrixScale( in mat4 m ){",
    "    vec4 r = m[ 0 ];",
    "    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
    "}",
    "",
    "void main(){",
    "",
    "    #ifdef PICKING",
    "        vPickingColor = unpackColor( primitiveId );",
    "    #else",
    "        vColor1 = color;",
    "        vColor2 = color2;",
    "    #endif",
    "",
    "    // vRadius = radius;",
    "    base_radius.w = radius * matrixScale( modelViewMatrix );",
    "",
    "    //vec3 center = position;",
    "    vec3 center = ( position2 + position1 ) / 2.0;",
    "    vec3 dir = normalize( position2 - position1 );",
    "    float ext = length( position2 - position1 ) / 2.0;",
    "",
    "    // using cameraPosition fails on some machines, not sure why",
    "    // vec3 cam_dir = normalize( cameraPosition - mix( center, vec3( 0.0 ), ortho ) );",
    "    vec3 cam_dir;",
    "    if( ortho == 0.0 ){",
    "        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center;",
    "    }else{",
    "        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 1, 0 ) ).xyz;",
    "    }",
    "    cam_dir = normalize( cam_dir );",
    "",
    "    vec3 ldir;",
    "",
    "    float b = dot( cam_dir, dir );",
    "    end_b.w = b;",
    "    // direction vector looks away, so flip",
    "    if( b < 0.0 )",
    "        ldir = -ext * dir;",
    "    // direction vector already looks in my direction",
    "    else",
    "        ldir = ext * dir;",
    "",
    "    vec3 left = normalize( cross( cam_dir, ldir ) );",
    "    left = radius * left;",
    "    vec3 up = radius * normalize( cross( left, ldir ) );",
    "",
    "    // transform to modelview coordinates",
    "    axis = normalize( normalMatrix * ldir );",
    "    U = normalize( normalMatrix * up );",
    "    V = normalize( normalMatrix * left );",
    "",
    "    vec4 base4 = modelViewMatrix * vec4( center - ldir, 1.0 );",
    "    base_radius.xyz = base4.xyz / base4.w;",
    "",
    "    vec4 top_position = modelViewMatrix * vec4( center + ldir, 1.0 );",
    "    vec4 end4 = top_position;",
    "    end_b.xyz = end4.xyz / end4.w;",
    "",
    "    w = modelViewMatrix * vec4(",
    "        center + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0",
    "    );",
    "",
    "    gl_Position = projectionMatrix * w;",
    "",
    "    // avoid clipping (1.0 seems to induce flickering with some drivers)",
    "    gl_Position.z = 0.99;",
    "",
    "}"
].join("\n");

$NGL_shaderTextHash['SphereInstancing.frag'] = ["#define STANDARD",
    "#define IMPOSTOR",
    "",
    "uniform vec3 diffuse;",
    "uniform vec3 emissive;",
    "uniform float roughness;",
    "uniform float metalness;",
    "uniform float opacity;",
    "uniform float nearClip;",
    "uniform mat4 projectionMatrix;",
    "uniform float ortho;",
    "",
    "varying float vRadius;",
    "varying float vRadiusSq;",
    "varying vec3 vPoint;",
    "varying vec3 vPointViewPosition;",
    "",
    "#ifdef PICKING",
    "    uniform float objectId;",
    "    varying vec3 vPickingColor;",
    "#else",
    "    #include common",
    "    #include color_pars_fragment",
    "    #include fog_pars_fragment",
    "    #include bsdfs",
    "    #include lights_pars",
    "    #include lights_physical_pars_fragment",
    "#endif",
    "",
    "bool flag2 = false;",
    "bool interior = false;",
    "vec3 cameraPos;",
    "vec3 cameraNormal;",
    "",
    "// Calculate depth based on the given camera position.",
    "float calcDepth( in vec3 cameraPos ){",
    "    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;",
    "    return 0.5 + 0.5 * clipZW.x / clipZW.y;",
    "}",
    "",
    "float calcClip( vec3 cameraPos ){",
    "    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );",
    "}",
    "",
    "bool Impostor( out vec3 cameraPos, out vec3 cameraNormal ){",
    "",
    "    vec3 cameraSpherePos = -vPointViewPosition;",
    "    cameraSpherePos.z += vRadius;",
    "",
    "    vec3 rayOrigin = mix( vec3( 0.0, 0.0, 0.0 ), vPoint, ortho );",
    "    vec3 rayDirection = mix( normalize( vPoint ), vec3( 0.0, 0.0, 1.0 ), ortho );",
    "    vec3 cameraSphereDir = mix( cameraSpherePos, rayOrigin - cameraSpherePos, ortho );",
    "",
    "    float B = dot( rayDirection, cameraSphereDir );",
    "    float det = B * B + vRadiusSq - dot( cameraSphereDir, cameraSphereDir );",
    "",
    "    if( det < 0.0 ){",
    "        discard;",
    "        return false;",
    "    }else{",
    "        float sqrtDet = sqrt( det );",
    "        float posT = mix( B + sqrtDet, B + sqrtDet, ortho );",
    "        float negT = mix( B - sqrtDet, sqrtDet - B, ortho );",
    "",
    "        cameraPos = rayDirection * negT + rayOrigin;",
    "",
    "        #ifdef NEAR_CLIP",
    "if( calcDepth( cameraPos ) <= 0.0 ){",
    "    cameraPos = rayDirection * posT + rayOrigin;",
    "    interior = true;",
    "    return false;",
    "}else if( calcClip( cameraPos ) > 0.0 ){",
    "    cameraPos = rayDirection * posT + rayOrigin;",
    "    interior = true;",
    "    flag2 = true;",
    "    return false;",
    "}else{",
    "    cameraNormal = normalize( cameraPos - cameraSpherePos );",
    "}",
    "        #else",
    "if( calcDepth( cameraPos ) <= 0.0 ){",
    "    cameraPos = rayDirection * posT + rayOrigin;",
    "    interior = true;",
    "    return false;",
    "}else{",
    "    cameraNormal = normalize( cameraPos - cameraSpherePos );",
    "}",
    "        #endif",
    "",
    "        return true;",
    "    }",
    "",
    "    return false; // ensure that each control flow has a return",
    "",
    "}",
    "",
    "void main(void){",
    "",
    "    bool flag = Impostor( cameraPos, cameraNormal );",
    "",
    "    #ifdef NEAR_CLIP",
    "        if( calcClip( cameraPos ) > 0.0 )",
    "            discard;",
    "    #endif",
    "",
    "    // FIXME not compatible with custom clipping plane",
    "    //Set the depth based on the new cameraPos.",
    "    gl_FragDepthEXT = calcDepth( cameraPos );",
    "    if( !flag ){",
    "",
    "        // clamp to near clipping plane and add a tiny value to",
    "        // make spheres with a greater radius occlude smaller ones",
    "        #ifdef NEAR_CLIP",
    "if( flag2 ){",
    "    gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );",
    "}else if( gl_FragDepthEXT >= 0.0 ){",
    "    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
    "}",
    "        #else",
    "if( gl_FragDepthEXT >= 0.0 ){",
    "    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
    "}",
    "        #endif",
    "",
    "    }",
    "",
    "    // bugfix (mac only?)",
    "    if (gl_FragDepthEXT < 0.0)",
    "        discard;",
    "    if (gl_FragDepthEXT > 1.0)",
    "        discard;",
    "",
    "    #ifdef PICKING",
    "",
    "        gl_FragColor = vec4( vPickingColor, objectId );",
    "",
    "    #else",
    "",
    "        vec3 vNormal = cameraNormal;",
    "        vec3 vViewPosition = -cameraPos;",
    "",
    "        vec4 diffuseColor = vec4( diffuse, opacity );",
    "        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
    "        vec3 totalEmissiveLight = emissive;",
    "",
    "        #include color_fragment",
    "        #include roughnessmap_fragment",
    "        #include metalnessmap_fragment",
    "        #include normal_flip",
    "        #include normal_fragment",
    "        if( interior ){",
    "            normal = vec3( 0.0, 0.0, 0.4 );",
    "        }",
    "",
    "        // include lights_phong_fragment",
    "        #include lights_physical_fragment",
    "        #include lights_template",
    "",
    "        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
    "",
    "        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );",
    "",
    "        #include premultiplied_alpha_fragment",
    "        #include tonemapping_fragment",
    "        #include encodings_fragment",
    "        #include fog_fragment",
    "",
    "    #endif",
    "",
    "}"
].join("\n");

$NGL_shaderTextHash['SphereInstancing.vert'] = ["uniform mat4 projectionMatrixInverse;",
    "uniform float nearClip;",
    "",
    "varying float vRadius;",
    "varying float vRadiusSq;",
    "varying vec3 vPoint;",
    "varying vec3 vPointViewPosition;",
    "",
    "attribute vec2 mapping;",
    "//attribute vec3 position;",
    "attribute float radius;",
    "attribute vec4 matrix1;",
    "attribute vec4 matrix2;",
    "attribute vec4 matrix3;",
    "attribute vec4 matrix4;",
    "",
    "#ifdef PICKING",
    "    #include unpack_clr",
    "    attribute float primitiveId;",
    "    varying vec3 vPickingColor;",
    "#else",
    "    #include color_pars_vertex",
    "#endif",
    "",
    "//include matrix_scale",
    "float matrixScale( in mat4 m ){",
    "    vec4 r = m[ 0 ];",
    "    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
    "}",
    "",
    "const mat4 D = mat4(",
    "    1.0, 0.0, 0.0, 0.0,",
    "    0.0, 1.0, 0.0, 0.0,",
    "    0.0, 0.0, 1.0, 0.0,",
    "    0.0, 0.0, 0.0, -1.0",
    ");",
    "",
    "mat4 transpose( in mat4 inMatrix ) {",
    "    vec4 i0 = inMatrix[0];",
    "    vec4 i1 = inMatrix[1];",
    "    vec4 i2 = inMatrix[2];",
    "    vec4 i3 = inMatrix[3];",
    "",
    "    mat4 outMatrix = mat4(",
    "        vec4(i0.x, i1.x, i2.x, i3.x),",
    "        vec4(i0.y, i1.y, i2.y, i3.y),",
    "        vec4(i0.z, i1.z, i2.z, i3.z),",
    "        vec4(i0.w, i1.w, i2.w, i3.w)",
    "    );",
    "    return outMatrix;",
    "}",
    "",
    "//------------------------------------------------------------------------------",
    "// Compute point size and center using the technique described in:",
    "// 'GPU-Based Ray-Casting of Quadratic Surfaces'",
    "// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.",
    "//",
    "// Code based on",
    "/*=========================================================================",
    "",
    " Program:   Visualization Toolkit",
    " Module:    Quadrics_fs.glsl and Quadrics_vs.glsl",
    "",
    " Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen",
    " All rights reserved.",
    " See Copyright.txt or http://www.kitware.com/Copyright.htm for details.",
    "",
    " This software is distributed WITHOUT ANY WARRANTY; without even",
    " the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR",
    " PURPOSE.  See the above copyright notice for more information.",
    "",
    " =========================================================================*/",
    "",
    "// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl",
    "// .SECTION Thanks",
    "// <verbatim>",
    "//",
    "//  This file is part of the PointSprites plugin developed and contributed by",
    "//",
    "//  Copyright (c) CSCS - Swiss National Supercomputing Centre",
    "//                EDF - Electricite de France",
    "//",
    "//  John Biddiscombe, Ugo Varetto (CSCS)",
    "//  Stephane Ploix (EDF)",
    "//",
    "// </verbatim>",
    "//",
    "// Contributions by Alexander Rose",
    "// - ported to WebGL",
    "// - adapted to work with quads",
    "void ComputePointSizeAndPositionInClipCoordSphere(vec4 updatePosition){",
    "",
    "    vec2 xbc;",
    "    vec2 ybc;",
    "",
    "    mat4 T = mat4(",
    "        radius, 0.0, 0.0, 0.0,",
    "        0.0, radius, 0.0, 0.0,",
    "        0.0, 0.0, radius, 0.0,",
    "        updatePosition.x, updatePosition.y, updatePosition.z, 1.0",
    "    );",
    "",
    "    mat4 R = transpose( projectionMatrix * modelViewMatrix * T );",
    "    float A = dot( R[ 3 ], D * R[ 3 ] );",
    "    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );",
    "    float C = dot( R[ 0 ], D * R[ 0 ] );",
    "    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
    "    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
    "    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;",
    "",
    "    A = dot( R[ 3 ], D * R[ 3 ] );",
    "    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );",
    "    C = dot( R[ 1 ], D * R[ 1 ] );",
    "    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
    "    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
    "    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;",
    "",
    "    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );",
    "    gl_Position.xy -= mapping * vec2( sx, sy );",
    "    gl_Position.xy *= gl_Position.w;",
    "",
    "}",
    "",
    "  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {",
    "    return mat4(",
    "      v1.x, v1.y, v1.z, v1.w,",
    "      v2.x, v2.y, v2.z, v2.w,",
    "      v3.x, v3.y, v3.z, v3.w,",
    "      v4.x, v4.y, v4.z, v4.w",
    "    );",
    "  }",
    "",
    "void main(void){",
    "",
    "    #ifdef PICKING",
    "        vPickingColor = unpackColor( primitiveId );",
    "    #else",
    "        #include color_vertex",
    "    #endif",
    "",
    "    vRadius = radius * matrixScale( modelViewMatrix );",
    "",
    "    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);",
    "    vec4 updatePosition = matrix * vec4(position, 1.0);",
    "",
    "//    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
    "    vec4 mvPosition = modelViewMatrix * vec4( updatePosition.xyz, 1.0 );",
    "    // avoid clipping, added again in fragment shader",
    "    mvPosition.z -= vRadius;",
    "",
    "//    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );",
    "    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );",
    "    ComputePointSizeAndPositionInClipCoordSphere(updatePosition);",
    "",
    "",
    "    vRadiusSq = vRadius * vRadius;",
    "    vec4 vPoint4 = projectionMatrixInverse * gl_Position;",
    "    vPoint = vPoint4.xyz / vPoint4.w;",
    "    vPointViewPosition = -mvPosition.xyz / mvPosition.w;",
    "",
    "}"
].join("\n");

$NGL_shaderTextHash['CylinderInstancing.frag'] = ["#define STANDARD",
    "#define IMPOSTOR",
    "",
    "// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
    "//",
    "//  All Rights Reserved",
    "//",
    "//  Permission to use, copy, modify, distribute, and distribute modified",
    "//  versions of this software and its built-in documentation for any",
    "//  purpose and without fee is hereby granted, provided that the above",
    "//  copyright notice appears in all copies and that both the copyright",
    "//  notice and this permission notice appear in supporting documentation,",
    "//  and that the name of Schrodinger, LLC not be used in advertising or",
    "//  publicity pertaining to distribution of the software without specific,",
    "//  written prior permission.",
    "//",
    "//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
    "//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
    "//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
    "//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
    "//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
    "//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
    "//  USE OR PERFORMANCE OF THIS SOFTWARE.",
    "",
    "// Contributions by Alexander Rose",
    "// - ported to WebGL",
    "// - dual color",
    "// - pk color",
    "// - custom clipping",
    "// - three.js lighting",
    "",
    "uniform vec3 diffuse;",
    "uniform vec3 emissive;",
    "uniform float roughness;",
    "uniform float metalness;",
    "uniform float opacity;",
    "uniform float nearClip;",
    "uniform mat4 projectionMatrix;",
    "uniform float ortho;",
    "",
    "varying vec3 axis;",
    "varying vec4 base_radius;",
    "varying vec4 end_b;",
    "varying vec3 U;",
    "varying vec3 V;",
    "varying vec4 w;",
    "",
    "#ifdef PICKING",
    "    uniform float objectId;",
    "    varying vec3 vPickingColor;",
    "#else",
    "    varying vec3 vColor1;",
    "    varying vec3 vColor2;",
    "    #include common",
    "    #include fog_pars_fragment",
    "    #include bsdfs",
    "    #include lights_pars",
    "    #include lights_physical_pars_fragment",
    "#endif",
    "",
    "bool interior = false;",
    "",
    "float distSq3( vec3 v3a, vec3 v3b ){",
    "    return (",
    "        ( v3a.x - v3b.x ) * ( v3a.x - v3b.x ) +",
    "        ( v3a.y - v3b.y ) * ( v3a.y - v3b.y ) +",
    "        ( v3a.z - v3b.z ) * ( v3a.z - v3b.z )",
    "    );",
    "}",
    "",
    "// Calculate depth based on the given camera position.",
    "float calcDepth( in vec3 cameraPos ){",
    "    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;",
    "    return 0.5 + 0.5 * clipZW.x / clipZW.y;",
    "}",
    "",
    "float calcClip( vec3 cameraPos ){",
    "    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );",
    "}",
    "",
    "void main(){",
    "",
    "    vec3 point = w.xyz / w.w;",
    "",
    "    // unpacking",
    "    vec3 base = base_radius.xyz;",
    "    float vRadius = base_radius.w;",
    "    vec3 end = end_b.xyz;",
    "    float b = end_b.w;",
    "",
    "    vec3 end_cyl = end;",
    "    vec3 surface_point = point;",
    "",
    "    vec3 ray_target = surface_point;",
    "    vec3 ray_origin = vec3(0.0);",
    "    vec3 ray_direction = mix(normalize(ray_origin - ray_target), vec3(0.0, 0.0, 1.0), ortho);",
    "    mat3 basis = mat3( U, V, axis );",
    "",
    "    vec3 diff = ray_target - 0.5 * (base + end_cyl);",
    "    vec3 P = diff * basis;",
    "",
    "    // angle (cos) between cylinder cylinder_axis and ray direction",
    "    float dz = dot( axis, ray_direction );",
    "",
    "    float radius2 = vRadius*vRadius;",
    "",
    "    // calculate distance to the cylinder from ray origin",
    "    vec3 D = vec3(dot(U, ray_direction),",
    "                dot(V, ray_direction),",
    "                dz);",
    "    float a0 = P.x*P.x + P.y*P.y - radius2;",
    "    float a1 = P.x*D.x + P.y*D.y;",
    "    float a2 = D.x*D.x + D.y*D.y;",
    "",
    "    // calculate a dicriminant of the above quadratic equation",
    "    float d = a1*a1 - a0*a2;",
    "    if (d < 0.0)",
    "        // outside of the cylinder",
    "        discard;",
    "",
    "    float dist = (-a1 + sqrt(d)) / a2;",
    "",
    "    // point of intersection on cylinder surface",
    "    vec3 new_point = ray_target + dist * ray_direction;",
    "",
    "    vec3 tmp_point = new_point - base;",
    "    vec3 _normal = normalize( tmp_point - axis * dot(tmp_point, axis) );",
    "",
    "    ray_origin = mix( ray_origin, surface_point, ortho );",
    "",
    "    // test caps",
    "    float front_cap_test = dot( tmp_point, axis );",
    "    float end_cap_test = dot((new_point - end_cyl), axis);",
    "",
    "    // to calculate caps, simply check the angle between",
    "    // the point of intersection - cylinder end vector",
    "    // and a cap plane normal (which is the cylinder cylinder_axis)",
    "    // if the angle < 0, the point is outside of cylinder",
    "    // test front cap",
    "",
    "    #ifndef CAP",
    "        vec3 new_point2 = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
    "        vec3 tmp_point2 = new_point2 - base;",
    "    #endif",
    "",
    "    // flat",
    "    if (front_cap_test < 0.0)",
    "    {",
    "        // ray-plane intersection",
    "        float dNV = dot(-axis, ray_direction);",
    "        if (dNV < 0.0)",
    "            discard;",
    "        float near = dot(-axis, (base)) / dNV;",
    "        vec3 front_point = ray_direction * near + ray_origin;",
    "        // within the cap radius?",
    "        if (dot(front_point - base, front_point-base) > radius2)",
    "            discard;",
    "",
    "        #ifdef CAP",
    "            new_point = front_point;",
    "            _normal = axis;",
    "        #else",
    "            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
    "            dNV = dot(-axis, ray_direction);",
    "            near = dot(axis, end_cyl) / dNV;",
    "            new_point2 = ray_direction * near + ray_origin;",
    "            if (dot(new_point2 - end_cyl, new_point2-base) < radius2)",
    "                discard;",
    "            interior = true;",
    "        #endif",
    "    }",
    "",
    "    // test end cap",
    "",
    "",
    "    // flat",
    "    if( end_cap_test > 0.0 )",
    "    {",
    "        // ray-plane intersection",
    "        float dNV = dot(axis, ray_direction);",
    "        if (dNV < 0.0)",
    "            discard;",
    "        float near = dot(axis, end_cyl) / dNV;",
    "        vec3 end_point = ray_direction * near + ray_origin;",
    "        // within the cap radius?",
    "        if( dot(end_point - end_cyl, end_point-base) > radius2 )",
    "            discard;",
    "",
    "        #ifdef CAP",
    "            new_point = end_point;",
    "            _normal = axis;",
    "        #else",
    "            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
    "            dNV = dot(-axis, ray_direction);",
    "            near = dot(-axis, (base)) / dNV;",
    "            new_point2 = ray_direction * near + ray_origin;",
    "            if (dot(new_point2 - base, new_point2-base) < radius2)",
    "                discard;",
    "            interior = true;",
    "        #endif",
    "    }",
    "",
    "    gl_FragDepthEXT = calcDepth( new_point );",
    "",
    "    #ifdef NEAR_CLIP",
    "        if( calcClip( new_point ) > 0.0 ){",
    "            dist = (-a1 - sqrt(d)) / a2;",
    "            new_point = ray_target + dist * ray_direction;",
    "            if( calcClip( new_point ) > 0.0 )",
    "                discard;",
    "            interior = true;",
    "            gl_FragDepthEXT = calcDepth( new_point );",
    "            if( gl_FragDepthEXT >= 0.0 ){",
    "                gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );",
    "            }",
    "        }else if( gl_FragDepthEXT <= 0.0 ){",
    "            dist = (-a1 - sqrt(d)) / a2;",
    "            new_point = ray_target + dist * ray_direction;",
    "            interior = true;",
    "            gl_FragDepthEXT = calcDepth( new_point );",
    "            if( gl_FragDepthEXT >= 0.0 ){",
    "                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
    "            }",
    "        }",
    "    #else",
    "        if( gl_FragDepthEXT <= 0.0 ){",
    "            dist = (-a1 - sqrt(d)) / a2;",
    "            new_point = ray_target + dist * ray_direction;",
    "            interior = true;",
    "            gl_FragDepthEXT = calcDepth( new_point );",
    "            if( gl_FragDepthEXT >= 0.0 ){",
    "                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
    "            }",
    "        }",
    "    #endif",
    "",
    "    // this is a workaround necessary for Mac",
    "    // otherwise the modified fragment won't clip properly",
    "    if (gl_FragDepthEXT < 0.0)",
    "        discard;",
    "    if (gl_FragDepthEXT > 1.0)",
    "        discard;",
    "",
    "    #ifdef PICKING",
    "",
    "        gl_FragColor = vec4( vPickingColor, objectId );",
    "",
    "    #else",
    "",
    "        vec3 vViewPosition = -new_point;",
    "        vec3 vNormal = _normal;",
    "        vec3 vColor;",
    "",
    "        if( distSq3( new_point, end_cyl ) < distSq3( new_point, base ) ){",
    "            if( b < 0.0 ){",
    "                vColor = vColor1;",
    "            }else{",
    "                vColor = vColor2;",
    "            }",
    "        }else{",
    "            if( b > 0.0 ){",
    "                vColor = vColor1;",
    "            }else{",
    "                vColor = vColor2;",
    "            }",
    "        }",
    "",
    "        vec4 diffuseColor = vec4( diffuse, opacity );",
    "        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
    "        vec3 totalEmissiveLight = emissive;",
    "",
    "        //include color_fragment",
    "         #ifdef USE_COLOR",
    "     diffuseColor.r *= vColor[0];",
    "     diffuseColor.g *= vColor[1];",
    "     diffuseColor.b *= vColor[2];",
    "     #endif",
    "        #include roughnessmap_fragment",
    "        #include metalnessmap_fragment",
    "",
    "        // don't use include normal_fragment",
    "        vec3 normal = normalize( vNormal );",
    "        if( interior ){",
    "            normal = vec3( 0.0, 0.0, 0.4 );",
    "        }",
    "",
    "        #include lights_physical_fragment",
    "        #include lights_template",
    "",
    "        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
    "",
    "        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );",
    "",
    "        #include premultiplied_alpha_fragment",
    "        #include tonemapping_fragment",
    "        #include encodings_fragment",
    "        #include fog_fragment",
    "    #endif",
    "",
    "}"
].join("\n");

$NGL_shaderTextHash['CylinderInstancing.vert'] = ["// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
    "//",
    "//  All Rights Reserved",
    "//",
    "//  Permission to use, copy, modify, distribute, and distribute modified",
    "//  versions of this software and its built-in documentation for any",
    "//  purpose and without fee is hereby granted, provided that the above",
    "//  copyright notice appears in all copies and that both the copyright",
    "//  notice and this permission notice appear in supporting documentation,",
    "//  and that the name of Schrodinger, LLC not be used in advertising or",
    "//  publicity pertaining to distribution of the software without specific,",
    "//  written prior permission.",
    "//",
    "//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
    "//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
    "//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
    "//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
    "//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
    "//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
    "//  USE OR PERFORMANCE OF THIS SOFTWARE.",
    "",
    "// Contributions by Alexander Rose",
    "// - ported to WebGL",
    "// - dual color",
    "// - pk color",
    "// - shift",
    "",
    "attribute vec3 mapping;",
    "attribute vec3 position1;",
    "attribute vec3 position2;",
    "attribute float radius;",
    "attribute vec4 matrix1;",
    "attribute vec4 matrix2;",
    "attribute vec4 matrix3;",
    "attribute vec4 matrix4;",
    "",
    "varying vec3 axis;",
    "varying vec4 base_radius;",
    "varying vec4 end_b;",
    "varying vec3 U;",
    "varying vec3 V;",
    "varying vec4 w;",
    "",
    "#ifdef PICKING",
    "    #include unpack_clr",
    "    attribute float primitiveId;",
    "    varying vec3 vPickingColor;",
    "#else",
    "    //attribute vec3 color;",
    "    attribute vec3 color2;",
    "    varying vec3 vColor1;",
    "    varying vec3 vColor2;",
    "#endif",
    "",
    "uniform mat4 modelViewMatrixInverse;",
    "uniform float ortho;",
    "",
    "//include matrix_scale",
    "float matrixScale( in mat4 m ){",
    "    vec4 r = m[ 0 ];",
    "    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
    "}",
    "",
    "  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {",
    "    return mat4(",
    "      v1.x, v1.y, v1.z, v1.w,",
    "      v2.x, v2.y, v2.z, v2.w,",
    "      v3.x, v3.y, v3.z, v3.w,",
    "      v4.x, v4.y, v4.z, v4.w",
    "    );",
    "  }",
    "",
    "void main(){",
    "",
    "    #ifdef PICKING",
    "        vPickingColor = unpackColor( primitiveId );",
    "    #else",
    "        vColor1 = color;",
    "        vColor2 = color2;",
    "    #endif",
    "",
    "    // vRadius = radius;",
    "    base_radius.w = radius * matrixScale( modelViewMatrix );",
    "",
    "    //vec3 center = ( position2 + position1 ) / 2.0;",
    "",
    "    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);",
    "    vec4 updatePosition1 = matrix * vec4(position1, 1.0);",
    "    vec4 updatePosition2 = matrix * vec4(position2, 1.0);",
    "    vec3 center = ( updatePosition2.xyz + updatePosition1.xyz ) / 2.0;",
    "",
    "    //vec3 dir = normalize( position2 - position1 );",
    "    vec3 dir = normalize( updatePosition2.xyz - updatePosition1.xyz );",
    "    float ext = length( position2 - position1 ) / 2.0;",
    "",
    "    // using cameraPosition fails on some machines, not sure why",
    "    // vec3 cam_dir = normalize( cameraPosition - mix( center, vec3( 0.0 ), ortho ) );",
    "    vec3 cam_dir;",
    "    if( ortho == 0.0 ){",
    "        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center;",
    "    }else{",
    "        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 1, 0 ) ).xyz;",
    "    }",
    "    cam_dir = normalize( cam_dir );",
    "",
    "    vec3 ldir;",
    "",
    "    float b = dot( cam_dir, dir );",
    "    end_b.w = b;",
    "    // direction vector looks away, so flip",
    "    if( b < 0.0 )",
    "        ldir = -ext * dir;",
    "    // direction vector already looks in my direction",
    "    else",
    "        ldir = ext * dir;",
    "",
    "    vec3 left = normalize( cross( cam_dir, ldir ) );",
    "    left = radius * left;",
    "    vec3 up = radius * normalize( cross( left, ldir ) );",
    "",
    "    // transform to modelview coordinates",
    "    axis = normalize( normalMatrix * ldir );",
    "    U = normalize( normalMatrix * up );",
    "    V = normalize( normalMatrix * left );",
    "",
    "    vec4 base4 = modelViewMatrix * vec4( center - ldir, 1.0 );",
    "    base_radius.xyz = base4.xyz / base4.w;",
    "",
    "    vec4 top_position = modelViewMatrix * vec4( center + ldir, 1.0 );",
    "    vec4 end4 = top_position;",
    "    end_b.xyz = end4.xyz / end4.w;",
    "",
    "    w = modelViewMatrix * vec4(",
    "        center + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0",
    "    );",
    "",
    "    gl_Position = projectionMatrix * w;",
    "",
    "    // avoid clipping (1.0 seems to induce flickering with some drivers)",
    "    gl_Position.z = 0.99;",
    "",
    "}"
].join("\n");

$NGL_shaderTextHash['Instancing.frag'] = ["#define STANDARD",
    "uniform vec3 diffuse;",
    "uniform vec3 emissive;",
    "uniform float roughness;",
    "uniform float metalness;",
    "uniform float opacity;",
    "uniform float nearClip;",
    "uniform float clipRadius;",
    "uniform mat4 projectionMatrix;",
    "uniform float ortho;",
    "varying float bCylinder;",
    "",
    "#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )",
    "    varying vec3 vViewPosition;",
    "#endif",
    "",
    "#if defined( RADIUS_CLIP )",
    "    varying vec3 vClipCenter;",
    "#endif",
    "",
    "#if defined( PICKING )",
    "    uniform float objectId;",
    "    varying vec3 vPickingColor;",
    "#elif defined( NOLIGHT )",
    "    varying vec3 vColor;",
    "#else",
    "    #ifndef FLAT_SHADED",
    "        varying vec3 vNormal;",
    "    #endif",
    "    #include common",
    "    #include color_pars_fragment",
    "    #include fog_pars_fragment",
    "    #include bsdfs",
    "    #include lights_pars",
    "    #include lights_physical_pars_fragment",
    "#endif",
    "",
    "void main(){",
    "    #include nearclip_fragment",
    "    #include radiusclip_fragment",
    "",
    "    #if defined( PICKING )",
    "",
    "        gl_FragColor = vec4( vPickingColor, objectId );",
    "",
    "    #elif defined( NOLIGHT )",
    "",
    "        gl_FragColor = vec4( vColor, opacity );",
    "",
    "    #else",
    "",
    "        vec4 diffuseColor = vec4( diffuse, opacity );",
    "        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
    "        vec3 totalEmissiveLight = emissive;",
    "",
    "        #include color_fragment",
    "        #include roughnessmap_fragment",
    "        #include metalnessmap_fragment",
    "        #include normal_flip",
    "        //include normal_fragment",
    "        vec3 normal;",
    "        if(bCylinder < 0.5) {",
    "          normal = normalize( vNormal ) * flipNormal;",
    "        } else {",
    "          //https://stackoverflow.com/questions/33094496/three-js-shadermaterial-flatshading",
    "          normal = normalize( cross( dFdx( vViewPosition ), dFdy( vViewPosition ) ) );",
    "        }",
    "",
    "        #include dull_interior_fragment",
    "",
    "        #include lights_physical_fragment",
    "        #include lights_template",
    "",
    "        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
    "",
    "        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "",
    "        #include premultiplied_alpha_fragment",
    "        #include tonemapping_fragment",
    "        #include encodings_fragment",
    "        #include fog_fragment",
    "",
    "        #include opaque_back_fragment",
    "",
    "    #endif",
    "",
    "}"
].join("\n");

$NGL_shaderTextHash['Instancing.vert'] = ["#define STANDARD",
    "",
    "uniform mat4 projectionMatrixInverse;",
    "uniform float nearClip;",
    "uniform vec3 clipCenter;",
    "attribute vec4 matrix1;",
    "attribute vec4 matrix2;",
    "attribute vec4 matrix3;",
    "attribute vec4 matrix4;",
    "attribute float cylinder;",
    "varying float bCylinder;",
    "",
    "#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )",
    "    varying vec3 vViewPosition;",
    "#endif",
    "",
    "#if defined( RADIUS_CLIP )",
    "    varying vec3 vClipCenter;",
    "#endif",
    "",
    "#if defined( PICKING )",
    "    attribute vec3 pickingColor;",
    "    varying vec3 vPickingColor;",
    "#elif defined( NOLIGHT )",
    "    varying vec3 vColor;",
    "#else",
    "    #include color_pars_vertex",
    "    #ifndef FLAT_SHADED",
    "        varying vec3 vNormal;",
    "    #endif",
    "#endif",
    "",
    "#include common",
    "",
    "  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {",
    "    return mat4(",
    "      v1.x, v1.y, v1.z, v1.w,",
    "      v2.x, v2.y, v2.z, v2.w,",
    "      v3.x, v3.y, v3.z, v3.w,",
    "      v4.x, v4.y, v4.z, v4.w",
    "    );",
    "  }",
    "",
    "void main(){",
    "    bCylinder = cylinder;",
    "",
    "    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);",
    "    vec4 updatePosition = matrix * vec4(position, 1.0);",
    "",
    "    //include begin_vertex",
    "    vec3 transformed = updatePosition.xyz;",
    "    //include project_vertex",
    "    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );",
    "    gl_Position = projectionMatrix * mvPosition;",
    "",
    "    #if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )",
    "        vViewPosition = -mvPosition.xyz;",
    "    #endif",
    "",
    "    #if defined( RADIUS_CLIP )",
    "        vClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;",
    "    #endif",
    "",
    "    #include nearclip_vertex",
    "",
    "    #if defined( PICKING )",
    "        vPickingColor = pickingColor;",
    "    #elif defined( NOLIGHT )",
    "        vColor = color;",
    "    #else",
    "        #include color_vertex",
    "        //include beginnormal_vertex",
    "        //vec3 objectNormal = vec3( normal );",
    "        vec3 objectNormal = vec3(matrix * vec4(normal,0.0));",
    "        #include defaultnormal_vertex",
    "        // Normal computed with derivatives when FLAT_SHADED",
    "        #ifndef FLAT_SHADED",
    "            vNormal = normalize( transformedNormal );",
    "        #endif",
    "    #endif",
    "",
    "}"
].join("\n");

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

if (typeof jQuery === 'undefined') { throw new Error('iCn3D requires jQuery') }

var iCn3D = function (id) {
    this.REVISION = '1.3';
    this.id = id;

    this.container = $('#' + id);

    this.overdraw = 0;

    this.bDrawn = false;

    this.bSecondaryStructure = false;

    this.bHighlight = 1; // undefined: no highlight, 1: highlight by outline, 2: highlight by 3D object
    this.renderOrderPicking = -1; // less than 0, the default order

    this.ALTERNATE_STRUCTURE = -1;

    if (Detector.webgl) {
        this.renderer = new THREE.WebGLRenderer({
            canvas: this.container.get(0),
            antialias: true,
            preserveDrawingBuffer: true,
            alpha: true
        });

        this.overdraw = 0;
    }
    else {
        alert("Currently your web browser has a problem on WebGL. If you are using Chrome, open a new tab for the same URL and WebGL may work again.");
        /*
                alert("Currently your web browser has a problem on WebGL, and CanvasRenderer instead of WebGLRenderer is used. If you are using Chrome, open a new tab for the same URL and WebGL may work again.");
        
                this.renderer = new THREE.CanvasRenderer({
                    canvas: this.container.get(0)
                });
        
                //http://threejs.org/docs/api/materials/Material.html
                this.overdraw = 0.5;
        
                // only WebGL support outlines using ShaderMaterial
                this.bHighlight = 2;
        */
    }

    this.matShader = this.setOutlineColor('yellow');
    this.frac = new THREE.Color(0.1, 0.1, 0.1);

    // mobile has a problem when the scaleFactor is 2.0
    // the scaleFactor improve the image quality
    this.scaleFactor = 1.5;

    // Impostor shaders
    this.bImpo = true;
    this.bExtFragDepth = this.renderer.extensions.get("EXT_frag_depth");
    if (!this.bExtFragDepth) {
        this.bImpo = false;
        console.log('EXT_frag_depth is NOT supported. All spheres and cylinders are drawn using geometry.');
    }
    else {
        console.log('EXT_frag_depth is supported. All spheres and cylinders are drawn using shaders.');
    }

    this.bInstanced = this.renderer.extensions.get("ANGLE_instanced_arrays");
    if (!this.bInstanced) {
        console.log('ANGLE_instanced_arrays is NOT supported. Assembly is drawn by making copies of the asymmetric unit.');
    }
    else {
        console.log('ANGLE_instanced_arrays is supported. Assembly is drawn with one copy of the asymmetric unit using hardware instancing.');
    }

    // cylinder impostor
    this.posArray = new Array();
    this.colorArray = new Array();

    this.pos2Array = new Array();
    this.color2Array = new Array();

    this.radiusArray = new Array();

    // sphere impostor
    this.posArraySphere = new Array();
    this.colorArraySphere = new Array();
    this.radiusArraySphere = new Array();

    // adjust the size
    this.WIDTH = this.container.width(), this.HEIGHT = this.container.height();
    this.setWidthHeight(this.WIDTH, this.HEIGHT);

    this.axis = false;  // used to turn on and off xyz axes

    // pk
    this.pk = 1; // 0: no pk, 1: pk on atoms, 2: pk on residues, 3: pk on strand/helix/coil, 4: pk on chain
    this.highlightlevel = 1; // 1: highlight on atoms, 2: highlight on residues, 3: highlight on strand/helix/coil 4: highlight on chain 5: highlight on structure

    this.pickpair = false; // used for pk pair of atoms for label and distance
    this.pAtomNum = 0;

    this.pAtom = undefined;
    this.pAtom2 = undefined;

    this.bCtrl = false; // if true, union selection on sequence window or on 3D structure
    this.bShift = false; // if true, select a range on 3D structure

    this.bStopRotate = false; // by default, do not stop the possible automatic rotation
    this.bCalphaOnly = false; // by default the input has both Calpha and O, used for drawing strands. If atoms have Calpha only, the orientation of the strands is random
    //    this.bSSOnly = false; // a flag to turn on when only helix and bricks are available to draw 3D dgm

    this.bAllAtoms = true; // no need to adjust atom for strand style

    this.bConsiderNeighbors = false; // a flag to show surface considering the neighboring atoms or not

    this.bShowCrossResidueBond = false;

    this.effects = {
        //'anaglyph': new THREE.AnaglyphEffect(this.renderer),
        //'parallax barrier': new THREE.ParallaxBarrierEffect(this.renderer),
        //'oculus rift': new THREE.OculusRiftEffect(this.renderer),
        //'stereo': new THREE.StereoEffect(this.renderer),
        'none': this.renderer
    };

    this.maxD = 500; // size of the molecule
    this.oriMaxD = this.maxD; // size of the molecule
    //this.cam_z = -150;

    this.cam_z = this.maxD * 2; // when zooming in, it gets dark if the camera is in front
    //this.cam_z = -this.maxD * 2;

    // these variables will not be cleared for each structure
    this.commands = []; // a list of commands, ordered by the operation steps. Each operation will be converted into a command. this command list can be used to go backward and forward.
    this.optsHistory = []; // a list of options corresponding to this.commands.
    this.logs = []; // a list of comands and other logs, ordered by the operation steps.

    this.bRender = true; // a flag to turn off rendering when loading state file

    // Default values
    this.hColor = new THREE.Color(0xFFFF00);

    this.sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
    this.boxGeometry = new THREE.BoxGeometry(1, 1, 1);
    this.cylinderGeometry = new THREE.CylinderGeometry(1, 1, 1, 32, 1);
    this.cylinderGeometryOutline = new THREE.CylinderGeometry(1, 1, 1, 32, 1, true);
    this.axisDIV = 5; // 3
    this.strandDIV = 6;
    this.tubeDIV = 8;
    this.nucleicAcidStrandDIV = 6; //4;

    this.linewidth = 1;
    this.hlLineRadius = 0.1; // style line, highlight
    //this.curveWidth = 3;

    this.lineRadius = 0.1; // hbonds, distance lines
    this.coilWidth = 0.3; //0.4; // style cartoon-coil
    this.cylinderRadius = 0.4; // style stick
    this.traceRadius = 0.4; //0.2; // c alpha trace, nucleotide stick
    this.dotSphereScale = 0.3; // style ball and stick, dot
    this.sphereRadius = 1.5; // style sphere
    this.cylinderHelixRadius = 1.6; // style sylinder and plate

    this.ribbonthickness = 0.2; // 0.4; // style ribbon, nucleotide cartoon, stand thickness
    this.helixSheetWidth = 1.3; // style ribbon, nucleotide cartoon, stand thickness
    this.nucleicAcidWidth = 0.8; // nucleotide cartoon

    this.threshbox = 180; // maximum possible boxsize, default 180
    this.maxAtoms3DMultiFile = 40000; // above the threshold, multiple files wil be output for 3D printing

    this.LABELSIZE = 30;

    this.opts = {
        camera: 'perspective',
        background: 'transparent',
        color: 'chain',
        sidec: 'nothing',
        proteins: 'ribbon',
        nucleotides: 'nucleotide cartoon',
        surface: 'nothing',
        wireframe: 'no',
        opacity: '1.0',
        chemicals: 'stick',
        water: 'nothing',
        ions: 'sphere',
        //labels: 'no',
        //effect: 'none',
        hbonds: 'no',
        //stabilizer: 'no',
        ssbonds: 'no',
        //ncbonds: 'no',
        labels: 'no',
        lines: 'no',
        rotationcenter: 'molecule center',
        axis: 'no',
        fog: 'no',
        slab: 'no',
        pk: 'residue',
        nucleotides: 'nucleotide cartoon',
        chemicalbinding: 'hide'
    };

    this._zoomFactor = 1.0;
    this.mouseChange = new THREE.Vector2(0, 0);
    this.quaternion = new THREE.Quaternion(0, 0, 0, 1);

    var me = this;
    this.container.bind('contextmn', function (e) {
        e.preventDefault();
    });

    me.switchHighlightLevel();

    // key event has to use the document because it requires the focus
    me.typetext = false;

    //http://unixpapa.com/js/key.html
    $(document).bind('keyup', function (e) {
        if (e.keyCode === 16) { // shiftKey
            me.bShift = false;
        }
        if (e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) { // ctrlKey or apple command key
            me.bCtrl = false;
        }
    });

    $('input[type=text], textarea').focus(function () {
        me.typetext = true;
    });

    $('input[type=text], textarea').blur(function () {
        me.typetext = false;
    });

    $(document).bind('keydown', function (e) {
        if (e.shiftKey || e.keyCode === 16) {
            me.bShift = true;
        }
        if (e.ctrlKey || e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) {
            me.bCtrl = true;
        }

        if (!me.controls) return;

        me.bStopRotate = true;

        if (!me.typetext) {
            // zoom
            if (e.keyCode === 90) { // Z
                var para = {};

                if (me.cam === me.perspectiveCamera) { // perspective
                    para._zoomFactor = 0.9;
                }
                else if (me.cam === me.orthographicCamera) {  // orthographics
                    if (me._zoomFactor < 0.1) {
                        me._zoomFactor = 0.1;
                    }
                    else if (me._zoomFactor > 1) {
                        me._zoomFactor = 1;
                    }

                    para._zoomFactor = me._zoomFactor * 0.8;
                    if (para._zoomFactor < 0.1) para._zoomFactor = 0.1;
                }

                para.update = true;
                me.controls.update(para);
                me.render();
            }
            else if (e.keyCode === 88) { // X
                var para = {};

                if (me.cam === me.perspectiveCamera) { // perspective
                    //para._zoomFactor = 1.1;
                    para._zoomFactor = 1.03;
                }
                else if (me.cam === me.orthographicCamera) {  // orthographics
                    if (me._zoomFactor > 10) {
                        me._zoomFactor = 10;
                    }
                    else if (me._zoomFactor < 1) {
                        me._zoomFactor = 1;
                    }

                    para._zoomFactor = me._zoomFactor * 1.01;
                    if (para._zoomFactor > 10) para._zoomFactor = 10;
                }

                para.update = true;
                me.controls.update(para);
                me.render();
            }

            // rotate
            else if (e.keyCode === 76) { // L, rotate left
                var axis = new THREE.Vector3(0, 1, 0);
                var angle = -5.0 / 180.0 * Math.PI;

                me.setRotation(axis, angle);
            }
            else if (e.keyCode === 74) { // J, rotate right
                var axis = new THREE.Vector3(0, 1, 0);
                var angle = 5.0 / 180.0 * Math.PI;

                me.setRotation(axis, angle);
            }
            else if (e.keyCode === 73) { // I, rotate up
                var axis = new THREE.Vector3(1, 0, 0);
                var angle = -5.0 / 180.0 * Math.PI;

                me.setRotation(axis, angle);
            }
            else if (e.keyCode === 77) { // M, rotate down
                var axis = new THREE.Vector3(1, 0, 0);
                var angle = 5.0 / 180.0 * Math.PI;

                me.setRotation(axis, angle);
            }

            else if (e.keyCode === 65) { // A, alternate
                if (Object.keys(me.structures) > 1) me.alternateStructures();
            }

        }
    });

    this.container.bind('mouseup touchend', function (e) {
        me.isDragging = false;
    });
    this.container.bind('mousedown touchstart', function (e) {
        e.preventDefault();

        if (!me.scene) return;

        me.bStopRotate = true;

        var x = e.pageX, y = e.pageY;
        if (e.originalEvent.targetTouches && e.originalEvent.targetTouches[0]) {
            x = e.originalEvent.targetTouches[0].pageX;
            y = e.originalEvent.targetTouches[0].pageY;
        }
        me.isDragging = true;

        // see ref http://soledadpenades.com/articles/three-js-tutorials/object-pk/
        if (me.pk && (e.altKey || e.ctrlKey || e.shiftKey || e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91)) {
            me.highlightlevel = me.pk;

            me.mouse.x = ((x - me.container.offset().left) / me.container.width()) * 2 - 1;
            me.mouse.y = - ((y - me.container.offset().top) / me.container.height()) * 2 + 1;

            var mouse3 = new THREE.Vector3();
            mouse3.x = me.mouse.x;
            mouse3.y = me.mouse.y;
            //mouse3.z = 0.5;
            if (this.cam_z > 0) {
                mouse3.z = -1.0; // between -1 to 1. The z positio of mouse in the real world should be between the camera and the target."-1" worked in our case.
            }
            else {
                mouse3.z = 1.0; // between -1 to 1. The z positio of mouse in the real world should be between the camera and the target."-1" worked in our case.
            }

            // similar to setFromCamera() except mouse3.z is the opposite sign from the value in setFromCamera()
            if (me.cam === me.perspectiveCamera) { // perspective
                if (this.cam_z > 0) {
                    mouse3.z = -1.0;
                }
                else {
                    mouse3.z = 1.0;
                }
                //me.projector.unprojectVector( mouse3, me.cam );  // works for all versions
                mouse3.unproject(me.cam);  // works for all versions
                me.raycaster.set(me.cam.position, mouse3.sub(me.cam.position).normalize()); // works for all versions
            }
            else if (me.cam === me.orthographicCamera) {  // orthographics
                if (this.cam_z > 0) {
                    mouse3.z = 1.0;
                }
                else {
                    mouse3.z = -1.0;
                }
                //me.projector.unprojectVector( mouse3, me.cam );  // works for all versions
                mouse3.unproject(me.cam);  // works for all versions
                me.raycaster.set(mouse3, new THREE.Vector3(0, 0, -1).transformDirection(me.cam.matrixWorld)); // works for all versions
            }

            var intersects = me.raycaster.intersectObjects(me.objects); // not all "mdl" group will be used for pk

            var bFound = false;

            var position = me.mdl.position;
            if (intersects.length > 0) {
                // the intersections are sorted so that the closest point is the first one.
                intersects[0].point.sub(position); // mdl.position was moved to the original (0,0,0) after reading the molecule coordinates. The raycasting was done based on the original. The positio of the ooriginal should be substracted.

                var threshold = 0.5;
                var atom = me.getAtomsFromPosition(intersects[0].point, threshold); // the second parameter is the distance threshold. The first matched atom will be returned. Use 1 angstrom, not 2 angstrom. If it's 2 angstrom, other atom will be returned.

                while (!atom && threshold < 10) {
                    threshold = threshold + 0.5;
                    atom = me.getAtomsFromPosition(intersects[0].point, threshold);
                }

                if (atom) {
                    bFound = true;
                    if (me.pickpair) {
                        if (me.pAtomNum % 2 === 0) {
                            me.pAtom = atom;
                        }
                        else {
                            me.pAtom2 = atom;
                        }

                        ++me.pAtomNum;
                    }
                    else {
                        me.pAtom = atom;
                    }

                    me.showPicking(atom);
                }
                else {
                    console.log("No atoms were found in 10 andstrom range");
                }
            } // end if

            if (!bFound) {
                intersects = me.raycaster.intersectObjects(me.objects_ghost); // not all "mdl" group will be used for pk

                position = me.mdl_ghost.position;
                if (intersects.length > 0) {
                    // the intersections are sorted so that the closest point is the first one.
                    intersects[0].point.sub(position); // mdl.position was moved to the original (0,0,0) after reading the molecule coordinates. The raycasting was done based on the original. The positio of the ooriginal should be substracted.

                    var threshold = 0.5;
                    var atom = me.getAtomsFromPosition(intersects[0].point, threshold); // the second parameter is the distance threshold. The first matched atom will be returned. Use 1 angstrom, not 2 angstrom. If it's 2 angstrom, other atom will be returned.

                    while (!atom && threshold < 10) {
                        threshold = threshold + 0.5;
                        atom = me.getAtomsFromPosition(intersects[0].point, threshold);
                    }

                    if (atom) {
                        if (me.pickpair) {
                            if (me.pAtomNum % 2 === 0) {
                                me.pAtom = atom;
                            }
                            else {
                                me.pAtom2 = atom;
                            }

                            ++me.pAtomNum;
                        }
                        else {
                            me.pAtom = atom;
                        }

                        me.showPicking(atom);
                    }
                    else {
                        console.log("No atoms were found in 10 andstrom range");
                    }
                } // end if
            }
        }

        me.controls.handleResize();
        me.controls.update();
        me.render();
    });
    this.container.bind('mousemove touchmove', function (e) {
        e.preventDefault();
        if (!me.scene) return;
        // no action when no mouse button is clicked and no key was down
        if (!me.isDragging) return;

        me.controls.handleResize();
        me.controls.update();
        me.render();
    });
    this.container.bind('mousewheel', function (e) {
        e.preventDefault();
        if (!me.scene) return;

        me.bStopRotate = true;

        me.controls.handleResize();
        me.controls.update();

        me.render();
    });
    this.container.bind('DOMMouseScroll', function (e) {
        e.preventDefault();
        if (!me.scene) return;

        me.bStopRotate = true;

        me.controls.handleResize();
        me.controls.update();

        me.render();
    });
};

iCn3D.prototype = {

    constructor: iCn3D,

    setRotation: function (axis, angle) {
        var me = this;
        axis.applyQuaternion(me.cam.quaternion).normalize();

        var quaternion = new THREE.Quaternion();
        quaternion.setFromAxisAngle(axis, -angle);

        var para = {};
        para.quaternion = quaternion;
        para.update = true;

        me.controls.update(para);
        me.render();
    },

    setOutlineColor: function (colorStr) {
        // outline using ShaderMaterial: http://jsfiddle.net/Eskel/g593q/9/
        var shader = {
            'outline': {
                vertex_shader: [
                    "uniform float offset;",
                    "void main() {",
                    "vec4 pos = modelViewMatrix * vec4( position + normal * offset, 1.0 );",
                    "gl_Position = projectionMatrix * pos;",
                    "}"
                ].join("\n"),

                fragment_shader: [
                    "void main(){",
                    "gl_FragColor = vec4( 1.0, 1.0, 0.0, 1.0 );",
                    "}"
                ].join("\n")
            }
        };

        if (colorStr === 'yellow') {
            shader.outline.fragment_shader = [
                "void main(){",
                "gl_FragColor = vec4( 1.0, 1.0, 0.0, 1.0 );",
                "}"
            ].join("\n");
        }
        else if (colorStr === 'green') {
            shader.outline.fragment_shader = [
                "void main(){",
                "gl_FragColor = vec4( 0.0, 1.0, 0.0, 1.0 );",
                "}"
            ].join("\n");
        }
        else if (colorStr === 'red') {
            shader.outline.fragment_shader = [
                "void main(){",
                "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );",
                "}"
            ].join("\n");
        }

        // shader
        var uniforms = {
            offset: {
                type: "f",
                //value: 1
                value: 0.5
            }
        };

        var outShader = shader['outline'];

        var matShader = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: outShader.vertex_shader,
            fragmentShader: outShader.fragment_shader,
            depthTest: false,
            depthWrite: false,
            needsUpdate: true
        });

        return matShader;
    },

    // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
    setWidthHeight: function (width, height) {
        //this.renderer.setSize(width, height);

        //antialiasing by render twice large:
        //https://stackoverflow.com/questions/17224795/antialiasing-not-working-in-three-js
        this.renderer.setSize(width * this.scaleFactor, height * this.scaleFactor);
        this.renderer.domElement.style.width = width + "px";
        this.renderer.domElement.style.height = height + "px";
        this.renderer.domElement.width = width * this.scaleFactor;
        this.renderer.domElement.height = height * this.scaleFactor;

        this.container.widthInv = 1 / (this.scaleFactor * width);
        this.container.heightInv = 1 / (this.scaleFactor * height);
        this.container.whratio = width / height;
    },

    // added nucleotides and ions
    nucleotidesArray: ['  G', '  A', '  T', '  C', '  U', ' DG', ' DA', ' DT', ' DC', ' DU'],

    ionsArray: ['  K', ' NA', ' MG', ' AL', ' CA', ' TI', ' MN', ' FE', ' NI', ' CU', ' ZN', ' AG', ' BA', '  F', ' CL', ' BR', '  I'],

    vdwRadii: { // Hu, S.Z.; Zhou, Z.H.; Tsai, K.R. Acta Phys.-Chim. Sin., 2003, 19:1073.
        H: 1.08,
        HE: 1.34,
        LI: 1.75,
        BE: 2.05,
        B: 1.47,
        C: 1.49,
        N: 1.41,
        O: 1.40,
        F: 1.39,
        NE: 1.68,
        NA: 1.84,
        MG: 2.05,
        AL: 2.11,
        SI: 2.07,
        P: 1.92,
        S: 1.82,
        CL: 1.83,
        AR: 1.93,
        K: 2.05,
        CA: 2.21,
        SC: 2.16,
        TI: 1.87,
        V: 1.79,
        CR: 1.89,
        MN: 1.97,
        FE: 1.94,
        CO: 1.92,
        NI: 1.84,
        CU: 1.86,
        ZN: 2.10,
        GA: 2.08,
        GE: 2.15,
        AS: 2.06,
        SE: 1.93,
        BR: 1.98,
        KR: 2.12,
        RB: 2.16,
        SR: 2.24,
        Y: 2.19,
        ZR: 1.86,
        NB: 2.07,
        MO: 2.09,
        TC: 2.09,
        RU: 2.07,
        RH: 1.95,
        PD: 2.02,
        AG: 2.03,
        CD: 2.30,
        IN: 2.36,
        SN: 2.33,
        SB: 2.25,
        TE: 2.23,
        I: 2.23,
        XE: 2.21,
        CS: 2.22,
        BA: 2.51,
        LA: 2.40,
        CE: 2.35,
        PR: 2.39,
        ND: 2.29,
        PM: 2.36,
        SM: 2.29,
        EU: 2.33,
        GD: 2.37,
        TB: 2.21,
        DY: 2.29,
        HO: 2.16,
        ER: 2.35,
        TM: 2.27,
        YB: 2.42,
        LU: 2.21,
        HF: 2.12,
        TA: 2.17,
        W: 2.10,
        RE: 2.17,
        OS: 2.16,
        IR: 2.02,
        PT: 2.09,
        AU: 2.17,
        HG: 2.09,
        TL: 2.35,
        PB: 2.32,
        BI: 2.43,
        PO: 2.29,
        AT: 2.36,
        RN: 2.43,
        FR: 2.56,
        RA: 2.43,
        AC: 2.60,
        TH: 2.37,
        PA: 2.43,
        U: 2.40,
        NP: 2.21,
        PU: 2.56,
        AM: 2.56,
        CM: 2.56,
        BK: 2.56,
        CF: 2.56,
        ES: 2.56,
        FM: 2.56,
    },

    covalentRadii: { // http://en.wikipedia.org/wiki/Covalent_radius
        H: 0.31,
        HE: 0.28,
        LI: 1.28,
        BE: 0.96,
        B: 0.84,
        C: 0.76,
        N: 0.71,
        O: 0.66,
        F: 0.57,
        NE: 0.58,
        NA: 1.66,
        MG: 1.41,
        AL: 1.21,
        SI: 1.11,
        P: 1.07,
        S: 1.05,
        CL: 1.02,
        AR: 1.06,
        K: 2.03,
        CA: 1.76,
        SC: 1.70,
        TI: 1.60,
        V: 1.53,
        CR: 1.39,
        MN: 1.39,
        FE: 1.32,
        CO: 1.26,
        NI: 1.24,
        CU: 1.32,
        ZN: 1.22,
        GA: 1.22,
        GE: 1.20,
        AS: 1.19,
        SE: 1.20,
        BR: 1.20,
        KR: 1.16,
        RB: 2.20,
        SR: 1.95,
        Y: 1.90,
        ZR: 1.75,
        NB: 1.64,
        MO: 1.54,
        TC: 1.47,
        RU: 1.46,
        RH: 1.42,
        PD: 1.39,
        AG: 1.45,
        CD: 1.44,
        IN: 1.42,
        SN: 1.39,
        SB: 1.39,
        TE: 1.38,
        I: 1.39,
        XE: 1.40,
        CS: 2.44,
        BA: 2.15,
        LA: 2.07,
        CE: 2.04,
        PR: 2.03,
        ND: 2.01,
        PM: 1.99,
        SM: 1.98,
        EU: 1.98,
        GD: 1.96,
        TB: 1.94,
        DY: 1.92,
        HO: 1.92,
        ER: 1.89,
        TM: 1.90,
        YB: 1.87,
        LU: 1.87,
        HF: 1.75,
        TA: 1.70,
        W: 1.62,
        RE: 1.51,
        OS: 1.44,
        IR: 1.41,
        PT: 1.36,
        AU: 1.36,
        HG: 1.32,
        TL: 1.45,
        PB: 1.46,
        BI: 1.48,
        PO: 1.40,
        AT: 1.50,
        RN: 1.50,
        FR: 2.60,
        RA: 2.21,
        AC: 2.15,
        TH: 2.06,
        PA: 2.00,
        U: 1.96,
        NP: 1.90,
        PU: 1.87,
        AM: 1.80,
        CM: 1.69,
    },

    //rasmol-like element colors
    atomColors: {
        'H': new THREE.Color(0xFFFFFF),
        'He': new THREE.Color(0xFFC0CB),
        'HE': new THREE.Color(0xFFC0CB),
        'Li': new THREE.Color(0xB22222),
        'LI': new THREE.Color(0xB22222),
        'B': new THREE.Color(0x00FF00),
        'C': new THREE.Color(0xC8C8C8),
        'N': new THREE.Color(0x8F8FFF),
        'O': new THREE.Color(0xF00000),
        'F': new THREE.Color(0xDAA520),
        'Na': new THREE.Color(0x0000FF),
        'NA': new THREE.Color(0x0000FF),
        'Mg': new THREE.Color(0x228B22),
        'MG': new THREE.Color(0x228B22),
        'Al': new THREE.Color(0x808090),
        'AL': new THREE.Color(0x808090),
        'Si': new THREE.Color(0xDAA520),
        'SI': new THREE.Color(0xDAA520),
        'P': new THREE.Color(0xFFA500),
        'S': new THREE.Color(0xFFC832),
        'Cl': new THREE.Color(0x00FF00),
        'CL': new THREE.Color(0x00FF00),
        'Ca': new THREE.Color(0x808090),
        'CA': new THREE.Color(0x808090),
        'Ti': new THREE.Color(0x808090),
        'TI': new THREE.Color(0x808090),
        'Cr': new THREE.Color(0x808090),
        'CR': new THREE.Color(0x808090),
        'Mn': new THREE.Color(0x808090),
        'MN': new THREE.Color(0x808090),
        'Fe': new THREE.Color(0xFFA500),
        'FE': new THREE.Color(0xFFA500),
        'Ni': new THREE.Color(0xA52A2A),
        'NI': new THREE.Color(0xA52A2A),
        'Cu': new THREE.Color(0xA52A2A),
        'CU': new THREE.Color(0xA52A2A),
        'Zn': new THREE.Color(0xA52A2A),
        'ZN': new THREE.Color(0xA52A2A),
        'Br': new THREE.Color(0xA52A2A),
        'BR': new THREE.Color(0xA52A2A),
        'Ag': new THREE.Color(0x808090),
        'AG': new THREE.Color(0x808090),
        'I': new THREE.Color(0xA020F0),
        'Ba': new THREE.Color(0xFFA500),
        'BA': new THREE.Color(0xFFA500),
        'Au': new THREE.Color(0xDAA520),
        'AU': new THREE.Color(0xDAA520)
    },

    defaultAtomColor: new THREE.Color(0xCCCCCC),

    stdChainColors: [
        // first 6 colors from MMDB
        new THREE.Color(0xFF00FF),
        new THREE.Color(0x0000FF),
        new THREE.Color(0x996633),
        new THREE.Color(0x00FF99),
        new THREE.Color(0xFF9900),
        new THREE.Color(0xFF6666),

        new THREE.Color(0x32CD32),
        new THREE.Color(0x1E90FF),
        new THREE.Color(0xFA8072),
        new THREE.Color(0xFFA500),
        new THREE.Color(0x00CED1),
        new THREE.Color(0xFF69B4),

        new THREE.Color(0x00FF00),
        new THREE.Color(0x0000FF),
        new THREE.Color(0xFF0000),
        new THREE.Color(0xFFFF00),
        new THREE.Color(0x00FFFF),
        new THREE.Color(0xFF00FF),

        new THREE.Color(0x3CB371),
        new THREE.Color(0x4682B4),
        new THREE.Color(0xCD5C5C),
        new THREE.Color(0xFFE4B5),
        new THREE.Color(0xAFEEEE),
        new THREE.Color(0xEE82EE),

        new THREE.Color(0x006400),
        new THREE.Color(0x00008B),
        new THREE.Color(0x8B0000),
        new THREE.Color(0xCD853F),
        new THREE.Color(0x008B8B),
        new THREE.Color(0x9400D3)
    ],

    backgroundColors: {
        black: new THREE.Color(0x000000),
        grey: new THREE.Color(0xCCCCCC),
        white: new THREE.Color(0xFFFFFF),
        transparent: new THREE.Color(0x000000)
    },

    residueColors: {
        ALA: new THREE.Color(0xC8C8C8),
        ARG: new THREE.Color(0x145AFF),
        ASN: new THREE.Color(0x00DCDC),
        ASP: new THREE.Color(0xE60A0A),
        CYS: new THREE.Color(0xE6E600),
        GLN: new THREE.Color(0x00DCDC),
        GLU: new THREE.Color(0xE60A0A),
        GLY: new THREE.Color(0xEBEBEB),
        HIS: new THREE.Color(0x8282D2),
        ILE: new THREE.Color(0x0F820F),
        LEU: new THREE.Color(0x0F820F),
        LYS: new THREE.Color(0x145AFF),
        MET: new THREE.Color(0xE6E600),
        PHE: new THREE.Color(0x3232AA),
        PRO: new THREE.Color(0xDC9682),
        SER: new THREE.Color(0xFA9600),
        THR: new THREE.Color(0xFA9600),
        TRP: new THREE.Color(0xB45AB4),
        TYR: new THREE.Color(0x3232AA),
        VAL: new THREE.Color(0x0F820F),
        ASX: new THREE.Color(0xFF69B4),
        GLX: new THREE.Color(0xFF69B4),
    },

    defaultResidueColor: new THREE.Color(0xBEA06E),

    chargeColors: {
        // charged residues
        '  G': new THREE.Color(0xFF0000),
        '  A': new THREE.Color(0xFF0000),
        '  T': new THREE.Color(0xFF0000),
        '  C': new THREE.Color(0xFF0000),
        '  U': new THREE.Color(0xFF0000),
        ' DG': new THREE.Color(0xFF0000),
        ' DA': new THREE.Color(0xFF0000),
        ' DT': new THREE.Color(0xFF0000),
        ' DC': new THREE.Color(0xFF0000),
        ' DU': new THREE.Color(0xFF0000),
        'G': new THREE.Color(0xFF0000),
        'A': new THREE.Color(0xFF0000),
        'T': new THREE.Color(0xFF0000),
        'C': new THREE.Color(0xFF0000),
        'U': new THREE.Color(0xFF0000),
        'DG': new THREE.Color(0xFF0000),
        'DA': new THREE.Color(0xFF0000),
        'DT': new THREE.Color(0xFF0000),
        'DC': new THREE.Color(0xFF0000),
        'DU': new THREE.Color(0xFF0000),
        'ARG': new THREE.Color(0x0000FF),
        'LYS': new THREE.Color(0x0000FF),
        'ASP': new THREE.Color(0xFF0000),
        'GLU': new THREE.Color(0xFF0000),

        // hydrophobic
        'GLY': new THREE.Color(0x888888),
        'PRO': new THREE.Color(0x888888),
        'ALA': new THREE.Color(0x888888),
        'VAL': new THREE.Color(0x888888),
        'LEU': new THREE.Color(0x888888),
        'ILE': new THREE.Color(0x888888),
        'PHE': new THREE.Color(0x888888),

        // polar
        'HIS': new THREE.Color(0x888888),
        'SER': new THREE.Color(0x888888),
        'THR': new THREE.Color(0x888888),
        'ASN': new THREE.Color(0x888888),
        'GLN': new THREE.Color(0x888888),
        'TYR': new THREE.Color(0x888888),
        'MET': new THREE.Color(0x888888),
        'CYS': new THREE.Color(0x888888),
        'TRP': new THREE.Color(0x888888)
    },

    hydrophobicColors: {
        // charged residues
        '  G': new THREE.Color(0x888888),
        '  A': new THREE.Color(0x888888),
        '  T': new THREE.Color(0x888888),
        '  C': new THREE.Color(0x888888),
        '  U': new THREE.Color(0x888888),
        ' DG': new THREE.Color(0x888888),
        ' DA': new THREE.Color(0x888888),
        ' DT': new THREE.Color(0x888888),
        ' DC': new THREE.Color(0x888888),
        ' DU': new THREE.Color(0x888888),
        'G': new THREE.Color(0x888888),
        'A': new THREE.Color(0x888888),
        'T': new THREE.Color(0x888888),
        'C': new THREE.Color(0x888888),
        'U': new THREE.Color(0x888888),
        'DG': new THREE.Color(0x888888),
        'DA': new THREE.Color(0x888888),
        'DT': new THREE.Color(0x888888),
        'DC': new THREE.Color(0x888888),
        'DU': new THREE.Color(0x888888),
        'ARG': new THREE.Color(0x888888),
        'LYS': new THREE.Color(0x888888),
        'ASP': new THREE.Color(0x888888),
        'GLU': new THREE.Color(0x888888),

        // hydrophobic
        'GLY': new THREE.Color(0x00FF00),
        'PRO': new THREE.Color(0x00FF00),
        'ALA': new THREE.Color(0x00FF00),
        'VAL': new THREE.Color(0x00FF00),
        'LEU': new THREE.Color(0x00FF00),
        'ILE': new THREE.Color(0x00FF00),
        'PHE': new THREE.Color(0x00FF00),

        // polar
        'HIS': new THREE.Color(0x888888),
        'SER': new THREE.Color(0x888888),
        'THR': new THREE.Color(0x888888),
        'ASN': new THREE.Color(0x888888),
        'GLN': new THREE.Color(0x888888),
        'TYR': new THREE.Color(0x888888),
        'MET': new THREE.Color(0x888888),
        'CYS': new THREE.Color(0x888888),
        'TRP': new THREE.Color(0x888888)
    },

    ssColors: {
        helix: new THREE.Color(0xFF0080),
        sheet: new THREE.Color(0xFFC800),
        //sheet: new THREE.Color(0x008000),
        coil: new THREE.Color(0x6080FF)
    },

    //defaultBondColor: new THREE.Color(0x2194D6),
    defaultBondColor: new THREE.Color(0xBBBBBB), // cross residue bonds

    surfaces: {
        1: undefined,
        2: undefined,
        3: undefined,
        4: undefined
    },

    // from iview (http://istar.cse.cuhk.edu.hk/iview/)
    hasCovalentBond: function (atom0, atom1) {
        var r = this.covalentRadii[atom0.elem] + this.covalentRadii[atom1.elem];
        return atom0.coord.distanceToSquared(atom1.coord) < 1.3 * r * r;
    },

    init: function () {
        this.structures = {}; // structure name -> array of chains
        this.chains = {}; // structure_chain name -> atom hash
        this.residues = {}; // structure_chain_resi name -> atom hash
        this.secondaries = {}; // structure_chain_resi name -> secondary structure: 'c', 'H', or 'E'
        this.alnChains = {}; // structure_chain name -> atom hash

        this.chainsSeq = {}; // structure_chain name -> array of sequence
        this.chainsColor = {}; // structure_chain name -> color, show chain color in sequence display for mmdbid and align input
        this.chainsAn = {}; // structure_chain name -> array of annotations, such as residue number
        this.chainsAnTitle = {}; // structure_chain name -> array of annotation title

        this.alnChainsSeq = {}; // structure_chain name -> array of residue object: {mmdbid, chain, resi, resn, aligned}
        this.alnChainsAnno = {}; // structure_chain name -> array of annotations, such as residue number
        this.alnChainsAnTtl = {}; // structure_chain name -> array of annotation title

        this.dAtoms = {}; // show selected atoms
        this.hAtoms = {}; // used to change color or dislay type for certain atoms

        this.pickedAtomList = {}; // used to switch among different highlight levels

        this.prevHighlightObjects = [];
        this.prevHighlightObjects_ghost = [];
        this.prevSurfaces = [];

        this.defNames2Residues = {}; // custom defined selection name -> residue array
        this.defNames2Atoms = {}; // custom defined selection name -> atom array
        this.defNames2Descr = {}; // custom defined selection name -> description
        this.defNames2Command = {}; // custom defined selection name -> command

        this.residueId2Name = {}; // structure_chain_resi -> one letter abbreviation

        this.molTitle = "";

        this.atoms = {};
        this.dAtoms = {};
        this.hAtoms = {};
        this.proteins = {};
        this.sidec = {};
        this.nucleotides = {};
        this.nucleotidesO3 = {};

        this.chemicals = {};
        this.ions = {};
        this.water = {};
        this.calphas = {};

        this.hbondpnts = [];
        this.stabilizerpnts = [];
        this.ssbondpnts = {}; // disulfide bonds for each structure
        //this.ncbondpnts = []; // non-covalent bonds

        this.doublebonds = {};
        this.triplebonds = {};
        this.aromaticbonds = {};

        this.atomPrevColors = {};

        this.style2atoms = {}; // style -> atom hash, 13 styles: ribbon, strand, cylinder and plate, nucleotide cartoon, o3 trace, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, dot, nothing
        this.labels = {};     // hash of name -> a list of labels. Each label contains 'position', 'text', 'size', 'color', 'background'
        // label name could be custom, residue, schmatic, distance
        this.lines = {};     // hash of name -> a list of solid or dashed lines. Each line contains 'position1', 'position2', 'color', and a boolean of 'dashed'
        // line name could be custom, hbond, ssbond, distance

        this.inputid = { "idtype": undefined, "id": undefined }; // support pdbid, mmdbid

        this.biomtMatrices = [];
        this.bAssembly = true;

        this.rotateCount = 0;
        this.rotateCountMax = 20;
    },

    reinitAfterLoad: function () {
        this.dAtoms = this.cloneHash(this.atoms); // show selected atoms
        this.hAtoms = this.cloneHash(this.atoms); // used to change color or dislay type for certain atoms

        this.prevHighlightObjects = [];
        this.prevHighlightObjects_ghost = [];
        this.prevSurfaces = [];

        this.labels = {};   // hash of name -> a list of labels. Each label contains 'position', 'text', 'size', 'color', 'background'
        // label name could be custom, residue, schmatic, distance
        this.lines = {};    // hash of name -> a list of solid or dashed lines. Each line contains 'position1', 'position2', 'color', and a boolean of 'dashed'
        // line name could be custom, hbond, ssbond, distance

        this.bAssembly = true;
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.loadPDB = function (src) {
    var helices = [], sheets = [];
    //this.atoms = {};
    var lines = src.split('\n');

    var chainsTmp = {}; // serial -> atom
    var residuesTmp = {}; // serial -> atom

    this.init();

    var sheetArray = [], sheetStart = [], sheetEnd = [], helixArray = [], helixStart = [], helixEnd = [];

    // Concatenation of two pdbs will have several atoms for the same serial
    var serial = 0;

    var moleculeNum = 1;
    var chainNum, residueNum, oriResidueNum;
    var prevChainNum = '', prevResidueNum = '', prevOriResidueNum = '', prevResi = 0;
    var prevRecord = '';
    var bModifyResi = false;

    var oriSerial2NewSerial = {};

    var chainMissingResidueArray = {};

    var id = 'structure';

    var maxMissingResi = 0, prevMissingChain = '';

    for (var i in lines) {
        var line = lines[i];
        var record = line.substr(0, 6);

        if (record === 'HEADER') {
            id = line.substr(62, 4);

            this.molTitle = '';

        } else if (record === 'TITLE ') {
            var name = line.substr(10);
            this.molTitle += name.trim() + " ";

        } else if (record === 'HELIX ') {
            this.bSecondaryStructure = true;

            var startChain = line.substr(19, 1);
            var startResi = parseInt(line.substr(21, 4));
            var endResi = parseInt(line.substr(33, 4));

            var chain_resi;
            for (var j = startResi; j <= endResi; ++j) {
                chain_resi = startChain + "_" + j;
                helixArray.push(chain_resi);

                if (j === startResi) helixStart.push(chain_resi);
                if (j === endResi) helixEnd.push(chain_resi);
            }

            helices.push({
                chain: startChain,
                initialResidue: startResi,
                initialInscode: line.substr(25, 1),
                terminalResidue: endResi,
                terminalInscode: line.substr(37, 1),
            });
        } else if (record === 'SHEET ') {
            this.bSecondaryStructure = true;

            var startChain = line.substr(21, 1);
            var startResi = parseInt(line.substr(22, 4));
            var endResi = parseInt(line.substr(33, 4));

            for (var j = startResi; j <= endResi; ++j) {
                var chain_resi = startChain + "_" + j;
                sheetArray.push(chain_resi);

                if (j === startResi) sheetStart.push(chain_resi);
                if (j === endResi) sheetEnd.push(chain_resi);
            }

            sheets.push({
                chain: startChain,
                initialResidue: startResi,
                initialInscode: line.substr(26, 1),
                terminalResidue: endResi,
                terminalInscode: line.substr(37, 1),
            });

        } else if (record === 'HBOND ') {
            //HBOND A 1536   N2 A   59  ND2  -19.130  83.151  52.266 -18.079  81.613  49.427    3.40
            bCalculateHbond = false;

            var chemicalChain = line.substr(6, 1);
            var chemicalResi = line.substr(8, 4).replace(/ /g, "");
            var chemicalAtom = line.substr(14, 4).replace(/ /g, "");
            var proteinChain = line.substr(18, 1);
            var proteinResi = line.substr(20, 4).replace(/ /g, "");
            var proteinAtom = line.substr(25, 4).replace(/ /g, "");

            var chemical_x = parseFloat(line.substr(30, 8));
            var chemical_y = parseFloat(line.substr(38, 8));
            var chemical_z = parseFloat(line.substr(46, 8));
            var protein_x = parseFloat(line.substr(54, 8));
            var protein_y = parseFloat(line.substr(62, 8));
            var protein_z = parseFloat(line.substr(70, 8));

            var dist = line.substr(78, 8).replace(/ /g, "");

            this.hbondpnts.push(new THREE.Vector3(chemical_x, chemical_y, chemical_z));
            this.hbondpnts.push(new THREE.Vector3(protein_x, protein_y, protein_z));
        } else if (record === 'SSBOND') {
            //SSBOND   1 CYS E   48    CYS E   51                          2555
            var chain1 = line.substr(15, 1);
            var resi1 = line.substr(17, 4).replace(/ /g, "");
            var resid1 = id + '_' + chain1 + '_' + resi1;

            var chain2 = line.substr(29, 1);
            var resi2 = line.substr(31, 4).replace(/ /g, "");
            var resid2 = id + '_' + chain2 + '_' + resi2;

            if (this.ssbondpnts[id] === undefined) this.ssbondpnts[id] = [];

            this.ssbondpnts[id].push(resid1);
            this.ssbondpnts[id].push(resid2);
        } else if (record === 'REMARK') {
            var type = parseInt(line.substr(7, 3));
            // from GLMol
            if (type == 350 && line.substr(13, 5) == 'BIOMT') {
                var n = parseInt(line[18]) - 1;
                //var m = parseInt(line.substr(21, 2));
                var m = parseInt(line.substr(21, 2)) - 1; // start from 1
                if (this.biomtMatrices[m] == undefined) this.biomtMatrices[m] = new THREE.Matrix4().identity();
                this.biomtMatrices[m].elements[n] = parseFloat(line.substr(24, 9));
                this.biomtMatrices[m].elements[n + 4] = parseFloat(line.substr(34, 9));
                this.biomtMatrices[m].elements[n + 8] = parseFloat(line.substr(44, 9));
                this.biomtMatrices[m].elements[n + 12] = parseFloat(line.substr(54, 10));
            }
            // missing residues
            else if (type == 465 && line.substr(18, 1) == ' ' && line.substr(20, 1) == ' ' && line.substr(21, 1) != 'S') {
                var resn = line.substr(15, 3);
                var chain = line.substr(19, 1);
                var resi = parseInt(line.substr(21, 5));

                //var structure = parseInt(line.substr(13, 1));
                //if(line.substr(13, 1) == ' ') structure = 1;

                //var chainNum = structure + '_' + chain;
                var chainNum = id + '_' + chain;

                if (chainMissingResidueArray[chainNum] === undefined) chainMissingResidueArray[chainNum] = [];
                var resObject = {};
                resObject.resi = resi;
                resObject.name = this.residueName2Abbr(resn).toLowerCase();

                if (chain != prevMissingChain) {
                    maxMissingResi = 0;
                }

                // not all listed residues are considered missing, e.g., PDB ID 4OR2, only the firts four residues are considered missing
                if (!isNaN(resi) && (prevMissingChain == '' || (chain != prevMissingChain) || (chain == prevMissingChain && resi > maxMissingResi))) {
                    chainMissingResidueArray[chainNum].push(resObject);

                    maxMissingResi = resi;
                    prevMissingChain = chain;
                }

            }
        } else if (record === 'ENDMDL') {
            ++moleculeNum;
        } else if (record === 'JRNL  ') {
            if (line.substr(12, 4) === 'PMID') {
                this.pmid = line.substr(19).trim();
            }
        } else if (record === 'ATOM  ' || record === 'HETATM') {
            var structure = (moleculeNum === 1) ? id : id + moleculeNum.toString();

            var alt = line.substr(16, 1);
            //if (alt === "B") continue;
            if (alt !== " " && alt !== "A") continue;

            // "CA" has to appear before "O". Otherwise the cartoon of secondary structure will have breaks
            // Concatenation of two pdbs will have several atoms for the same serial
            ++serial;

            var serial2 = parseInt(line.substr(6, 5));
            oriSerial2NewSerial[serial2] = serial;

            var elem = line.substr(76, 2).replace(/ /g, "");
            if (elem === '') { // for some incorrect PDB files
                elem = line.substr(12, 2).replace(/ /g, "");
            }

            var chain = line.substr(21, 1);
            if (chain === '') chain = 1;

            chainNum = structure + "_" + chain;
            if (chainNum !== prevChainNum) {
                prevResi = 0;
                bModifyResi = false;
            }

            //var oriResi = line.substr(22, 4).trim();
            var oriResi = line.substr(22, 5).trim();
            oriResidueNum = chainNum + "_" + oriResi;
            if (oriResidueNum !== prevOriResidueNum) {
                if (bModifyResi) {
                    ++prevResi;
                }
                else {
                    prevResi = (chainNum !== prevChainNum) ? 0 : parseInt(prevResidueNum.substr(prevResidueNum.lastIndexOf("_") + 1));
                }
            }

            var resi = parseInt(oriResi);
            if (oriResi != resi || bModifyResi) { // e.g., 99A and 99
                bModifyResi = true;
                resi = (prevResi == 0) ? resi : prevResi + 1;
            }

            residueNum = chainNum + "_" + resi;

            var atom = line.substr(12, 4).replace(/ /g, '');
            var chain_resi = chain + "_" + resi;

            var x = parseFloat(line.substr(30, 8));
            var y = parseFloat(line.substr(38, 8));
            var z = parseFloat(line.substr(46, 8));
            var resn = line.substr(17, 3);
            var coord = new THREE.Vector3(x, y, z);

            var atomDetails = {
                het: record[0] === 'H', // optional, used to determine chemicals, water, ions, etc
                serial: serial,         // required, unique atom id
                name: atom,             // required, atom name
                alt: alt,               // optional, some alternative coordinates
                resn: resn,             // optional, used to determine protein or nucleotide
                structure: structure,   // optional, used to identify structure
                chain: chain,           // optional, used to identify chain
                resi: resi,             // optional, used to identify residue ID
                //insc: line.substr(26, 1),
                coord: coord,           // required, used to draw 3D shape
                b: parseFloat(line.substr(60, 8)), // optional, used to draw B-factor tube
                elem: elem,             // optional, used to determine hydrogen bond
                bonds: [],              // required, used to connect atoms
                ss: 'coil',             // optional, used to show secondary structures
                ssbegin: false,         // optional, used to show the beginning of secondary structures
                ssend: false            // optional, used to show the end of secondary structures
            };

            this.atoms[serial] = atomDetails;

            this.dAtoms[serial] = 1;
            this.hAtoms[serial] = 1;

            // Assign secondary structures from the input
            // if a residue is assigned both sheet and helix, it is assigned as sheet
            if ($.inArray(chain_resi, sheetArray) !== -1) {
                this.atoms[serial].ss = 'sheet';

                if ($.inArray(chain_resi, sheetStart) !== -1) {
                    this.atoms[serial].ssbegin = true;
                }

                // do not use else if. Some residues are both start and end of secondary structure
                if ($.inArray(chain_resi, sheetEnd) !== -1) {
                    this.atoms[serial].ssend = true;
                }
            }
            else if ($.inArray(chain_resi, helixArray) !== -1) {
                this.atoms[serial].ss = 'helix';

                if ($.inArray(chain_resi, helixStart) !== -1) {
                    this.atoms[serial].ssbegin = true;
                }

                // do not use else if. Some residues are both start and end of secondary structure
                if ($.inArray(chain_resi, helixEnd) !== -1) {
                    this.atoms[serial].ssend = true;
                }
            }

            var secondaries = '-';
            if (this.atoms[serial].ss === 'helix') {
                secondaries = 'H';
            }
            else if (this.atoms[serial].ss === 'sheet') {
                secondaries = 'E';
            }
            //else if(this.atoms[serial].ss === 'coil') {
            //    secondaries = 'c';
            //}
            else if (!this.atoms[serial].het && this.residueColors.hasOwnProperty(this.atoms[serial].resn.toUpperCase())) {
                secondaries = 'c';
            }
            else {
                secondaries = 'o';
            }

            this.secondaries[residueNum] = secondaries;

            // different residue
            if (residueNum !== prevResidueNum) {
                var residue = this.residueName2Abbr(resn);

                this.residueId2Name[residueNum] = residue;

                if (serial !== 1) this.residues[prevResidueNum] = residuesTmp;

                residuesTmp = {};

                // different chain
                if (chainNum !== prevChainNum) {
                    // a chain could be separated in two sections
                    if (serial !== 1) {
                        //this.chains[prevChainNum] = this.unionHash2Atoms(this.chains[prevChainNum], chainsTmp);
                        this.chains[prevChainNum] = this.unionHash(this.chains[prevChainNum], chainsTmp);
                    }

                    chainsTmp = {};

                    if (this.structures[structure.toString()] === undefined) this.structures[structure.toString()] = [];
                    this.structures[structure.toString()].push(chainNum);

                    if (this.chainsSeq[chainNum] === undefined) this.chainsSeq[chainNum] = [];
                    /*
                                        if(this.chainsAn[chainNum] === undefined ) this.chainsAn[chainNum] = [];
                                        if(this.chainsAn[chainNum][0] === undefined ) this.chainsAn[chainNum][0] = [];
                                        if(this.chainsAn[chainNum][1] === undefined ) this.chainsAn[chainNum][1] = [];
                                        if(this.chainsAnTitle[chainNum] === undefined ) this.chainsAnTitle[chainNum] = [];
                                        if(this.chainsAnTitle[chainNum][0] === undefined ) this.chainsAnTitle[chainNum][0] = [];
                                        if(this.chainsAnTitle[chainNum][1] === undefined ) this.chainsAnTitle[chainNum][1] = [];
                    */
                    var resObject = {};
                    resObject.resi = resi;
                    resObject.name = residue;

                    this.chainsSeq[chainNum].push(resObject);

                    /*
                                          var numberStr = '';
                                          if(resi % 10 === 0) numberStr = resi.toString();
                    
                                        this.chainsAn[chainNum][0].push(numberStr);
                                        this.chainsAn[chainNum][1].push(secondaries);
                                        this.chainsAnTitle[chainNum][0].push("");
                                        this.chainsAnTitle[chainNum][1].push("SS");
                    */
                }
                else {
                    var resObject = {};
                    resObject.resi = resi;
                    resObject.name = residue;

                    this.chainsSeq[chainNum].push(resObject);

                    /*
                                          var numberStr = '';
                                          if(resi % 10 === 0) numberStr = resi.toString();
                    
                                        this.chainsAn[chainNum][0].push(numberStr);
                                        this.chainsAn[chainNum][1].push(secondaries);
                    */
                }
            }

            chainsTmp[serial] = 1;
            residuesTmp[serial] = 1;

            prevRecord = record;

            prevChainNum = chainNum;
            prevResidueNum = residueNum;
            prevOriResidueNum = oriResidueNum;

        } else if (record === 'CONECT') {
            var from = parseInt(line.substr(6, 5));
            for (var j = 0; j < 4; ++j) {
                var to = parseInt(line.substr([11, 16, 21, 26][j], 5));
                if (isNaN(to)) continue;

                if (this.atoms[oriSerial2NewSerial[from]] !== undefined) this.atoms[oriSerial2NewSerial[from]].bonds.push(oriSerial2NewSerial[to]);
            }
        } else if (record === 'TER   ') {
            // Concatenation of two pdbs will have several atoms for the same serial
            ++serial;
        }
    }

    // copy disulfide bonds
    var structureArray = Object.keys(this.structures);
    for (var s = 0, sl = structureArray.length; s < sl; ++s) {
        var structure = structureArray[s];

        if (structure == id) continue;

        if (this.ssbondpnts[structure] === undefined) this.ssbondpnts[structure] = [];

        if (this.ssbondpnts[id] !== undefined) {
            for (var j = 0, jl = this.ssbondpnts[id].length; j < jl; ++j) {
                var ori_resid = this.ssbondpnts[id][j];
                var pos = ori_resid.indexOf('_');
                var resid = structure + ori_resid.substr(pos);

                this.ssbondpnts[structure].push(resid);
            }
        }
    }

    this.adjustSeq(chainMissingResidueArray);

    // remove the reference
    lines = null;

    // add the last residue set
    this.residues[residueNum] = residuesTmp;
    this.chains[chainNum] = this.unionHash2Atoms(this.chains[chainNum], chainsTmp);

    var curChain, curResi, curInsc, curResAtoms = [], me = this;
    // refresh for atoms in each residue
    var refreshBonds = function (f) {
        var n = curResAtoms.length;
        for (var j = 0; j < n; ++j) {
            var atom0 = curResAtoms[j];
            for (var k = j + 1; k < n; ++k) {
                var atom1 = curResAtoms[k];
                if (atom0.alt === atom1.alt && me.hasCovalentBond(atom0, atom1)) {
                    //if (me.hasCovalentBond(atom0, atom1)) {
                    atom0.bonds.push(atom1.serial);
                    atom1.bonds.push(atom0.serial);
                }
            }
            f && f(atom0);
        }
    };
    var pmin = new THREE.Vector3(9999, 9999, 9999);
    var pmax = new THREE.Vector3(-9999, -9999, -9999);
    var psum = new THREE.Vector3();
    var cnt = 0;
    // assign atoms
    for (var i in this.atoms) {
        var atom = this.atoms[i];
        var coord = atom.coord;
        psum.add(coord);
        pmin.min(coord);
        pmax.max(coord);
        ++cnt;

        if (!atom.het) {
            if ($.inArray(atom.resn, this.nucleotidesArray) !== -1) {
                this.nucleotides[atom.serial] = 1;
                //if (atom.name === 'P') {
                if (atom.name === "O3'" || atom.name === "O3*") {
                    this.nucleotidesO3[atom.serial] = 1;

                    this.secondaries[atom.structure + '_' + atom.chain + '_' + atom.resi] = 'o'; // nucleotide
                }
            }
            else {
                this.proteins[atom.serial] = 1;
                if (atom.name === 'CA') this.calphas[atom.serial] = 1;
                if (atom.name !== 'N' && atom.name !== 'CA' && atom.name !== 'C' && atom.name !== 'O') this.sidec[atom.serial] = 1;
            }
        }
        else if (atom.het) {
            if (atom.resn === 'HOH' || atom.resn === 'WAT') {
                this.water[atom.serial] = 1;
            }
            else if ($.inArray(atom.resn, this.ionsArray) !== -1 || atom.elem.trim() === atom.resn.trim()) {
                this.ions[atom.serial] = 1;
            }
            else {
                this.chemicals[atom.serial] = 1;
            }
        }

        if (!(curChain === atom.chain && curResi === atom.resi)) {
            // a new residue, add the residue-residue bond beides the regular bonds
            refreshBonds(function (atom0) {
                if (((atom0.name === 'C' && atom.name === 'N') || (atom0.name === 'O3\'' && atom.name === 'P')) && me.hasCovalentBond(atom0, atom)) {
                    atom0.bonds.push(atom.serial);
                    atom.bonds.push(atom0.serial);
                }
            });
            curChain = atom.chain;
            curResi = atom.resi;
            //curInsc = atom.insc;
            curResAtoms.length = 0;
        }
        curResAtoms.push(atom);
    } // end of for

    // last residue
    refreshBonds();

    this.pmin = pmin;
    this.pmax = pmax;

    this.cnt = cnt;

    this.maxD = this.pmax.distanceTo(this.pmin);
    this.center = psum.multiplyScalar(1.0 / this.cnt);

    if (this.maxD < 5) this.maxD = 5;

    this.oriMaxD = this.maxD;
    this.oriCenter = this.center.clone();
};

iCn3D.prototype.adjustSeq = function (chainMissingResidueArray) {
    // adjust sequences
    for (var chainNum in this.chainsSeq) {
        if (chainMissingResidueArray[chainNum] === undefined) continue;

        var A = this.chainsSeq[chainNum];
        //var A2 = this.chainsAn[chainNum][0];
        //var A3 = this.chainsAn[chainNum][1];
        var B = chainMissingResidueArray[chainNum];

        var m = A.length;
        var n = B.length;

        var C = new Array(m + n);
        //var C2 = new Array(m + n);
        //var C3 = new Array(m + n);

        // http://www.algolist.net/Algorithms/Merge/Sorted_arrays
        // m - size of A
        // n - size of B
        // size of C array must be equal or greater than m + n
        var i, j, k;
        i = 0;
        j = 0;
        k = 0;
        while (i < m && j < n) {
            if (A[i].resi <= B[j].resi) {
                C[k] = A[i];
                //C2[k] = A2[i];
                //C3[k] = A3[i];
                i++;
            } else {
                C[k] = B[j];
                //if(B[j].resi % 10 === 0) {
                //    C2[k] = B[j].resi.toString();
                //}
                //else {
                //    C2[k] = '';
                //}
                //C3[k] = '-';
                j++;
            }
            k++;
        }
        if (i < m) {
            for (var p = i; p < m; p++) {
                C[k] = A[p];
                //C2[k] = A2[p];
                //C3[k] = A3[p];
                k++;
            }
        } else {
            for (var p = j; p < n; p++) {
                C[k] = B[p];
                //if(B[p].resi % 10 === 0) {
                //    C2[k] = B[p].resi.toString();
                //}
                //else {
                //    C2[k] = '';
                //}
                //C3[k] = '-';
                k++;
            }
        }

        this.chainsSeq[chainNum] = C;
        //this.chainsAn[chainNum][0] = C2;
        //this.chainsAn[chainNum][1] = C3;
    }
};
/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createSphere = function (atom, defaultRadius, forceDefault, scale, bHighlight) {
    var mesh;

    if (defaultRadius === undefined) defaultRadius = 0.8;
    if (forceDefault === undefined) forceDefault = false;
    if (scale === undefined) scale = 1.0;

    var radius = (this.vdwRadii[atom.elem] || defaultRadius);

    if (bHighlight === 2) {
        //if(scale > 0.9) { // sphere
        //  scale = 1.5;
        //}
        //else if(scale < 0.5) { // dot
        //  scale = 1.0;
        //}

        scale *= 1.5;

        var color = this.hColor;

        mesh = new THREE.Mesh(this.sphereGeometry, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));

        mesh.scale.x = mesh.scale.y = mesh.scale.z = forceDefault ? defaultRadius : radius * (scale ? scale : 1);
        mesh.position.copy(atom.coord);
        this.mdl.add(mesh);
    }
    else if (bHighlight === 1) {
        mesh = new THREE.Mesh(this.sphereGeometry, this.matShader);

        mesh.scale.x = mesh.scale.y = mesh.scale.z = forceDefault ? defaultRadius : radius * (scale ? scale : 1);
        mesh.position.copy(atom.coord);
        mesh.renderOrder = this.renderOrderPicking;
        //this.mdlPicking.add(mesh);
        this.mdl.add(mesh);
    }
    else {
        if (atom.color === undefined) {
            atom.color = this.defaultAtomColor;
        }

        var color = atom.color;

        mesh = new THREE.Mesh(this.sphereGeometry, new THREE.MeshPhongMaterial({ overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));
        mesh.scale.x = mesh.scale.y = mesh.scale.z = forceDefault ? defaultRadius : radius * (scale ? scale : 1);
        mesh.position.copy(atom.coord);

        if (this.bImpo) {
            this.posArraySphere.push(atom.coord.x);
            this.posArraySphere.push(atom.coord.y);
            this.posArraySphere.push(atom.coord.z);

            this.colorArraySphere.push(atom.color.r);
            this.colorArraySphere.push(atom.color.g);
            this.colorArraySphere.push(atom.color.b);

            var realRadius = forceDefault ? defaultRadius : radius * (scale ? scale : 1);
            this.radiusArraySphere.push(realRadius);

            this.mdl_ghost.add(mesh);
        }
        else {
            this.mdl.add(mesh);
        }
    }

    //this.mdl.add(mesh);

    if (bHighlight === 1 || bHighlight === 2) {
        if (this.bImpo) {
            this.prevHighlightObjects_ghost.push(mesh);
        }
        else {
            this.prevHighlightObjects.push(mesh);
        }
    }
    else {
        if (this.bImpo) {
            this.objects_ghost.push(mesh);
        }
        else {
            this.objects.push(mesh);
        }
    }
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createCylinder = function (p0, p1, radius, color, bHighlight, color2, bPicking) {
    var mesh;
    if (bHighlight === 1) {
        mesh = new THREE.Mesh(this.cylinderGeometryOutline, this.matShader);

        mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
        mesh.matrixAutoUpdate = false;
        mesh.lookAt(p0);
        mesh.updateMatrix();

        mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius, p0.distanceTo(p1))).multiply(new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

        mesh.renderOrder = this.renderOrderPicking;
        //this.mdlPicking.add(mesh);
        this.mdl.add(mesh);

        this.prevHighlightObjects.push(mesh);
    }
    else {
        if (bHighlight === 2) {
            mesh = new THREE.Mesh(this.cylinderGeometry, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));

            radius *= 1.5;
        }
        else {
            mesh = new THREE.Mesh(this.cylinderGeometry, new THREE.MeshPhongMaterial({ overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));
        }

        mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
        mesh.matrixAutoUpdate = false;
        mesh.lookAt(p0);
        mesh.updateMatrix();

        mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius, p0.distanceTo(p1))).multiply(new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

        if (this.bImpo) {
            this.posArray.push(p0.x);
            this.posArray.push(p0.y);
            this.posArray.push(p0.z);

            this.colorArray.push(color.r);
            this.colorArray.push(color.g);
            this.colorArray.push(color.b);

            this.pos2Array.push(p1.x);
            this.pos2Array.push(p1.y);
            this.pos2Array.push(p1.z);

            if (color2 !== undefined) {
                this.color2Array.push(color2.r);
                this.color2Array.push(color2.g);
                this.color2Array.push(color2.b);
            }
            else {
                this.color2Array.push(color.r);
                this.color2Array.push(color.g);
                this.color2Array.push(color.b);
            }

            this.radiusArray.push(radius);

            this.mdl_ghost.add(mesh);
        }
        else {
            this.mdl.add(mesh);
        }

        if (bHighlight === 2) {
            if (this.bImpo) {
                this.prevHighlightObjects_ghost.push(mesh);
            }
            else {
                this.prevHighlightObjects.push(mesh);
            }
        }
        else {
            if (this.bImpo) {
                this.objects_ghost.push(mesh);
            }
            else {
                if (bPicking === undefined || bPicking) this.objects.push(mesh);
            }
        }
    }
};

// from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createRepresentationSub = function (atoms, f0, f01) {
    var me = this;

    //var ged = new THREE.Geometry();
    var clbondArray = [];
    for (var i in atoms) {
        var atom0 = atoms[i];
        f0 && f0(atom0);
        for (var j in atom0.bonds) {
            var atom1 = this.atoms[atom0.bonds[j]];
            if (atom1 === undefined || atom1.serial < atom0.serial) continue;
            if (atom1.chain === atom0.chain && ((atom1.resi === atom0.resi) || (atom0.name === 'C' && atom1.name === 'N') || (atom0.name === 'O3\'' && atom1.name === 'P') || (atom0.name === 'O3*' && atom1.name === 'P') || (atom0.name === 'SG' && atom1.name === 'SG'))) {
                f01 && f01(atom0, atom1);
            } else {
                //ged.vertices.push(atom0.coord);
                //ged.vertices.push(atom1.coord);
                clbondArray.push([atom0.coord, atom1.coord]);
            }
        }
    }
    //if (ged.vertices.length && this.bShowCrossResidueBond) {
    if (clbondArray.length > 0 && this.bShowCrossResidueBond) {
        //ged.computeLineDistances();
        //this.mdl.add(new THREE.Line(ged, new THREE.LineDashedMaterial({ linewidth: this.linewidth, color: this.defaultBondColor, dashSize: 0.3, gapSize: 0.15 }), THREE.LinePieces));
        var color = new THREE.Color(0x00FF00);

        for (var i = 0, il = clbondArray.length; i < il; ++i) {
            me.createCylinder(clbondArray[i][0], clbondArray[i][1], this.cylinderRadius, color, 0);
        }
    }
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createSphereRepresentation = function (atoms, defaultRadius, forceDefault, scale, bHighlight) {
    var me = this;

    this.createRepresentationSub(atoms, function (atom0) {
        me.createSphere(atom0, defaultRadius, forceDefault, scale, bHighlight);
    });
};

iCn3D.prototype.createBoxRepresentation_P_CA = function (atoms, scale, bHighlight) {
    var me = this;
    this.createRepresentationSub(atoms, function (atom0) {
        if (atom0.name === 'CA' || atom0.name === "O3'" || atom0.name === "O3*") {
            me.createBox(atom0, undefined, undefined, scale, undefined, bHighlight);
        }
    });
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createStickRepresentation = function (atoms, atomR, bondR, scale, bHighlight, bSchematic) {
    var me = this;
    var factor = (bSchematic !== undefined && bSchematic) ? atomR / me.cylinderRadius : 1;

    //        if(bHighlight !== 2) {
    this.createRepresentationSub(atoms, function (atom0) {
        me.createSphere(atom0, atomR, !scale, scale, bHighlight);
    }, function (atom0, atom1) {
        var mp = atom0.coord.clone().add(atom1.coord).multiplyScalar(0.5);
        var pair = atom0.serial + '_' + atom1.serial;

        if (me.doublebonds.hasOwnProperty(pair)) { // show double bond
            var a0, a1, a2;

            var v0;
            var random = new THREE.Vector3(Math.random(), Math.random(), Math.random());
            if (atom0.bonds.length == 1 && atom1.bonds.length == 1) {
                v0 = atom1.coord.clone();
                v0.sub(atom0.coord);

                var v = random.clone();
                v0.cross(v).normalize().multiplyScalar(0.2 * factor);
            }
            else {
                if (atom0.bonds.length >= atom1.bonds.length && atom0.bonds.length > 1) {
                    a0 = atom0.serial;
                    a1 = atom0.bonds[0];
                    a2 = atom0.bonds[1];
                }
                //else {
                else if (atom1.bonds.length >= atom0.bonds.length && atom1.bonds.length > 1) {
                    a0 = atom1.serial;
                    a1 = atom1.bonds[0];
                    a2 = atom1.bonds[1];
                }
                else {
                    console.log("Double bond was not drawn due to the undefined cross plane");
                    return;
                }

                var v1 = me.atoms[a0].coord.clone();
                v1.sub(me.atoms[a1].coord);
                var v2 = me.atoms[a0].coord.clone();
                v2.sub(me.atoms[a2].coord);

                v1.cross(v2);

                // parallel
                if (parseInt(v1.length() * 10000) == 0) {
                    //v1 = random.clone();
                    // use a constant so that they are fixed,e.g., in CO2
                    v1 = new THREE.Vector3(0.2, 0.3, 0.5);
                }

                v0 = atom1.coord.clone();
                v0.sub(atom0.coord);

                v0.cross(v1).normalize().multiplyScalar(0.2 * factor);
                // parallel
                if (parseInt(v0.length() * 10000) == 0) {
                    //v1 = random.clone();
                    // use a constant so that they are fixed,e.g., in CO2
                    v1 = new THREE.Vector3(0.5, 0.3, 0.2);
                    v0.cross(v1).normalize().multiplyScalar(0.2 * factor);
                }
            }

            if (atom0.color === atom1.color) {
                me.createCylinder(atom0.coord.clone().add(v0), atom1.coord.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                me.createCylinder(atom0.coord.clone().sub(v0), atom1.coord.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
            } else {
                if (me.bImpo) {
                    me.createCylinder(atom0.coord.clone().add(v0), atom1.coord.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight, atom1.color);
                    me.createCylinder(atom0.coord.clone().sub(v0), atom1.coord.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight, atom1.color);
                }
                else {
                    me.createCylinder(atom0.coord.clone().add(v0), mp.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                    me.createCylinder(atom1.coord.clone().add(v0), mp.clone().add(v0), me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);

                    me.createCylinder(atom0.coord.clone().sub(v0), mp.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                    me.createCylinder(atom1.coord.clone().sub(v0), mp.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);
                }
            }
        }
        else if (me.aromaticbonds.hasOwnProperty(pair)) { // show aromatic bond
            var a0, a1, a2;
            if (atom0.bonds.length > atom1.bonds.length && atom0.bonds.length > 1) {
                a0 = atom0.serial;
                a1 = atom0.bonds[0];
                a2 = atom0.bonds[1];
            }
            else if (atom1.bonds.length > 1) {
                a0 = atom1.serial;
                a1 = atom1.bonds[0];
                a2 = atom1.bonds[1];
            }
            else {
                return;
            }

            var v1 = me.atoms[a0].coord.clone();
            v1.sub(me.atoms[a1].coord);
            var v2 = me.atoms[a0].coord.clone();
            v2.sub(me.atoms[a2].coord);

            v1.cross(v2);

            var v0 = atom1.coord.clone();
            v0.sub(atom0.coord);

            v0.cross(v1).normalize().multiplyScalar(0.2 * factor);

            // find an aromatic neighbor
            var aromaticNeighbor = 0;
            for (var i = 0, il = atom0.bondOrder.length; i < il; ++i) {
                if (atom0.bondOrder[i] === '1.5' && atom0.bonds[i] !== atom1.serial) {
                    aromaticNeighbor = atom0.bonds[i];
                }
            }

            var dashed = "add";
            if (aromaticNeighbor === 0) { // no neighbor found, atom order does not matter
                dashed = "add";
            }
            else {
                // calculate the angle between atom1, atom0add, atomNeighbor and the angle atom1, atom0sub, atomNeighbor
                var atom0add = atom0.coord.clone().add(v0);
                var atom0sub = atom0.coord.clone().sub(v0);

                var a = atom1.coord.clone().sub(atom0add).normalize();
                var b = me.atoms[aromaticNeighbor].coord.clone().sub(atom0add).normalize();

                var c = atom1.coord.clone().sub(atom0sub).normalize();
                var d = me.atoms[aromaticNeighbor].coord.clone().sub(atom0sub).normalize();

                var angleadd = Math.acos(a.dot(b));
                var anglesub = Math.acos(c.dot(d));

                if (angleadd < anglesub) {
                    dashed = 'sub';
                }
                else {
                    dashed = 'add';
                }
            }

            if (atom0.color === atom1.color) {
                var base, step;
                if (dashed === 'add') {
                    me.createCylinder(atom0.coord.clone().sub(v0), atom1.coord.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);

                    base = atom0.coord.clone().add(v0);
                    step = atom1.coord.clone().add(v0).sub(base).multiplyScalar(1.0 / 11);
                }
                else {
                    me.createCylinder(atom0.coord.clone().add(v0), atom1.coord.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);

                    base = atom0.coord.clone().sub(v0);
                    step = atom1.coord.clone().sub(v0).sub(base).multiplyScalar(1.0 / 11);
                }

                for (var i = 0; i <= 10; ++i) {
                    if (i % 2 == 0) {
                        var pos1 = base.clone().add(step.clone().multiplyScalar(i));
                        var pos2 = base.clone().add(step.clone().multiplyScalar(i + 1));
                        me.createCylinder(pos1, pos2, me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                    }
                }

            } else {
                var base, step;
                if (dashed === 'add') {
                    me.createCylinder(atom0.coord.clone().sub(v0), mp.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                    me.createCylinder(atom1.coord.clone().sub(v0), mp.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);

                    base = atom0.coord.clone().add(v0);
                    step = atom1.coord.clone().add(v0).sub(base).multiplyScalar(1.0 / 11);
                }
                else {
                    me.createCylinder(atom0.coord.clone().add(v0), mp.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                    me.createCylinder(atom1.coord.clone().add(v0), mp.clone().add(v0), me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);

                    base = atom0.coord.clone().sub(v0);
                    step = atom1.coord.clone().sub(v0).sub(base).multiplyScalar(1.0 / 11);
                }

                for (var i = 0; i <= 10; ++i) {
                    if (i % 2 == 0) {
                        var pos1 = base.clone().add(step.clone().multiplyScalar(i));
                        var pos2 = base.clone().add(step.clone().multiplyScalar(i + 1));
                        if (i < 5) {
                            me.createCylinder(pos1, pos2, me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                        }
                        else {
                            me.createCylinder(pos1, pos2, me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);
                        }
                    }
                }
            }
        }
        else if (me.triplebonds.hasOwnProperty(pair)) { // show triple bond
            var random = new THREE.Vector3(Math.random(), Math.random(), Math.random());
            var v = atom1.coord.clone();
            v.sub(atom0.coord);

            var c = random.clone();
            c.cross(v).normalize().multiplyScalar(0.3 * factor);

            if (atom0.color === atom1.color) {
                me.createCylinder(atom0.coord, atom1.coord, me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                me.createCylinder(atom0.coord.clone().add(c), atom1.coord.clone().add(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                me.createCylinder(atom0.coord.clone().sub(c), atom1.coord.clone().sub(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
            } else {
                if (me.bImpo) {
                    me.createCylinder(atom0.coord, atom1.coord, me.cylinderRadius * factor * 0.2, atom0.color, bHighlight, atom1.color);
                    me.createCylinder(atom0.coord.clone().add(c), atom1.coord.clone().add(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight, atom1.color);
                    me.createCylinder(atom0.coord.clone().sub(c), atom1.coord.clone().sub(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight, atom1.color);
                }
                else {
                    me.createCylinder(atom0.coord, mp, me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                    me.createCylinder(atom1.coord, mp, me.cylinderRadius * factor * 0.2, atom1.color, bHighlight);

                    me.createCylinder(atom0.coord.clone().add(c), mp.clone().add(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                    me.createCylinder(atom1.coord.clone().add(c), mp.clone().add(c), me.cylinderRadius * factor * 0.2, atom1.color, bHighlight);

                    me.createCylinder(atom0.coord.clone().sub(c), mp.clone().sub(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                    me.createCylinder(atom1.coord.clone().sub(c), mp.clone().sub(c), me.cylinderRadius * factor * 0.2, atom1.color, bHighlight);
                }
            }
        }
        else {
            if (atom0.color === atom1.color) {
                me.createCylinder(atom0.coord, atom1.coord, bondR, atom0.color, bHighlight);
            } else {
                if (me.bImpo) {
                    me.createCylinder(atom0.coord, atom1.coord, bondR, atom0.color, bHighlight, atom1.color);
                }
                else {
                    me.createCylinder(atom0.coord, mp, bondR, atom0.color, bHighlight);
                    me.createCylinder(atom1.coord, mp, bondR, atom1.color, bHighlight);
                }
            }
        }
    });
    //        }
    //        else if(bHighlight === 2) {
    //            this.createBoxRepresentation_P_CA(atoms, 1.2, bHighlight);
    //        }
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createLineRepresentation = function (atoms, bHighlight) {
    var me = this;
    var geo = new THREE.Geometry();
    this.createRepresentationSub(atoms, undefined, function (atom0, atom1) {
        if (atom0.color === atom1.color) {
            geo.vertices.push(atom0.coord);
            geo.vertices.push(atom1.coord);
            geo.colors.push(atom0.color);
            geo.colors.push(atom1.color);
        } else {
            var mp = atom0.coord.clone().add(atom1.coord).multiplyScalar(0.5);
            geo.vertices.push(atom0.coord);
            geo.vertices.push(mp);
            geo.vertices.push(atom1.coord);
            geo.vertices.push(mp);
            geo.colors.push(atom0.color);
            geo.colors.push(atom0.color);
            geo.colors.push(atom1.color);
            geo.colors.push(atom1.color);
        }
    });

    if (bHighlight !== 2) {
        var line;
        if (bHighlight === 1) {
            // highlight didn't work for lines
            //line = new THREE.Mesh(geo, this.matShader);
        }
        else {
            line = new THREE.Line(geo, new THREE.LineBasicMaterial({ linewidth: this.linewidth, vertexColors: true }), THREE.LinePieces);
            this.mdl.add(line);
        }

        if (bHighlight === 1) {
            this.prevHighlightObjects.push(line);
        }
        else {
            this.objects.push(line);
        }
    }
    else if (bHighlight === 2) {
        this.createBoxRepresentation_P_CA(atoms, 0.8, bHighlight);
    }
};

/*
// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
// Catmull�Rom subdivision
iCn3D.prototype.subdivide = function (_pnts, _clrs, DIV, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes) {
    var ret = [];
    var pos = [];
    var color = [];

    var pnts = new Array(); // Smoothing test

    var prevoneLen = (prevone !== undefined) ? prevone.length : 0;
    var nexttwoLenOri = (nexttwo !== undefined) ? nexttwo.length : 0;

    if(prevoneLen > 0) pnts.push(prevone[0]);

    pnts.push(_pnts[0]);
    for (var i = 1, lim = _pnts.length - 1; i < lim; ++i) {
        var p0 = _pnts[i], p1 = _pnts[i + 1];
        pnts.push(p0.smoothen ? p0.clone().add(p1).multiplyScalar(0.5) : p0);
    }
    pnts.push(_pnts[_pnts.length - 1]);

    if(nexttwoLenOri > 0) pnts.push(nexttwo[0]);
    if(nexttwoLenOri > 1) pnts.push(nexttwo[1]);

    var savedPoints = [];
    var savedPos = [];
    var savedColor = [];

    var nexttwoLen = nexttwoLenOri;
    if(bExtendLastRes) {
        nexttwoLen = (nexttwoLenOri > 0) ? nexttwoLenOri - 1 : 0;
    }

    for (var i = -1, size = pnts.length, DIVINV = 1 / DIV; i <= size - 3; ++i) {
        var newI = i - prevoneLen;
        var p0 = pnts[i === -1 ? 0 : i];
        var p1 = pnts[i + 1];
        var p2 = pnts[i + 2];
        var p3 = pnts[i === size - 3 ? size - 1 : i + 3];
        var v0 = p2.clone().sub(p0).multiplyScalar(0.5);
        var v1 = p3.clone().sub(p1).multiplyScalar(0.5);

        //if(i > -1 && bHighlight && bShowArray !== undefined && bShowArray[i + 1]) {
        if(i > -1 && (bShowArray === undefined || bShowArray[newI + 1]) ) {
            // get from previous i for the first half of residue
            if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                ret = ret.concat(savedPoints);
                pos = pos.concat(savedPos);
                color = color.concat(savedColor);
            }
        }

        savedPoints = [];
        savedPos = [];
        savedColor = [];

        for (var j = 0; j < DIV; ++j) {
            var t = DIVINV * j;
            var x = p1.x + t * v0.x
                     + t * t * (-3 * p1.x + 3 * p2.x - 2 * v0.x - v1.x)
                     + t * t * t * (2 * p1.x - 2 * p2.x + v0.x + v1.x);
            var y = p1.y + t * v0.y
                     + t * t * (-3 * p1.y + 3 * p2.y - 2 * v0.y - v1.y)
                     + t * t * t * (2 * p1.y - 2 * p2.y + v0.y + v1.y);
            var z = p1.z + t * v0.z
                     + t * t * (-3 * p1.z + 3 * p2.z - 2 * v0.z - v1.z)
                     + t * t * t * (2 * p1.z - 2 * p2.z + v0.z + v1.z);

            if(!bShowArray) {
                if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                    ret.push(new THREE.Vector3(x, y, z));
                    pos.push(newI + 1);
                    color.push(_clrs[newI+1]);
                }
            }
            else {
                if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                    if(bShowArray[newI + 1]) {
                        if(j <= parseInt((DIV) / 2) ) {
                            ret.push(new THREE.Vector3(x, y, z));
                            pos.push(bShowArray[newI + 1]);
                            color.push(_clrs[newI+1]);
                        }
                    }
                }

                if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                    if(bShowArray[newI + 2]) {
                        if(j > parseInt((DIV) / 2) ) {
                            savedPoints.push(new THREE.Vector3(x, y, z));
                            savedPos.push(bShowArray[newI + 2]);
                            savedColor.push(_clrs[newI+2]);
                        }
                    }
                }
            } // end else

        } // end for (var j = 0;
    } // end for (var i = -1;

    if(!bShowArray || bShowArray[newI + 1]) {
        //if(bHighlight) {
        ret = ret.concat(savedPoints);
        pos = pos.concat(savedPos);
        color = color.concat(savedColor);
        //}

        ret.push(pnts[pnts.length - 1 - nexttwoLen]);
        pos.push(pnts.length - 1 - nexttwoLen);
        color.push(_clrs[pnts.length - 1 - nexttwoLen]);
    }

    savedPoints = [];
    savedPos = [];
    savedColor = [];
    pnts = [];

    var pnts_positions = [];

    pnts_positions.push(ret);
    pnts_positions.push(pos);
    pnts_positions.push(color);

    return pnts_positions;
};
*/

iCn3D.prototype.getKnot = function (alpha, ti, Pi, Pj) {
    var alpha = 1;

    //return Math.pow(Pi.distanceTo(Pj), alpha) + ti;
    return Pi.distanceTo(Pj) + ti;
}

iCn3D.prototype.getValueFromKnot = function (t, t0, t1, t2, t3, y0, y1, y2, y3) {
    var inf = 9999;

    // m(i) = ( t(i+1) - t(i) == 0 ) ? 0 : ( y(i+1) - y(i) ) / ( t(i+1) - t(i) )
    var m0 = (y1 - y0) / (t1 - t0);
    var m1 = (y2 - y1) / (t2 - t1);
    var m2 = (y3 - y2) / (t3 - t2);

    // L(i) = m(i) * (t - t(i)) + y(i)
    //var L0 = m0 * (t - t0) + y0;
    var L1 = m1 * (t - t1) + y1;
    //var L2 = m2 * (t - t2) + y2;

    var denom = (t1 + t2) * (t1 + t2) - 4 * (t0 * t1 + t2 * t3 - t0 * t3);
    var d0 = 0;
    var d3 = 0;
    var d1, d2;

    if (denom == 0) {
        d1 = inf;
        d2 = inf;
    }
    else {
        d1 = 6 * (3 * m1 * t1 + 2 * m0 * t3 + m2 * t1 - 2 * m0 * t1 - 2 * m1 * t3 - m1 * t2 - m2 * t1) / denom;
        d2 = 6 * (3 * m1 * t2 + 2 * m2 * t0 + m0 * t1 - 2 * m1 * t0 - 2 * m2 * t2 - m0 * t2 - m1 * t1) / denom;
    }

    // a(i) = ( 2*d(i) + d(i+1) ) / 6 / (t(i) - t(i+1))
    // b(i) = ( 2*d(i+1) + d(i) ) / 6 / (t(i+1) - t(i))
    //var a0 = ( 2*d0 + d1 ) / 6 / (t0 - t1);
    var a1 = (2 * d1 + d2) / 6 / (t1 - t2);
    //var a2 = ( 2*d2 + d3 ) / 6 / (t2 - t3);

    //var b0 = ( 2*d1 + d0 ) / 6 / (t1 - t0);
    var b1 = (2 * d2 + d1) / 6 / (t2 - t1);
    //var b2 = ( 2*d3 + d2 ) / 6 / (t3 - t2);

    // C(i) = a(i)*(t - t(i))*(t - t(i+1))*(t - t(i+1)) + b(i)*(t - t(i))*(t - t(i))*(t - t(i+1))
    //var C0 = a0*(t - t0)*(t - t1)*(t - t1) + b0*(t - t0)*(t - t0)*(t - t1);
    var C1 = a1 * (t - t1) * (t - t2) * (t - t2) + b1 * (t - t1) * (t - t1) * (t - t2);
    //var C2 = a2*(t - t2)*(t - t3)*(t - t3) + b2*(t - t2)*(t - t2)*(t - t3);

    var F1 = L1 + C1;

    return F1;
}

// cubic splines for four points: http://thalestriangles.blogspot.com/2014/02/a-bit-of-ex-spline-ation.html
// https://math.stackexchange.com/questions/577641/how-to-calculate-interpolating-splines-in-3d-space
iCn3D.prototype.subdivide = function (_pnts, _clrs, DIV, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes) {
    var ret = [];
    var pos = [];
    var color = [];

    var pnts = new Array(); // Smoothing test

    var prevoneLen = (prevone !== undefined) ? prevone.length : 0;
    var nexttwoLenOri = (nexttwo !== undefined) ? nexttwo.length : 0;

    if (prevoneLen > 0) pnts.push(prevone[0]);

    pnts.push(_pnts[0]);
    for (var i = 1, lim = _pnts.length - 1; i < lim; ++i) {
        var p0 = _pnts[i], p1 = _pnts[i + 1];
        pnts.push(p0.smoothen ? p0.clone().add(p1).multiplyScalar(0.5) : p0);
    }
    pnts.push(_pnts[_pnts.length - 1]);

    if (nexttwoLenOri > 0) pnts.push(nexttwo[0]);
    if (nexttwoLenOri > 1) pnts.push(nexttwo[1]);

    var savedPoints = [];
    var savedPos = [];
    var savedColor = [];

    var nexttwoLen = nexttwoLenOri;
    if (bExtendLastRes) {
        nexttwoLen = (nexttwoLenOri > 0) ? nexttwoLenOri - 1 : 0;
    }

    var alpha = 1;

    for (var i = -1, size = pnts.length, DIVINV = 1 / DIV; i <= size - 3; ++i) {
        var newI = i - prevoneLen;
        var p0 = pnts[i === -1 ? 0 : i];
        var p1 = pnts[i + 1];
        var p2 = pnts[i + 2];
        var p3 = pnts[i === size - 3 ? size - 1 : i + 3];

        var t0 = 0;
        var t1 = this.getKnot(alpha, t0, p0, p1);
        var t2 = this.getKnot(alpha, t1, p1, p2);
        var t3 = this.getKnot(alpha, t2, p2, p3);

        if (t1 - t0 < 1e-4) t1 = t0 + 1;
        if (t2 - t1 < 1e-4) t2 = t1 + 1;
        if (t3 - t2 < 1e-4) t3 = t2 + 1;

        //if(i > -1 && bHighlight && bShowArray !== undefined && bShowArray[i + 1]) {
        if (i > -1 && (bShowArray === undefined || bShowArray[newI + 1])) {
            // get from previous i for the first half of residue
            if (i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                ret = ret.concat(savedPoints);
                pos = pos.concat(savedPos);
                color = color.concat(savedColor);
            }
        }

        savedPoints = [];
        savedPos = [];
        savedColor = [];

        var step = (t2 - t1) * DIVINV;
        for (var j = 0; j < DIV; ++j) {
            var t = t1 + step * j;
            var x = this.getValueFromKnot(t, t0, t1, t2, t3, p0.x, p1.x, p2.x, p3.x);
            var y = this.getValueFromKnot(t, t0, t1, t2, t3, p0.y, p1.y, p2.y, p3.y);
            var z = this.getValueFromKnot(t, t0, t1, t2, t3, p0.z, p1.z, p2.z, p3.z);

            if (!bShowArray) {
                if (i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                    ret.push(new THREE.Vector3(x, y, z));
                    pos.push(newI + 1);
                    color.push(_clrs[newI + 1]);
                }
            }
            else {
                if (i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                    if (bShowArray[newI + 1]) {
                        if (j <= parseInt((DIV) / 2)) {
                            ret.push(new THREE.Vector3(x, y, z));
                            pos.push(bShowArray[newI + 1]);
                            color.push(_clrs[newI + 1]);
                        }
                    }
                }

                if (i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                    if (bShowArray[newI + 2]) {
                        if (j > parseInt((DIV) / 2)) {
                            savedPoints.push(new THREE.Vector3(x, y, z));
                            savedPos.push(bShowArray[newI + 2]);
                            savedColor.push(_clrs[newI + 2]);
                        }
                    }
                }
            } // end else

        } // end for (var j = 0;
    } // end for (var i = -1;

    if (!bShowArray || bShowArray[newI + 1]) {
        //if(bHighlight) {
        ret = ret.concat(savedPoints);
        pos = pos.concat(savedPos);
        color = color.concat(savedColor);
        //}

        ret.push(pnts[pnts.length - 1 - nexttwoLen]);
        pos.push(pnts.length - 1 - nexttwoLen);
        color.push(_clrs[pnts.length - 1 - nexttwoLen]);
    }

    savedPoints = [];
    savedPos = [];
    savedColor = [];
    pnts = [];

    var pnts_positions = [];

    pnts_positions.push(ret);
    pnts_positions.push(pos);
    pnts_positions.push(color);

    return pnts_positions;
};

iCn3D.prototype.createCurveSubArrow = function (p, width, colors, div, bHighlight, bRibbon, num, positionIndex, pntsCA, prevCOArray, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo) {
    var divPoints = [], positions = [];

    divPoints.push(p);
    positions.push(positionIndex);

    this.prepareStrand(divPoints, positions, width, colors, div, undefined, bHighlight, bRibbon, num, pntsCA, prevCOArray, false, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo);

    divPoints = [];
    positions = [];
};

iCn3D.prototype.setCalphaDrawnCoord = function (pnts, div, calphaIdArray) {
    var index = 0;

    if (calphaIdArray !== undefined) {
        for (var i = 0, il = pnts.length; i < il; i += div) { // pnts.length = (calphaIdArray.length - 1) * div + 1
            var serial = calphaIdArray[index];

            if (this.atoms.hasOwnProperty(serial)) {
                this.atoms[serial].coord2 = pnts[i].clone();
            }

            ++index;
        }
    }
};


// modified from iview (http://star.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createCurveSub = function (_pnts, width, colors, div, bHighlight, bRibbon, bNoSmoothen, bShowArray, calphaIdArray, positions, prevone, nexttwo) {
    if (_pnts.length === 0) return;
    div = div || 5;
    var pnts;
    if (!bNoSmoothen) {
        var bExtendLastRes = true;
        var pnts_clrs = this.subdivide(_pnts, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
        pnts = pnts_clrs[0];
        colors = pnts_clrs[2];
    }
    else {
        pnts = _pnts;
    }
    if (pnts.length === 0) return;

    this.setCalphaDrawnCoord(pnts, div, calphaIdArray);

    if (bHighlight === 1) {
        var radius = this.coilWidth / 2;
        //var radiusSegments = 8;
        var radiusSegments = 4; // save memory
        var closed = false;

        if (pnts.length > 1) {
            if (positions !== undefined) {
                var currPos, prevPos;
                var currPoints = [];
                for (var i = 0, il = pnts.length; i < il; ++i) {
                    currPos = positions[i];

                    if ((currPos !== prevPos && currPos !== prevPos + 1 && prevPos !== undefined) || (i === il - 1)) {
                        // first tube
                        var geometry0 = new THREE.TubeGeometry(
                            new THREE.CatmullRomCurve3(currPoints), // path
                            currPoints.length, // segments
                            radius,
                            radiusSegments,
                            closed
                        );

                        mesh = new THREE.Mesh(geometry0, this.matShader);
                        mesh.renderOrder = this.renderOrderPicking;
                        //this.mdlPicking.add(mesh);
                        this.mdl.add(mesh);

                        this.prevHighlightObjects.push(mesh);

                        geometry0 = null;

                        currPoints = [];
                    }

                    currPoints.push(pnts[i]);

                    prevPos = currPos;
                }

                currPoints = [];
            }
            else {
                var geometry0 = new THREE.TubeGeometry(
                    new THREE.CatmullRomCurve3(pnts), // path
                    pnts.length, // segments
                    radius,
                    radiusSegments,
                    closed
                );

                mesh = new THREE.Mesh(geometry0, this.matShader);
                mesh.renderOrder = this.renderOrderPicking;
                //this.mdlPicking.add(mesh);
                this.mdl.add(mesh);

                this.prevHighlightObjects.push(mesh);

                geometry0 = null;
            }
        }
    }
    else {
        var geo = new THREE.Geometry();

        if (bHighlight === 2 && bRibbon) {
            for (var i = 0, divInv = 1 / div; i < pnts.length; ++i) {
                // shift the highlight a little bit to avoid the overlap with ribbon
                pnts[i].addScalar(0.6); // this.ribbonthickness is 0.4
                geo.vertices.push(pnts[i]);
                //geo.colors.push(new THREE.Color(colors[i === 0 ? 0 : Math.round((i - 1) * divInv)]));
                geo.colors.push(new THREE.Color(colors[i]));
            }
        }
        else {
            for (var i = 0, divInv = 1 / div; i < pnts.length; ++i) {
                geo.vertices.push(pnts[i]);
                //geo.colors.push(new THREE.Color(colors[i === 0 ? 0 : Math.round((i - 1) * divInv)]));
                geo.colors.push(new THREE.Color(colors[i]));
            }
        }

        var line = new THREE.Line(geo, new THREE.LineBasicMaterial({ linewidth: width, vertexColors: true }), THREE.LineStrip);
        this.mdl.add(line);
        if (bHighlight === 2) {
            this.prevHighlightObjects.push(line);
        }
        else {
            this.objects.push(line);
        }
    }

    pnts = null;
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createCylinderCurve = function (atoms, atomNameArray, radius, bLines, bHighlight) {
    var start = null;
    var currentChain, currentResi;
    var i;
    var pnts = [], colors = [], radii = [];

    var maxDistance = 8.0; // max residue-residue (or nucleitide-nucleitide) distance allowed

    for (i in atoms) {
        var atom = atoms[i];
        if (atom.het) continue;

        //if (atom.name !== atomName) continue;
        if (atomNameArray.indexOf(atom.name) == -1) continue;

        if (start !== null && currentChain === atom.chain && currentResi + 1 === atom.resi && Math.abs(start.coord.x - atom.coord.x) < maxDistance && Math.abs(start.coord.y - atom.coord.y) < maxDistance && Math.abs(start.coord.z - atom.coord.z) < maxDistance) {
            //            if (start !== null && currentChain === atom.chain && Math.abs(start.coord.x - atom.coord.x) < maxDistance && Math.abs(start.coord.y - atom.coord.y) < maxDistance && Math.abs(start.coord.z - atom.coord.z) < maxDistance ) {
            var middleCoord = start.coord.clone().add(atom.coord).multiplyScalar(0.5);

            if (!bHighlight) {
                if (bLines) {
                    var line = this.createSingleLine(start.coord, middleCoord, start.color, false);
                    this.mdl.add(line);
                    this.objects.push(line);
                    line = this.createSingleLine(middleCoord, atom.coord, atom.color, false);
                    this.mdl.add(line);
                    this.objects.push(line);
                }
                else {
                    this.createCylinder(start.coord, middleCoord, radius, start.color);
                    this.createCylinder(middleCoord, atom.coord, radius, atom.color);
                    this.createSphere(atom, radius, true, 1, bHighlight);
                }
            }
            else if (bHighlight === 1) {
                this.createCylinder(start.coord, middleCoord, radius, start.color, bHighlight);
                this.createCylinder(middleCoord, atom.coord, radius, atom.color, bHighlight);
                this.createSphere(atom, radius, true, 1, bHighlight);
            }
        }

        start = atom;
        currentChain = atom.chain;
        currentResi = atom.resi;

        if (bHighlight === 2) this.createBox(atom, undefined, undefined, undefined, undefined, bHighlight);
    }
    if (start !== null && currentChain === atom.chain && currentResi + 1 === atom.resi && Math.abs(start.coord.x - atom.coord.x) < maxDistance && Math.abs(start.coord.y - atom.coord.y) < maxDistance && Math.abs(start.coord.z - atom.coord.z) < maxDistance) {
        //        if (start !== null && currentChain === atom.chain && Math.abs(start.coord.x - atom.coord.x) < maxDistance && Math.abs(start.coord.y - atom.coord.y) < maxDistance && Math.abs(start.coord.z - atom.coord.z) < maxDistance ) {
        var middleCoord = start.coord.add(atom.coord).multiplyScalar(0.5);
        if (!bHighlight) {
            if (bLines) {
                var line = this.createSingleLine(start.coord, middleCoord, start.color, false);
                this.mdl.add(line);
                this.objects.push(line);
                line = this.createSingleLine(middleCoord, atom.coord, atom.color, false);
                this.mdl.add(line);
                this.objects.push(line);
            }
            else {
                this.createCylinder(start.coord, middleCoord, radius, start.color);
                this.createCylinder(middleCoord, atom.coord, radius, atom.color);
            }
        }
        else if (bHighlight === 1) {
            this.createCylinder(start.coord, middleCoord, radius, start.color, bHighlight);
            this.createCylinder(middleCoord, atom.coord, radius, atom.color, bHighlight);
            this.createSphere(atom, radius, true, 1, bHighlight);
        }
    }
};

iCn3D.prototype.prepareStrand = function (divPoints, positions, width, colors, div, thickness, bHighlight, bRibbon, num, pntsCA, prevCOArray, bStrip, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo) {
    if (pntsCA.length === 1) {
        return;
    }

    var colorsLastTwo = [];
    colorsLastTwo.push(colors[colors.length - 2]);
    colorsLastTwo.push(colors[colors.length - 1]);

    div = div || this.axisDIV;
    var numM1Inv2 = 2 / (num - 1);
    var delta, lastCAIndex, lastPrevCOIndex, v;

    var pnts = {}, colorsTmp = [];
    for (var i = 0, il = positions.length; i < il; ++i) pnts[i] = [];

    // smooth C-alpha
    var pnts_clrs = this.subdivide(pntsCA, colors, div, undefined, undefined, prevone, nexttwo);
    var pntsCASmooth = pnts_clrs[0]; // get all smoothen pnts, do not use 'bShowArray'
    //colors = pnts_clrs[2];

    if (pntsCASmooth.length === 1) {
        return;
    }

    // draw the sheet without the last residue
    // use the sheet coord for n-2 residues
    var colorsTmp = [];
    var lastIndex = (bShowArrow === undefined || bShowArrow) ? pntsCA.length - 2 : pntsCA.length;

    for (var i = 0, il = lastIndex; i < il; ++i) {
        for (var index = 0, indexl = positions.length; index < indexl; ++index) {
            pnts[index].push(divPoints[index][i]);
        }
        colorsTmp.push(colors[i]);
    }
    colorsTmp.push(colors[i]);

    if (bShowArrow === undefined || bShowArrow) {
        // assign the sheet coord from C-alpha for the 2nd to the last residue of the sheet
        for (var i = 0, il = positions.length; i < il; ++i) {
            delta = -1 + numM1Inv2 * positions[i];
            lastCAIndex = pntsCASmooth.length - 1 - div;
            lastPrevCOIndex = pntsCA.length - 2;
            v = new THREE.Vector3(pntsCASmooth[lastCAIndex].x + prevCOArray[lastPrevCOIndex].x * delta, pntsCASmooth[lastCAIndex].y + prevCOArray[lastPrevCOIndex].y * delta, pntsCASmooth[lastCAIndex].z + prevCOArray[lastPrevCOIndex].z * delta);
            pnts[i].push(v);
        }
    }

    var posIndex = [];
    var results;
    for (var i = 0, il = positions.length; i < il; ++i) {
        results = this.subdivide(pnts[i], colorsTmp, div, bShowArray, bHighlight);
        pnts[i] = results[0];
        colors = results[2];
        if (i === 0) {
            posIndex = results[1];
        }
    }

    if (bStrip) {
        this.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight, true, undefined, calphaIdArray, posIndex, prevone, nexttwo);
    }
    else {
        this.createCurveSub(pnts[0], width, colors, div, bHighlight, bRibbon, true, undefined, calphaIdArray, posIndex, prevone, nexttwo);
    }

    if (bShowArrow === undefined || bShowArrow) {
        // draw the arrow
        colorsTmp = [];

        posIndex = [];
        for (var index = 0, indexl = positions.length; index < indexl; ++index) {
            pnts[index] = [];

            for (var i = div * (pntsCA.length - 2), il = div * (pntsCA.length - 1); bShowArray[parseInt(i / div)] && i < il; i = i + div) {
                var pos = parseInt(i / div);
                for (var j = 0; j < div; ++j) {
                    var delta = -1 + numM1Inv2 * positions[index];
                    var scale = 1.8; // scale of the arrow width
                    delta = delta * scale * (div - j) / div;
                    var oriIndex = parseInt(i / div);

                    var v = new THREE.Vector3(pntsCASmooth[i + j].x + prevCOArray[oriIndex].x * delta, pntsCASmooth[i + j].y + prevCOArray[oriIndex].y * delta, pntsCASmooth[i + j].z + prevCOArray[oriIndex].z * delta);
                    v.smoothen = true;
                    pnts[index].push(v);
                    colorsTmp.push(colorsLastTwo[0]);
                    if (index === 0) posIndex.push(pos);
                }
            }

            // last residue
            // make the arrow end with 0
            var delta = 0;
            var lastCAIndex = pntsCASmooth.length - 1;
            var lastPrevCOIndex = pntsCA.length - 1;

            //if(bShowArray[lastPrevCOIndex]) {
            var v = new THREE.Vector3(pntsCASmooth[lastCAIndex].x + prevCOArray[lastPrevCOIndex].x * delta, pntsCASmooth[lastCAIndex].y + prevCOArray[lastPrevCOIndex].y * delta, pntsCASmooth[lastCAIndex].z + prevCOArray[lastPrevCOIndex].z * delta);
            v.smoothen = true;
            pnts[index].push(v);
            colorsTmp.push(colorsLastTwo[1]);
            if (index === 0) posIndex.push(lastCAIndex);
            //}
        }

        pntsCASmooth = [];

        //colorsTmp.push(colors[colors.length - 2]);
        //colorsTmp.push(colors[colors.length - 1]);

        if (bStrip) {
            this.createStrip(pnts[0], pnts[1], colorsTmp, div, thickness, bHighlight, true, undefined, undefined, posIndex, prevone, nexttwo);
        }
        else {
            this.createCurveSub(pnts[0], width, colorsTmp, div, bHighlight, bRibbon, true, undefined, undefined, posIndex, prevone, nexttwo);
        }
    }

    for (var i in pnts) {
        for (var j = 0, jl = pnts[i].length; j < jl; ++j) {
            pnts[i][j] = null;
        }
        pnts[i] = [];
    }

    pnts = {};
};

iCn3D.prototype.createStripArrow = function (p0, p1, colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo) {
    var divPoints = [], positions = [];

    divPoints.push(p0);
    divPoints.push(p1);
    positions.push(start);
    positions.push(end);

    this.prepareStrand(divPoints, positions, undefined, colors, div, thickness, bHighlight, undefined, num, pntsCA, prevCOArray, true, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo);

    divPoints = [];
    positions = [];
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createStrip = function (p0, p1, colors, div, thickness, bHighlight, bNoSmoothen, bShowArray, calphaIdArray, positions, prevone, nexttwo) {
    if (p0.length < 2) return;
    div = div || this.axisDIV;
    if (!bNoSmoothen) {
        var bExtendLastRes = true;
        var pnts_clrs0 = this.subdivide(p0, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
        var pnts_clrs1 = this.subdivide(p1, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
        p0 = pnts_clrs0[0];
        p1 = pnts_clrs1[0];
        colors = pnts_clrs0[2];
    }
    if (p0.length < 2) return;

    this.setCalphaDrawnCoord(p0, div, calphaIdArray);

    if (bHighlight === 1) {
        //mesh = new THREE.Mesh(geo, this.matShader);

        var radius = this.coilWidth / 2;
        //var radiusSegments = 8;
        var radiusSegments = 4; // save memory
        var closed = false;

        if (positions !== undefined) {
            var currPos, prevPos;
            var currP0 = [], currP1 = [];

            for (var i = 0, il = p0.length; i < il; ++i) {
                currPos = positions[i];

                if ((currPos !== prevPos && currPos !== prevPos + 1 && prevPos !== undefined) || (i === il - 1)) {
                    // first tube
                    var geometry0 = new THREE.TubeGeometry(
                        new THREE.CatmullRomCurve3(currP0), // path
                        currP0.length, // segments
                        radius,
                        radiusSegments,
                        closed
                    );

                    mesh = new THREE.Mesh(geometry0, this.matShader);
                    mesh.renderOrder = this.renderOrderPicking;
                    //this.mdlPicking.add(mesh);
                    this.mdl.add(mesh);

                    this.prevHighlightObjects.push(mesh);

                    geometry0 = null;

                    // second tube
                    var geometry1 = new THREE.TubeGeometry(
                        new THREE.CatmullRomCurve3(currP1), // path
                        currP1.length, // segments
                        radius,
                        radiusSegments,
                        closed
                    );

                    mesh = new THREE.Mesh(geometry1, this.matShader);
                    mesh.renderOrder = this.renderOrderPicking;
                    //this.mdlPicking.add(mesh);
                    this.mdl.add(mesh);

                    this.prevHighlightObjects.push(mesh);

                    geometry1 = null;

                    currP0 = [];
                    currP1 = [];
                }

                currP0.push(p0[i]);
                currP1.push(p1[i]);

                prevPos = currPos;
            }

            currP0 = [];
            currP1 = [];
        }
        else {
            // first tube
            var geometry0 = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(p0), // path
                p0.length, // segments
                radius,
                radiusSegments,
                closed
            );

            mesh = new THREE.Mesh(geometry0, this.matShader);
            mesh.renderOrder = this.renderOrderPicking;
            //this.mdlPicking.add(mesh);
            this.mdl.add(mesh);

            this.prevHighlightObjects.push(mesh);

            geometry0 = null;

            // second tube
            var geometry1 = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(p1), // path
                p1.length, // segments
                radius,
                radiusSegments,
                closed
            );

            mesh = new THREE.Mesh(geometry1, this.matShader);
            mesh.renderOrder = this.renderOrderPicking;
            //this.mdlPicking.add(mesh);
            this.mdl.add(mesh);

            this.prevHighlightObjects.push(mesh);

            geometry1 = null;
        }
    }
    else {
        var geo = new THREE.Geometry();
        var vs = geo.vertices, fs = geo.faces;
        var axis, p0v, p1v, a0v, a1v;
        for (var i = 0, lim = p0.length; i < lim; ++i) {
            vs.push(p0v = p0[i]); // 0
            vs.push(p0v); // 1
            vs.push(p1v = p1[i]); // 2
            vs.push(p1v); // 3
            if (i < lim - 1) {
                axis = p1[i].clone().sub(p0[i]).cross(p0[i + 1].clone().sub(p0[i])).normalize().multiplyScalar(thickness);
            }
            vs.push(a0v = p0[i].clone().add(axis)); // 4
            vs.push(a0v); // 5
            vs.push(a1v = p1[i].clone().add(axis)); // 6
            vs.push(a1v); // 7
        }
        var faces = [[0, 2, -6, -8], [-4, -2, 6, 4], [7, 3, -5, -1], [-3, -7, 1, 5]];

        for (var i = 1, lim = p0.length, divInv = 1 / div; i < lim; ++i) {
            var offset = 8 * i;
            //var color = new THREE.Color(colors[Math.round((i - 1) * divInv)]);
            var color = new THREE.Color(colors[i - 1]);
            for (var j = 0; j < 4; ++j) {
                fs.push(new THREE.Face3(offset + faces[j][0], offset + faces[j][1], offset + faces[j][2], undefined, color));
                fs.push(new THREE.Face3(offset + faces[j][3], offset + faces[j][0], offset + faces[j][2], undefined, color));
            }
        }
        var vsize = vs.length - 8; // Cap
        for (var i = 0; i < 4; ++i) {
            vs.push(vs[i * 2]);
            vs.push(vs[vsize + i * 2]);
        };
        vsize += 8;
        fs.push(new THREE.Face3(vsize, vsize + 2, vsize + 6, undefined, fs[0].color));
        fs.push(new THREE.Face3(vsize + 4, vsize, vsize + 6, undefined, fs[0].color));
        fs.push(new THREE.Face3(vsize + 1, vsize + 5, vsize + 7, undefined, fs[fs.length - 3].color));
        fs.push(new THREE.Face3(vsize + 3, vsize + 1, vsize + 7, undefined, fs[fs.length - 3].color));
        geo.computeFaceNormals();
        geo.computeVertexNormals(false);

        var mesh;

        if (bHighlight === 2) {
            mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));

            this.mdl.add(mesh);
            this.prevHighlightObjects.push(mesh);
        }
        else {
            mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));

            this.mdl.add(mesh);
            this.objects.push(mesh);
        }
    }

    p0 = null;
    p1 = null;
};

// significantly modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createStrand = function (atoms, num, div, fill, coilWidth, helixSheetWidth, doNotSmoothen, thickness, bHighlight) {
    var bRibbon = fill ? true : false;

    // when highlight, the input atoms may only include part of sheet or helix
    // include the whole sheet or helix when highlighting
    var atomsAdjust = {};

    //if( (bHighlight === 1 || bHighlight === 2) && !this.bAllAtoms) {
    if (!this.bAllAtoms) {
        var currChain, currResi, currAtom, prevChain, prevResi, prevAtom;
        var firstAtom, lastAtom;
        var index = 0, length = Object.keys(atoms).length;

        atomsAdjust = this.cloneHash(atoms);
        for (var serial in atoms) {
            currChain = atoms[serial].structure + '_' + atoms[serial].chain;
            currResi = parseInt(atoms[serial].resi);
            currAtom = atoms[serial];

            if (prevChain === undefined) firstAtom = atoms[serial];

            if ((currChain !== prevChain && prevChain !== undefined) || (currResi !== prevResi && currResi !== prevResi + 1 && prevResi !== undefined) || index === length - 1) {
                if ((currChain !== prevChain && prevChain !== undefined) || (currResi !== prevResi && currResi !== prevResi + 1 && prevResi !== undefined)) {
                    //              if( (currChain !== prevChain && prevChain !== undefined) || index === length - 1) {
                    //                if( (currChain !== prevChain && prevChain !== undefined) ) {
                    lastAtom = prevAtom;
                }
                else if (index === length - 1) {
                    lastAtom = currAtom;
                }

                // fill the beginning
                var beginResi = firstAtom.resi;
                if (firstAtom.ss !== 'coil' && !(firstAtom.ssbegin)) {
                    for (var i = firstAtom.resi - 1; i > 0; --i) {
                        var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
                        if (!this.residues.hasOwnProperty(residueid)) break;

                        var atom = this.getFirstAtomObj(this.residues[residueid]);

                        if (atom.ss === firstAtom.ss && atom.ssbegin) {
                            beginResi = atom.resi;
                            break;
                        }
                    }

                    for (var i = beginResi; i < firstAtom.resi; ++i) {
                        var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
                        atomsAdjust = this.unionHash(atomsAdjust, this.hash2Atoms(this.residues[residueid]));
                    }
                }

                // add one extra residue for coils between strands/helix
                if (this.pk === 3 && bHighlight === 1 && firstAtom.ss === 'coil') {
                    var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + (firstAtom.resi - 1);
                    if (this.residues.hasOwnProperty(residueid)) {
                        atomsAdjust = this.unionHash(atomsAdjust, this.hash2Atoms(this.residues[residueid]));
                        atoms = this.unionHash(atoms, this.hash2Atoms(this.residues[residueid]));
                    }
                }

                // fill the end
                var endResi = lastAtom.resi;
                // when a coil connects to a sheet and the last residue of coil is highlighted, the first sheet residue is set as atom.notshow. This residue should not be shown.
                if (lastAtom.ss !== 'coil' && !(lastAtom.ssend) && !(lastAtom.notshow)) {
                    var endChainResi = this.getLastAtomObj(this.chains[lastAtom.structure + '_' + lastAtom.chain]).resi;
                    for (var i = lastAtom.resi + 1; i <= endChainResi; ++i) {
                        var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
                        if (!this.residues.hasOwnProperty(residueid)) break;

                        var atom = this.getFirstAtomObj(this.residues[residueid]);

                        if (atom.ss === lastAtom.ss && atom.ssend) {
                            endResi = atom.resi;
                            break;
                        }
                    }

                    for (var i = lastAtom.resi + 1; i <= endResi; ++i) {
                        var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
                        atomsAdjust = this.unionHash(atomsAdjust, this.hash2Atoms(this.residues[residueid]));
                    }
                }

                // add one extra residue for coils between strands/helix
                if (this.pk === 3 && bHighlight === 1 && lastAtom.ss === 'coil') {
                    var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + (lastAtom.resi + 1);
                    if (this.residues.hasOwnProperty(residueid)) {
                        atomsAdjust = this.unionHash(atomsAdjust, this.hash2Atoms(this.residues[residueid]));
                        atoms = this.unionHash(atoms, this.hash2Atoms(this.residues[residueid]));
                    }
                }

                // reset notshow
                if (lastAtom.notshow) lastAtom.notshow = undefined;

                firstAtom = currAtom;
            }

            prevChain = currChain;
            prevResi = currResi;
            prevAtom = currAtom;

            ++index;
        }
    }
    else {
        atomsAdjust = atoms;
    }

    if (bHighlight === 2) {
        if (fill) {
            fill = false;
            num = null;
            div = null;
            coilWidth = null;
            helixSheetWidth = null;
            thickness = undefined;
        }
        else {
            fill = true;
            num = 2;
            div = undefined;
            coilWidth = undefined;
            helixSheetWidth = undefined;
            thickness = this.ribbonthickness;
        }
    }

    num = num || this.strandDIV;
    div = div || this.axisDIV;
    coilWidth = coilWidth || this.coilWidth;
    doNotSmoothen = doNotSmoothen || false;
    helixSheetWidth = helixSheetWidth || this.helixSheetWidth;
    var pnts = {}; for (var k = 0; k < num; ++k) pnts[k] = [];
    var pntsCA = [];
    var prevCOArray = [];
    var bShowArray = [];
    var calphaIdArray = []; // used to store one of the final positions drawn in 3D
    var colors = [];
    var currentChain, currentResi, currentCA = null, currentO = null, currentColor = null, prevCoorCA = null, prevCoorO = null, prevColor = null;
    var prevCO = null, ss = null, ssend = false, atomid = null, prevAtomid = null, prevResi = null, calphaid = null, prevCalphaid = null;
    var strandWidth, bSheetSegment = false, bHelixSegment = false;
    var atom, tubeAtoms = {};

    // test the first 30 atoms to see whether only C-alpha is available
    this.bCalphaOnly = this.isCalphaPhosOnly(atomsAdjust, 'CA');

    // when highlight, draw whole beta sheet and use bShowArray to show the highlight part
    var residueHash = {};
    for (var i in atomsAdjust) {
        var atom = atomsAdjust[i];

        residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
        residueHash[residueid] = 1;
    }
    var totalResidueCount = Object.keys(residueHash).length;

    var drawnResidueCount = 0;
    var highlightResiduesCount = 0;

    var bFullAtom = (Object.keys(this.hAtoms).length == Object.keys(this.atoms).length) ? true : false;

    for (var i in atomsAdjust) {
        atom = atomsAdjust[i];
        var atomOxygen = undefined;
        if ((atom.name === 'O' || atom.name === 'CA') && !atom.het) {
            // "CA" has to appear before "O"

            if (atom.name === 'CA') {
                if (atoms.hasOwnProperty(i) && ((atom.ss !== 'helix' && atom.ss !== 'sheet') || atom.ssend || atom.ssbegin)) {
                    tubeAtoms[i] = atom;
                }

                currentCA = atom.coord;
                currentColor = atom.color;
                calphaid = atom.serial;
            }

            if (atom.name === 'O' || (this.bCalphaOnly && atom.name === 'CA')) {
                if (atom.name === 'O') {
                    currentO = atom.coord;
                }
                // smoothen each coil, helix and sheet separately. The joint residue has to be included both in the previous and next segment
                var bSameChain = true;
                if (currentChain !== atom.chain || currentResi + 1 !== atom.resi) {
                    //                        if (currentChain !== atom.chain) {
                    bSameChain = false;
                }

                if (atom.ssend && atom.ss === 'sheet') {
                    bSheetSegment = true;
                }
                else if (atom.ssend && atom.ss === 'helix') {
                    bHelixSegment = true;
                }

                // assign the previous residue
                if (prevCoorO) {
                    if (bHighlight === 1 || bHighlight === 2) {
                        colors.push(this.hColor);
                    }
                    else {
                        colors.push(prevColor);
                    }

                    if (ss !== 'coil' && atom.ss === 'coil') {
                        strandWidth = coilWidth;
                    }
                    else if (ssend && atom.ssbegin) { // a transition between two ss
                        strandWidth = coilWidth;
                    }
                    else {
                        strandWidth = (ss === 'coil') ? coilWidth : helixSheetWidth;
                    }

                    var O;
                    if (atom.name === 'O') {
                        O = prevCoorO.clone();
                        if (prevCoorCA !== null && prevCoorCA !== undefined) {
                            O.sub(prevCoorCA);
                        }
                        else {
                            prevCoorCA = prevCoorO.clone();
                            O = new THREE.Vector3(Math.random(), Math.random(), Math.random());
                        }
                    }
                    else if (this.bCalphaOnly && atom.name === 'CA') {
                        O = new THREE.Vector3(Math.random(), Math.random(), Math.random());
                    }

                    O.normalize(); // can be omitted for performance
                    O.multiplyScalar(strandWidth);
                    if (prevCO !== null && O.dot(prevCO) < 0) O.negate();
                    prevCO = O;

                    for (var j = 0, numM1Inv2 = 2 / (num - 1); j < num; ++j) {
                        var delta = -1 + numM1Inv2 * j;
                        var v = new THREE.Vector3(prevCoorCA.x + prevCO.x * delta, prevCoorCA.y + prevCO.y * delta, prevCoorCA.z + prevCO.z * delta);
                        if (!doNotSmoothen && ss === 'sheet') v.smoothen = true;
                        pnts[j].push(v);
                    }

                    pntsCA.push(prevCoorCA);
                    prevCOArray.push(prevCO);

                    if (atoms.hasOwnProperty(prevAtomid)) {
                        bShowArray.push(prevResi);
                        calphaIdArray.push(prevCalphaid);

                        ++highlightResiduesCount;
                    }
                    else {
                        bShowArray.push(0);
                        calphaIdArray.push(0);
                    }

                    ++drawnResidueCount;
                }

                //var maxDist = 6.0;
                //var bBrokenSs = (prevCoorCA && Math.abs(currentCA.x - prevCoorCA.x) > maxDist) || (prevCoorCA && Math.abs(currentCA.y - prevCoorCA.y) > maxDist) || (prevCoorCA && Math.abs(currentCA.z - prevCoorCA.z) > maxDist);

                if ((atom.ssbegin || atom.ssend || (drawnResidueCount === totalResidueCount - 1)) && pnts[0].length > 0 && bSameChain) {
                    var atomName = 'CA';

                    var prevone = [], nexttwo = [];

                    var prevoneResid = this.atoms[prevAtomid].structure + '_' + this.atoms[prevAtomid].chain + '_' + (this.atoms[prevAtomid].resi - 1).toString();
                    var prevoneCoord = this.getAtomCoordFromResi(prevoneResid, atomName);
                    prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];

                    var nextoneResid = this.atoms[prevAtomid].structure + '_' + this.atoms[prevAtomid].chain + '_' + (this.atoms[prevAtomid].resi + 1).toString();
                    var nextoneCoord = this.getAtomCoordFromResi(nextoneResid, atomName);
                    if (nextoneCoord !== undefined) {
                        nexttwo.push(nextoneCoord);
                    }

                    var nexttwoResid = this.atoms[prevAtomid].structure + '_' + this.atoms[prevAtomid].chain + '_' + (this.atoms[prevAtomid].resi + 2).toString();
                    var nexttwoCoord = this.getAtomCoordFromResi(nexttwoResid, atomName);
                    if (nexttwoCoord !== undefined) {
                        nexttwo.push(nexttwoCoord);
                    }

                    // assign the current joint residue to the previous segment
                    if (bHighlight === 1 || bHighlight === 2) {
                        colors.push(this.hColor);
                    }
                    else {
                        //colors.push(atom.color);
                        colors.push(prevColor);
                    }

                    if (atom.ssend && atom.ss === 'sheet') { // current residue is the end of ss and is the end of arrow
                        strandWidth = 0; // make the arrow end sharp
                    }
                    else if (ss === 'coil' && atom.ssbegin) {
                        strandWidth = coilWidth;
                    }
                    else if (ssend && atom.ssbegin) { // current residue is the start of ss and  the previous residue is the end of ss, then use coil
                        strandWidth = coilWidth;
                    }
                    else { // use the ss from the previous residue
                        strandWidth = (atom.ss === 'coil') ? coilWidth : helixSheetWidth;
                    }

                    var O;
                    if (atom.name === 'O') {
                        O = currentO.clone();
                        O.sub(currentCA);
                    }
                    else if (this.bCalphaOnly && atom.name === 'CA') {
                        O = new THREE.Vector3(Math.random(), Math.random(), Math.random());
                    }

                    O.normalize(); // can be omitted for performance
                    O.multiplyScalar(strandWidth);
                    if (prevCO !== null && O.dot(prevCO) < 0) O.negate();
                    prevCO = O;

                    for (var j = 0, numM1Inv2 = 2 / (num - 1); j < num; ++j) {
                        var delta = -1 + numM1Inv2 * j;
                        var v = new THREE.Vector3(currentCA.x + prevCO.x * delta, currentCA.y + prevCO.y * delta, currentCA.z + prevCO.z * delta);
                        if (!doNotSmoothen && ss === 'sheet') v.smoothen = true;
                        pnts[j].push(v);
                    }

                    atomid = atom.serial;

                    pntsCA.push(currentCA);
                    prevCOArray.push(prevCO);

                    // when a coil connects to a sheet and the last residue of coild is highlighted, the first sheet residue is set as atom.highlightStyle. This residue should not be shown.
                    //if(atoms.hasOwnProperty(atomid) && (bHighlight === 1 && !atom.notshow) ) {
                    if (atoms.hasOwnProperty(atomid)) {
                        bShowArray.push(atom.resi);
                        calphaIdArray.push(calphaid);
                    }
                    else {
                        bShowArray.push(0);
                        calphaIdArray.push(0);
                    }

                    // draw the current segment
                    for (var j = 0; !fill && j < num; ++j) {
                        if (bSheetSegment) {
                            this.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                        }
                        else if (bHelixSegment) {
                            if (bFullAtom) {
                                this.createCurveSub(pnts[j], 1, colors, div, bHighlight, bRibbon, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                            }
                            else {
                                this.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                            }
                        }
                    }
                    if (fill) {
                        if (bSheetSegment) {
                            var start = 0, end = num - 1;
                            this.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                        }
                        else if (bHelixSegment) {
                            if (bFullAtom) {
                                this.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                            }
                            else {
                                var start = 0, end = num - 1;
                                this.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                            }
                        }
                        else {
                            if (bHighlight === 2) { // draw coils only when highlighted. if not highlighted, coils will be drawn as tubes separately
                                this.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                            }
                        }
                    }
                    for (var k = 0; k < num; ++k) pnts[k] = [];

                    colors = [];
                    pntsCA = [];
                    prevCOArray = [];
                    bShowArray = [];
                    calphaIdArray = [];
                    bSheetSegment = false;
                    bHelixSegment = false;
                } // end if (atom.ssbegin || atom.ssend)

                // end of a chain
                if ((currentChain !== atom.chain || currentResi + 1 !== atom.resi) && pnts[0].length > 0) {
                    //                        if ((currentChain !== atom.chain) && pnts[0].length > 0) {

                    var atomName = 'CA';

                    var prevoneResid = this.atoms[prevAtomid].structure + '_' + this.atoms[prevAtomid].chain + '_' + (this.atoms[prevAtomid].resi - 1).toString();
                    var prevoneCoord = this.getAtomCoordFromResi(prevoneResid, atomName);
                    var prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];

                    var nexttwo = [];

                    for (var j = 0; !fill && j < num; ++j) {
                        if (bSheetSegment) {
                            this.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                        }
                        else if (bHelixSegment) {
                            if (bFullAtom) {
                                this.createCurveSub(pnts[j], 1, colors, div, bHighlight, bRibbon, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                            }
                            else {
                                this.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                            }
                        }
                    }
                    if (fill) {
                        if (bSheetSegment) {
                            var start = 0, end = num - 1;
                            this.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                        }
                        else if (bHelixSegment) {
                            if (bFullAtom) {
                                this.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                            }
                            else {
                                var start = 0, end = num - 1;
                                this.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                            }
                        }
                    }

                    for (var k = 0; k < num; ++k) pnts[k] = [];
                    colors = [];
                    pntsCA = [];
                    prevCOArray = [];
                    bShowArray = [];
                    calphaIdArray = [];
                    bSheetSegment = false;
                    bHelixSegment = false;
                }

                currentChain = atom.chain;
                currentResi = atom.resi;
                ss = atom.ss;
                ssend = atom.ssend;
                prevAtomid = atom.serial;
                prevResi = atom.resi;

                prevCalphaid = calphaid;

                // only update when atom.name === 'O'
                prevCoorCA = currentCA;
                prevCoorO = atom.coord;
                prevColor = currentColor;
            } // end if (atom.name === 'O' || (this.bCalphaOnly && atom.name === 'CA') ) {
        } // end if ((atom.name === 'O' || atom.name === 'CA') && !atom.het) {
    } // end for

    this.createTube(tubeAtoms, 'CA', coilWidth, bHighlight);

    tubeAtoms = {};
    pnts = {};
};

/*
iCn3D.prototype.createStrandBrick = function (brick, color, thickness, bHighlight) {
    var num = this.strandDIV;
    var div = this.axisDIV;
    var doNotSmoothen = false;
    var helixSheetWidth = this.helixSheetWidth;

    if(bHighlight === 2) {
        thickness *= 1.5;
        helixSheetWidth *= 1.5;
    }

    var pnts = {}; for (var k = 0; k < num; ++k) pnts[k] = [];
    var colors = [];
    var prevCO = null, ss = null;
    for (var i = 0; i < 2; ++i) {
        var currentCA = brick.coords[i];

        colors.push(new THREE.Color(color));

        var O = new THREE.Vector3(brick.coords[2].x, brick.coords[2].y, brick.coords[2].z);
        O.normalize();

        O.multiplyScalar(helixSheetWidth);
        if (prevCO !== null && O.dot(prevCO) < 0) O.negate();
        prevCO = O;
        for (var j = 0, numM1Inv2 = 2 / (num - 1); j < num; ++j) {
            var delta = -1 + numM1Inv2 * j;
            var v = new THREE.Vector3(currentCA.x + prevCO.x * delta, currentCA.y + prevCO.y * delta, currentCA.z + prevCO.z * delta);
            if (!doNotSmoothen) v.smoothen = true;
            pnts[j].push(v);
        }
    }
    this.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight);
};
*/

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createTubeSub = function (_pnts, colors, radii, bHighlight, prevone, nexttwo) {
    if (_pnts.length < 2) return;
    var circleDiv = this.tubeDIV, axisDiv = this.axisDIV;
    var circleDivInv = 1 / circleDiv, axisDivInv = 1 / axisDiv;
    var geo = new THREE.Geometry();
    var pnts_clrs = this.subdivide(_pnts, colors, axisDiv, undefined, undefined, prevone, nexttwo);

    var pnts = pnts_clrs[0];
    colors = pnts_clrs[2];

    var prevAxis1 = new THREE.Vector3(), prevAxis2;
    for (var i = 0, lim = pnts.length; i < lim; ++i) {
        var r, idx = (i - 1) * axisDivInv;
        if (i === 0) r = radii[0];
        else {
            if (idx % 1 === 0) r = radii[idx];
            else {
                var floored = Math.floor(idx);
                var tmp = idx - floored;
                r = radii[floored] * tmp + radii[floored + 1] * (1 - tmp);
            }
        }
        var delta, axis1, axis2;
        if (i < lim - 1) {
            delta = pnts[i].clone().sub(pnts[i + 1]);
            axis1 = new THREE.Vector3(0, -delta.z, delta.y).normalize().multiplyScalar(r);
            axis2 = delta.clone().cross(axis1).normalize().multiplyScalar(r);
            //      var dir = 1, offset = 0;
            if (prevAxis1.dot(axis1) < 0) {
                axis1.negate(); axis2.negate();  //dir = -1;//offset = 2 * Math.PI / axisDiv;
            }
            prevAxis1 = axis1; prevAxis2 = axis2;
        } else {
            axis1 = prevAxis1; axis2 = prevAxis2;
        }
        for (var j = 0; j < circleDiv; ++j) {
            var angle = 2 * Math.PI * circleDivInv * j; //* dir  + offset;
            geo.vertices.push(pnts[i].clone().add(axis1.clone().multiplyScalar(Math.cos(angle))).add(axis2.clone().multiplyScalar(Math.sin(angle))));
        }
    }
    var offset = 0;
    for (var i = 0, lim = pnts.length - 1; i < lim; ++i) {
        //var c = new THREE.Color(colors[Math.round((i - 1) * axisDivInv)]);
        var c = new THREE.Color(colors[i]);

        var reg = 0;
        var r1 = geo.vertices[offset].clone().sub(geo.vertices[offset + circleDiv]).lengthSq();
        var r2 = geo.vertices[offset].clone().sub(geo.vertices[offset + circleDiv + 1]).lengthSq();
        if (r1 > r2) { r1 = r2; reg = 1; };
        for (var j = 0; j < circleDiv; ++j) {
            geo.faces.push(new THREE.Face3(offset + j, offset + (j + reg) % circleDiv + circleDiv, offset + (j + 1) % circleDiv, undefined, c));
            geo.faces.push(new THREE.Face3(offset + (j + 1) % circleDiv, offset + (j + reg) % circleDiv + circleDiv, offset + (j + reg + 1) % circleDiv + circleDiv, undefined, c));
        }
        offset += circleDiv;
    }
    geo.computeFaceNormals();
    geo.computeVertexNormals(false);

    var mesh;
    if (bHighlight === 2) {
        mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));
        this.mdl.add(mesh);
    }
    else if (bHighlight === 1) {
        mesh = new THREE.Mesh(geo, this.matShader);
        mesh.renderOrder = this.renderOrderPicking;
        //this.mdlPicking.add(mesh);
        this.mdl.add(mesh);
    }
    else {
        mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));
        this.mdl.add(mesh);
    }

    if (bHighlight === 1 || bHighlight === 2) {
        this.prevHighlightObjects.push(mesh);
    }
    else {
        this.objects.push(mesh);
    }
};

iCn3D.prototype.getAtomCoordFromResi = function (resid, atomName) {
    if (this.residues.hasOwnProperty(resid)) {
        for (var i in this.residues[resid]) {
            if (this.atoms[i].name === atomName && !this.atoms[i].het) {
                var coord = (this.atoms[i].coord2 !== undefined) ? this.atoms[i].coord2 : this.atoms[i].coord;

                return coord;
            }
        }
    }

    return undefined;
}

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createTube = function (atoms, atomName, radius, bHighlight) {
    var pnts = [], colors = [], radii = [], prevone = [], nexttwo = [];
    var currentChain, currentResi;
    var index = 0;
    var prevAtom;
    var maxDist = 6.0;

    var pnts_colors_radii_prevone_nexttwo = [];
    var firstAtom, atom;

    for (var i in atoms) {
        atom = atoms[i];
        if ((atom.name === atomName) && !atom.het) {
            if (index == 0) {
                firstAtom = atom;
            }

            if (index > 0 && (currentChain !== atom.chain || currentResi + 1 !== atom.resi || Math.abs(atom.coord.x - prevAtom.coord.x) > maxDist || Math.abs(atom.coord.y - prevAtom.coord.y) > maxDist || Math.abs(atom.coord.z - prevAtom.coord.z) > maxDist)) {
                //                if (index > 0 && (currentChain !== atom.chain || Math.abs(atom.coord.x - prevAtom.coord.x) > 6.0 || Math.abs(atom.coord.y - prevAtom.coord.y) > 6.0 || Math.abs(atom.coord.z - prevAtom.coord.z) > 6.0) ) {
                if (bHighlight !== 2) {
                    //this.createTubeSub(pnts, colors, radii, bHighlight);
                    var prevoneResid = firstAtom.structure + '_' + firstAtom.chain + '_' + (firstAtom.resi - 1).toString();
                    var prevoneCoord = this.getAtomCoordFromResi(prevoneResid, atomName);
                    prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];

                    var nextoneResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (prevAtom.resi + 1).toString();
                    var nextoneCoord = this.getAtomCoordFromResi(nextoneResid, atomName);
                    if (nextoneCoord !== undefined) {
                        nexttwo.push(nextoneCoord);
                    }

                    var nexttwoResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (prevAtom.resi + 2).toString();
                    var nexttwoCoord = this.getAtomCoordFromResi(nexttwoResid, atomName);
                    if (nexttwoCoord !== undefined) {
                        nexttwo.push(nexttwoCoord);
                    }

                    pnts_colors_radii_prevone_nexttwo.push({ 'pnts': pnts, 'colors': colors, 'radii': radii, 'prevone': prevone, 'nexttwo': nexttwo });
                }
                pnts = []; colors = []; radii = []; prevone = []; nexttwo = [];
                firstAtom = atom;
            }
            pnts.push(atom.coord);

            radii.push(radius || (atom.b > 0 ? atom.b * 0.01 : this.coilWidth));
            colors.push(atom.color);

            currentChain = atom.chain;
            currentResi = atom.resi;

            var scale = 1.2;
            if (bHighlight === 2 && !atom.ssbegin) {
                this.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
            }

            ++index;

            prevAtom = atom;
        }
    }
    if (bHighlight !== 2) {
        //this.createTubeSub(pnts, colors, radii, bHighlight);

        prevone = [];
        if (firstAtom !== undefined) {
            var prevoneResid = firstAtom.structure + '_' + firstAtom.chain + '_' + (firstAtom.resi - 1).toString();
            var prevoneCoord = this.getAtomCoordFromResi(prevoneResid, atomName);
            prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];
        }

        nexttwo = [];
        if (atom !== undefined) {
            var nextoneResid = atom.structure + '_' + atom.chain + '_' + (atom.resi + 1).toString();
            var nextoneCoord = this.getAtomCoordFromResi(nextoneResid, atomName);
            if (nextoneCoord !== undefined) {
                nexttwo.push(nextoneCoord);
            }

            var nexttwoResid = atom.structure + '_' + atom.chain + '_' + (atom.resi + 2).toString();
            var nexttwoCoord = this.getAtomCoordFromResi(nexttwoResid, atomName);
            if (nexttwoCoord !== undefined) {
                nexttwo.push(nexttwoCoord);
            }
        }

        pnts_colors_radii_prevone_nexttwo.push({ 'pnts': pnts, 'colors': colors, 'radii': radii, 'prevone': prevone, 'nexttwo': nexttwo });
    }

    for (var i = 0, il = pnts_colors_radii_prevone_nexttwo.length; i < il; ++i) {
        var pnts = pnts_colors_radii_prevone_nexttwo[i].pnts;
        var colors = pnts_colors_radii_prevone_nexttwo[i].colors;
        var radii = pnts_colors_radii_prevone_nexttwo[i].radii;
        var prevone = pnts_colors_radii_prevone_nexttwo[i].prevone;
        var nexttwo = pnts_colors_radii_prevone_nexttwo[i].nexttwo;

        this.createTubeSub(pnts, colors, radii, bHighlight, prevone, nexttwo);
    }

    pnts_colors_radii_prevone_nexttwo = [];
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createCylinderHelix = function (atoms, radius, bHighlight) {
    var start = null;
    var currentChain, currentResi;
    var others = {}, beta = {};
    var i;
    for (i in atoms) {
        var atom = atoms[i];
        if (atom.het) continue;
        if ((atom.ss !== 'helix' && atom.ss !== 'sheet') || atom.ssend || atom.ssbegin) others[atom.serial] = atom;
        if (atom.ss === 'sheet') beta[atom.serial] = atom;
        if (atom.name !== 'CA') continue;
        if (atom.ss === 'helix' && atom.ssend) {
            if (start !== null && currentChain === atom.chain && currentResi < atom.resi) {
                if (bHighlight === 1 || bHighlight === 2) {
                    this.createCylinder(start.coord, atom.coord, radius, this.hColor, bHighlight);
                }
                else {
                    this.createCylinder(start.coord, atom.coord, radius, atom.color);
                }
            }

            start = null;
        }

        if (start === null && atom.ss === 'helix' && atom.ssbegin) {
            start = atom;

            currentChain = atom.chain;
            currentResi = atom.resi;
        }
    }

    if (bHighlight === 1 || bHighlight === 2) {
        if (Object.keys(others).length > 0) this.createTube(others, 'CA', this.coilWidth, bHighlight);
        if (Object.keys(beta).length > 0) this.createStrand(beta, undefined, undefined, true, 0, this.helixSheetWidth, false, this.ribbonthickness * 2, bHighlight);
    }
    else {
        if (Object.keys(others).length > 0) this.createTube(others, 'CA', this.coilWidth);
        if (Object.keys(beta).length > 0) this.createStrand(beta, undefined, undefined, true, 0, this.helixSheetWidth, false, this.ribbonthickness * 2);
    }
};

// modified from GLmol (http://webglmol.osdn.jp/index-en.html)
iCn3D.prototype.drawNucleicAcidStick = function (atomlist, bHighlight) {
    var currentChain, currentResi, start = null, end = null;
    var i;

    for (i in atomlist) {
        var atom = atomlist[i];
        if (atom === undefined || atom.het) continue;

        if (atom.resi !== currentResi || atom.chain !== currentChain) {
            if (start !== null && end !== null) {
                this.createCylinder(new THREE.Vector3(start.coord.x, start.coord.y, start.coord.z),
                    new THREE.Vector3(end.coord.x, end.coord.y, end.coord.z), this.cylinderRadius, start.color, bHighlight);
            }
            start = null; end = null;
        }
        if (atom.name === 'O3\'' || atom.name === 'O3*') start = atom;
        if (atom.resn === '  A' || atom.resn === '  G' || atom.resn === ' DA' || atom.resn === ' DG') {
            if (atom.name === 'N1') end = atom; //  N1(AG), N3(CTU)
        } else if (atom.name === 'N3') {
            end = atom;
        }
        currentResi = atom.resi; currentChain = atom.chain;
    }
    if (start !== null && end !== null)
        this.createCylinder(new THREE.Vector3(start.coord.x, start.coord.y, start.coord.z),
            new THREE.Vector3(end.coord.x, end.coord.y, end.coord.z), this.cylinderRadius, start.color, bHighlight);
};

iCn3D.prototype.isCalphaPhosOnly = function (atomlist, atomname1, atomname2) {
    var bCalphaPhosOnly = false;

    var index = 0, testLength = 30;
    var bOtherAtoms = false;
    for (var i in atomlist) {
        if (index < testLength) {
            if (atomlist[i].name !== atomname1 &&
                (atomname2 == undefined || (atomname2 != undefined && atomlist.name !== atomname2))
            ) {
                bOtherAtoms = true;
                break;
            }
        }
        else {
            break;
        }

        ++index;
    }

    if (!bOtherAtoms) {
        bCalphaPhosOnly = true;
    }

    return bCalphaPhosOnly;
};

// modified from GLmol (http://webglmol.osdn.jp/index-en.html)
iCn3D.prototype.drawCartoonNucleicAcid = function (atomlist, div, thickness, bHighlight) {
    this.drawStrandNucleicAcid(atomlist, 2, div, true, undefined, thickness, bHighlight);
};

// modified from GLmol (http://webglmol.osdn.jp/index-en.html)
iCn3D.prototype.drawStrandNucleicAcid = function (atomlist, num, div, fill, nucleicAcidWidth, thickness, bHighlight) {
    if (bHighlight === 2) {
        num = undefined;
        thickness = undefined;
    }

    nucleicAcidWidth = nucleicAcidWidth || this.nucleicAcidWidth;
    div = div || this.axisDIV;
    num = num || this.nucleicAcidStrandDIV;
    var i, j, k;
    var pnts = []; for (k = 0; k < num; k++) pnts[k] = [];
    var colors = [];
    var currentChain, currentResi, currentO3;
    var prevOO = null;

    for (i in atomlist) {
        var atom = atomlist[i];
        if (atom === undefined) continue;

        if ((atom.name === 'O3\'' || atom.name === 'OP2' || atom.name === 'O3*' || atom.name === 'O2P') && !atom.het) {
            if (atom.name === 'O3\'' || atom.name === 'O3*') { // to connect 3' end. FIXME: better way to do?
                if (currentChain !== atom.chain || currentResi + 1 !== atom.resi) {
                    //                if (currentChain !== atom.chain) {
                    if (currentO3 && prevOO) {
                        for (j = 0; j < num; j++) {
                            var delta = -1 + 2 / (num - 1) * j;
                            pnts[j].push(new THREE.Vector3(currentO3.x + prevOO.x * delta,
                                currentO3.y + prevOO.y * delta, currentO3.z + prevOO.z * delta));
                        }
                    }
                    if (fill) this.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight);
                    for (j = 0; !thickness && j < num; j++)
                        this.createCurveSub(pnts[j], 1, colors, div, bHighlight);
                    var pnts = []; for (k = 0; k < num; k++) pnts[k] = [];
                    colors = [];
                    prevOO = null;
                }
                currentO3 = new THREE.Vector3(atom.coord.x, atom.coord.y, atom.coord.z);
                currentChain = atom.chain;
                currentResi = atom.resi;
                if (bHighlight === 1 || bHighlight === 2) {
                    colors.push(this.hColor);
                }
                else {
                    colors.push(atom.color);
                }

            }
            else if (atom.name === 'OP2' || atom.name === 'O2P') {
                if (!currentO3) { prevOO = null; continue; } // for 5' phosphate (e.g. 3QX3)
                var O = new THREE.Vector3(atom.coord.x, atom.coord.y, atom.coord.z);
                O.sub(currentO3);
                O.normalize().multiplyScalar(nucleicAcidWidth);  // TODO: refactor
                //if (prevOO !== undefined && O.dot(prevOO) < 0) {
                if (prevOO !== null && O.dot(prevOO) < 0) {
                    O.negate();
                }
                prevOO = O;
                for (j = 0; j < num; j++) {
                    var delta = -1 + 2 / (num - 1) * j;
                    pnts[j].push(new THREE.Vector3(currentO3.x + prevOO.x * delta,
                        currentO3.y + prevOO.y * delta, currentO3.z + prevOO.z * delta));
                }
                currentO3 = null;
            }
        }
    }

    if (currentO3 && prevOO) {
        for (j = 0; j < num; j++) {
            var delta = -1 + 2 / (num - 1) * j;
            pnts[j].push(new THREE.Vector3(currentO3.x + prevOO.x * delta,
                currentO3.y + prevOO.y * delta, currentO3.z + prevOO.z * delta));
        }
    }
    if (fill) this.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight);
    for (j = 0; !thickness && j < num; j++)
        this.createCurveSub(pnts[j], 1, colors, div, bHighlight);
};

iCn3D.prototype.createSingleLine = function (src, dst, colorHex, dashed, dashSize) {
    var geom = new THREE.Geometry();
    var mat;

    if (dashed) {
        mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: dashSize, gapSize: 0.5 * dashSize });
    } else {
        mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
    }

    geom.vertices.push(src);
    geom.vertices.push(dst);
    if (dashed) geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

    var axis = new THREE.Line(geom, mat, THREE.LinePieces);

    return axis;
};

// used for highlight
iCn3D.prototype.createBox = function (atom, defaultRadius, forceDefault, scale, color, bHighlight) {
    var mesh;

    if (defaultRadius === undefined) defaultRadius = 0.8;
    if (forceDefault === undefined) forceDefault = false;
    if (scale === undefined) scale = 0.8;

    if (bHighlight) {
        if (color === undefined) color = this.hColor;

        mesh = new THREE.Mesh(this.boxGeometry, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));
    }
    else {
        if (color === undefined) color = atom.color;

        mesh = new THREE.Mesh(this.boxGeometry, new THREE.MeshPhongMaterial({ overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));
    }

    mesh.scale.x = mesh.scale.y = mesh.scale.z = forceDefault ? defaultRadius : (this.vdwRadii[atom.elem] || defaultRadius) * (scale ? scale : 1);
    mesh.position.copy(atom.coord);
    this.mdl.add(mesh);

    if (bHighlight) {
        this.prevHighlightObjects.push(mesh);
    }
    else {
        this.objects.push(mesh);
    }
};

// modified from 3Dmol (http://3dmol.csb.pitt.edu/)
// new: http://stackoverflow.com/questions/23514274/three-js-2d-text-sprite-labels
// old: http://stemkoski.github.io/Three.js/Sprite-Text-Labels.html
iCn3D.prototype.makeTextSprite = function (message, parameters) {

    if (parameters === undefined) parameters = {};
    var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
    var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;

    var a = parameters.hasOwnProperty("alpha") ? parameters["alpha"] : 1.0;

    var bBkgd = true;
    var bSchematic = false;
    if (parameters.hasOwnProperty("bSchematic") && parameters["bSchematic"]) {
        bSchematic = true;

        fontsize = 40;
    }

    var backgroundColor, borderColor, borderThickness;
    if (parameters.hasOwnProperty("backgroundColor") && parameters["backgroundColor"] !== undefined) {
        backgroundColor = this.hexToRgb(parameters["backgroundColor"], a);

        borderColor = parameters.hasOwnProperty("borderColor") ? this.hexToRgb(parameters["borderColor"], a) : { r: 0, g: 0, b: 0, a: 1.0 };
        borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
    }
    else {
        bBkgd = false;
        backgroundColor = undefined;
        borderColor = undefined;
        borderThickness = 0;
    }

    var textAlpha = 1.0;
    var textColor = parameters.hasOwnProperty("textColor") && parameters["textColor"] !== undefined ? this.hexToRgb(parameters["textColor"], textAlpha) : { r: 255, g: 255, b: 0, a: 1.0 };

    var canvas = document.createElement('canvas');

    var context = canvas.getContext('2d');

    context.font = "Bold " + fontsize + "px " + fontface;

    var metrics = context.measureText(message);

    var textWidth = metrics.width;

    var width = textWidth + 2 * borderThickness;
    var height = fontsize + 2 * borderThickness;

    if (bSchematic) {
        if (width > height) {
            height = width;
        }
        else {
            width = height;
        }
    }

    //var factor = (bSchematic) ? 3 * this.oriMaxD / 100 : 3 * this.oriMaxD / 100;
    var factor = (bSchematic) ? 3 * this.maxD / 100 : 3 * this.maxD / 100;

    var expandWidthFactor = 0.8 * textWidth / height;

    /*
        // define width and height will make long text be squashed, but make the label to appear at the exact location
        if(bSchematic || message.length <= textLengthThreshold) {
            canvas.width = width;
            canvas.height = height;
    
            factor = 3 * this.oriMaxD / 100;
        }
    */

    canvas.width = width;
    canvas.height = height;

    context.clearRect(0, 0, width, height);

    //var radius = context.measureText( "M" ).width;

    if (bBkgd) {
        // background color
        context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
        // border color
        context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

        context.lineWidth = borderThickness;

        if (bSchematic) {
            var r = width * 0.35;
            this.circle(context, 0, 0, width, height, r);
        }
        else {
            //var r = (message.length <= textLengthThreshold) ? height * 0.5 : 0;
            //var r = height * 0.8;
            var r = 0;
            this.roundRect(context, 0, 0, width, height, r);
        }
    }

    // need to redefine again
    context.font = "Bold " + fontsize + "px " + fontface;

    context.textAlign = "center";
    context.textBaseline = "middle";

    context.fillStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", 1.0)";
    context.strokeStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", 1.0)";

    context.fillText(message, width * 0.5, height * 0.5);

    // canvas contents will be used for a texture
    var texture = new THREE.Texture(canvas)
    texture.needsUpdate = true;

    var frontOfTarget = true;
    //var spriteMaterial = new THREE.SpriteMaterial( { map: texture, useScreenCoordinates: false } );
    var spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        //useScreenCoordinates: false,
        depthTest: !frontOfTarget,
        depthWrite: !frontOfTarget
    });

    //https://stackoverflow.com/questions/29421702/threejs-texture
    spriteMaterial.map.minFilter = THREE.LinearFilter;

    var sprite = new THREE.Sprite(spriteMaterial);

    if (bSchematic) {
        sprite.scale.set(factor, factor, 1.0);
    }
    else {
        sprite.scale.set(expandWidthFactor * factor, factor, 1.0);
    }

    return sprite;
};

// function for drawing rounded rectangles
iCn3D.prototype.roundRect = function (ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
};

iCn3D.prototype.circle = function (ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.arc(x + w / 2, y + h / 2, r, 0, 2 * Math.PI, true);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createLabelRepresentation = function (labels) {
    var tmpMaxD = this.maxD;

    for (var name in labels) {
        var labelArray = (labels[name] !== undefined) ? labels[name] : [];

        for (var i = 0, il = labelArray.length; i < il; ++i) {
            var label = labelArray[i];
            // make sure fontsize is a number

            if (label.size == 0) label.size = undefined;
            if (label.color == 0) label.color = undefined;
            if (label.background == 0) label.background = undefined;

            var labelsize = (label.size !== undefined) ? label.size : this.LABELSIZE;
            var labelcolor = (label.color !== undefined) ? label.color : '#ffff00';
            var labelbackground = (label.background !== undefined) ? label.background : '#cccccc';
            var labelalpha = (label.alpha !== undefined) ? label.alpha : 1.0;
            // if label.background is undefined, no background will be drawn
            labelbackground = label.background;

            if (labelcolor !== undefined && labelbackground !== undefined && labelcolor.toLowerCase() === labelbackground.toLowerCase()) {
                labelcolor = "#888888";
            }

            var bChemicalInProteinOrTrace = false;
            var bStick = false;
            if (Object.keys(this.proteins).length + Object.keys(this.nucleotides).length > 0) {
                var firstAtom = this.getFirstAtomObj(this.hAtoms);
                if (firstAtom !== undefined) {
                    if (this.chemicals.hasOwnProperty(firstAtom.serial)
                        || firstAtom.style == 'c alpha trace' || firstAtom.style == 'o3 trace'
                        //|| firstAtom.style == 'schematic'
                    ) {
                        bChemicalInProteinOrTrace = true;
                    }

                    if (firstAtom.style == 'stick' || firstAtom.style == 'ball and stick') {
                        bStick = true;
                    }
                }
            }

            // somehow the transformation is not stable when reset camera
            /*
                        if(bChemicalInProteinOrTrace) {
                            this.maxD = 15; // 50
                            this.setCamera();
                        }
                        else if(bStick) {
                            this.maxD = 30; // 50
                            this.setCamera();
                        }
                        else {
                            if(Object.keys(this.proteins).length + Object.keys(this.nucleotides).length > 0) {
                                this.maxD = 100;
                                this.setCamera();
                            }
                            else {
                                this.maxD = 15;
                                this.setCamera();
                            }
                        }
            */

            var bb;
            if (label.bSchematic !== undefined && label.bSchematic) {

                bb = this.makeTextSprite(label.text, { fontsize: parseInt(labelsize), textColor: labelcolor, borderColor: labelbackground, backgroundColor: labelbackground, alpha: labelalpha, bSchematic: 1 });
            }
            else {
                if (label.text.length === 1) {
                    bb = this.makeTextSprite(label.text, { fontsize: parseInt(labelsize), textColor: labelcolor, borderColor: labelbackground, backgroundColor: labelbackground, alpha: labelalpha, bSchematic: 1 });
                }
                else {
                    bb = this.makeTextSprite(label.text, { fontsize: parseInt(labelsize), textColor: labelcolor, borderColor: labelbackground, backgroundColor: labelbackground, alpha: labelalpha, bSchematic: 0 });
                }
            }

            bb.position.set(label.position.x, label.position.y, label.position.z);
            this.mdl.add(bb);
            // do not add labels to objects for pk
        }
    }

    // somehow the transformation is not stable when reset camera
    //    this.maxD = tmpMaxD;
    //    this.setCamera();
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.setAtmClr = function (atoms, hex) {
    for (var i in atoms) {
        var atom = this.atoms[i];
        atom.color = new THREE.Color().setHex(hex);

        this.atomPrevColors[i] = atom.color;
    }
};

iCn3D.prototype.updateChainsColor = function (atom) {
    var chainid = atom.structure + '_' + atom.chain;
    if (this.chainsColor[chainid] !== undefined) {  // for mmdbid and align input
        this.chainsColor[chainid] = atom.color;
    }
};

iCn3D.prototype.setColorByOptions = function (options, atoms, bUseInputColor) {
    if (options !== undefined) {
        if (bUseInputColor !== undefined && bUseInputColor) {
            for (var i in atoms) {
                var atom = this.atoms[i];

                this.atomPrevColors[i] = atom.color;
            }
        }
        else if (options.color.indexOf("#") === 0) {
            for (var i in atoms) {
                var atom = this.atoms[i];
                atom.color = new THREE.Color().setStyle(options.color.toLowerCase());

                this.atomPrevColors[i] = atom.color;
            }
        }
        else {
            switch (options.color.toLowerCase()) {
                case 'spectrum':
                    var idx = 0;
                    //var lastTerSerialInv = 1 / this.lastTerSerial;
                    var lastTerSerialInv = 1 / this.cnt;
                    for (var i in atoms) {
                        var atom = this.atoms[i];
                        atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : new THREE.Color().setHSL(2 / 3 * (1 - idx++ * lastTerSerialInv), 1, 0.45);
                        //atom.color = this.atomColors[atom.elem] || this.defaultAtomColor;

                        this.atomPrevColors[i] = atom.color;
                    }
                    break;
                case 'chain':
                    if (this.chainsColor !== undefined && Object.keys(this.chainsColor).length > 0) { // mmdb input
                        this.applyOriginalColor(this.hash2Atoms(this.hAtoms));

                        // atom color
                        var atomHash = this.unionHash(this.chemicals, this.ions);

                        for (var i in atomHash) {
                            var atom = this.atoms[i];
                            atom.color = this.atomColors[atom.elem] || this.defaultAtomColor;

                            this.atomPrevColors[i] = atom.color;
                        }
                    }
                    else {
                        var index = -1, prevChain = '', colorLength = this.stdChainColors.length;
                        for (var i in atoms) {
                            var atom = this.atoms[i];

                            if (atom.chain != prevChain) {
                                ++index;

                                index = index % colorLength;
                            }

                            atom.color = this.stdChainColors[index];

                            if (Object.keys(this.chainsColor).length > 0) this.updateChainsColor(atom);
                            this.atomPrevColors[i] = atom.color;

                            prevChain = atom.chain;
                        }
                    }
                    break;
                case 'secondary structure':
                    for (var i in atoms) {
                        var atom = this.atoms[i];
                        // secondary color of nucleotide: blue (new THREE.Color(0x0000FF))
                        atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : this.ssColors[atom.ss] || new THREE.Color(0x0000FF);

                        this.atomPrevColors[i] = atom.color;
                    }

                    break;

                case 'residue':
                    for (var i in atoms) {
                        var atom = this.atoms[i];
                        atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : this.residueColors[atom.resn] || this.defaultResidueColor;

                        this.atomPrevColors[i] = atom.color;
                    }
                    break;
                case 'charge':
                    for (var i in atoms) {
                        var atom = this.atoms[i];

                        //atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : this.chargeColors[atom.resn] || this.defaultResidueColor;
                        atom.color = atom.het ? this.defaultAtomColor : this.chargeColors[atom.resn] || this.defaultResidueColor;

                        this.atomPrevColors[i] = atom.color;
                    }
                    break;
                case 'hydrophobic':
                    for (var i in atoms) {
                        var atom = this.atoms[i];

                        //atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : this.chargeColors[atom.resn] || this.defaultResidueColor;
                        atom.color = atom.het ? this.defaultAtomColor : this.hydrophobicColors[atom.resn] || this.defaultResidueColor;

                        this.atomPrevColors[i] = atom.color;
                    }
                    break;
                case 'atom':
                    for (var i in atoms) {
                        var atom = this.atoms[i];
                        atom.color = this.atomColors[atom.elem] || this.defaultAtomColor;

                        this.atomPrevColors[i] = atom.color;
                    }
                    break;

                case 'conserved':
                    for (var i in atoms) {
                        var atom = this.atoms[i];
                        atom.color = this.defaultAtomColor;

                        this.atomPrevColors[i] = atom.color;
                    }

                    for (var chainid in this.alnChainsSeq) {
                        var resObjectArray = this.alnChainsSeq[chainid];

                        for (var i = 0, il = resObjectArray.length; i < il; ++i) {
                            var residueid = chainid + '_' + resObjectArray[i].resi;

                            for (var j in this.residues[residueid]) {
                                if (atoms.hasOwnProperty(j)) {
                                    var color = new THREE.Color(resObjectArray[i].color);
                                    this.atoms[j].color = color;
                                    this.atomPrevColors[j] = color;
                                }
                            }
                        }
                    }
                    break;

                case 'white':
                    this.setAtmClr(atoms, 0xFFFFFF);
                    break;

                case 'grey':
                    this.setAtmClr(atoms, 0x888888);
                    break;

                case 'red':
                    this.setAtmClr(atoms, 0xFF0000);
                    break;
                case 'green':
                    this.setAtmClr(atoms, 0x00FF00);
                    break;
                case 'blue':
                    this.setAtmClr(atoms, 0x0000FF);
                    break;
                case 'magenta':
                    this.setAtmClr(atoms, 0xFF00FF);
                    break;
                case 'yellow':
                    this.setAtmClr(atoms, 0xFFFF00);
                    break;
                case 'cyan':
                    this.setAtmClr(atoms, 0x00FFFF);
                    break;
                case 'custom':
                    // do the coloring separately
                    break;

                default: // the "#" was missed in order to make sharelink work
                    for (var i in atoms) {
                        var atom = this.atoms[i];
                        atom.color = new THREE.Color().setStyle("#" + options.color.toLowerCase());

                        this.atomPrevColors[i] = atom.color;
                    }

                    break;
            }
        }
    }
};

iCn3D.prototype.applyDisplayOptions = function (options, atoms, bHighlight) {
    var me = this; // atoms: hash of key -> 1
    if (options === undefined) options = this.opts;

    var residueHash = {};
    var singletonResidueHash = {};
    var atomsObj = {};
    var residueid;

    if (bHighlight === 1 && Object.keys(atoms).length < Object.keys(this.atoms).length) {
        atomsObj = this.hash2Atoms(atoms);

        for (var i in atomsObj) {
            var atom = atomsObj[i];

            residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
            residueHash[residueid] = 1;
        }

        // find singleton residues
        for (var i in residueHash) {
            var last = i.lastIndexOf('_');
            var base = i.substr(0, last + 1);
            var lastResi = parseInt(i.substr(last + 1));

            var prevResidueid = base + (lastResi - 1).toString();
            var nextResidueid = base + (lastResi + 1).toString();

            if (!residueHash.hasOwnProperty(prevResidueid) && !residueHash.hasOwnProperty(prevResidueid)) {
                singletonResidueHash[i] = 1;
            }
        }

        // show the only atom in a transparent box
        if (Object.keys(atomsObj).length === 1 && Object.keys(this.residues[residueid]).length > 1
            && atomsObj[Object.keys(atomsObj)[0]].style !== 'sphere' && atomsObj[Object.keys(atomsObj)[0]].style !== 'dot') {
            if (this.bCid === undefined || !this.bCid) {
                for (var i in atomsObj) {
                    var atom = atomsObj[i];
                    var scale = 1.0;
                    this.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
                }
            }
        }
        else {
            // if only one residue, add the next residue in order to show highlight
            for (var residueid in singletonResidueHash) {
                var atom = this.getFirstAtomObj(this.residues[residueid]);
                var prevResidueid = atom.structure + '_' + atom.chain + '_' + parseInt(atom.resi - 1);
                var nextResidueid = atom.structure + '_' + atom.chain + '_' + parseInt(atom.resi + 1);

                //ribbon, strand, cylinder and plate, nucleotide cartoon, o3 trace, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, dot

                if (atom.style === 'cylinder and plate' && atom.ss === 'helix') { // no way to highlight part of cylinder
                    for (var i in this.residues[residueid]) {
                        var atom = this.atoms[i];
                        var scale = 1.0;
                        this.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
                    }
                }
                else if ((atom.style === 'ribbon' && atom.ss === 'coil') || (atom.style === 'strand' && atom.ss === 'coil') || atom.style === 'o3 trace' || atom.style === 'schematic' || atom.style === 'c alpha trace' || atom.style === 'b factor tube' || (atom.style === 'cylinder and plate' && atom.ss !== 'helix')) {
                    var bAddResidue = false;
                    // add the next residue with same style
                    if (!bAddResidue && this.residues.hasOwnProperty(nextResidueid)) {
                        var index2 = Object.keys(this.residues[nextResidueid])[0];
                        var atom2 = this.hash2Atoms(this.residues[nextResidueid])[index2];
                        if ((atom.style === atom2.style && !atom2.ssbegin) || atom2.ssbegin) {
                            var residueAtoms = this.residues[nextResidueid];
                            atoms = this.unionHash(atoms, residueAtoms);

                            bAddResidue = true;

                            // record the highlight style for the artificial residue
                            if (atom2.ssbegin) {
                                for (var i in residueAtoms) {
                                    this.atoms[i].notshow = true;
                                }
                            }
                        }
                    }

                    // add the previous residue with same style
                    if (!bAddResidue && this.residues.hasOwnProperty(prevResidueid)) {
                        var index2 = Object.keys(this.residues[prevResidueid])[0];
                        var atom2 = this.hash2Atoms(this.residues[prevResidueid])[index2];
                        if (atom.style === atom2.style) {
                            atoms = this.unionHash(atoms, this.residues[prevResidueid]);

                            bAddResidue = true;
                        }
                    }
                }
                else if ((atom.style === 'ribbon' && atom.ss !== 'coil' && atom.ssend) || (atom.style === 'strand' && atom.ss !== 'coil' && atom.ssend)) {
                    var bAddResidue = false;
                    // add the next residue with same style
                    if (!bAddResidue && this.residues.hasOwnProperty(nextResidueid)) {
                        var index2 = Object.keys(this.residues[nextResidueid])[0];
                        var atom2 = this.hash2Atoms(this.residues[nextResidueid])[index2];
                        //if(atom.style === atom2.style && !atom2.ssbegin) {
                        atoms = this.unionHash(atoms, this.residues[nextResidueid]);

                        bAddResidue = true;
                        //}
                    }
                }
            } // end for
        } // end else {

        atomsObj = {};
    } // end if(bHighlight === 1)

    this.setStyle2Atoms(atoms);

    //this.bAllAtoms = (Object.keys(atoms).length === Object.keys(this.atoms).length);
    this.bAllAtoms = false;
    if (atoms && atoms !== undefined) {
        this.bAllAtoms = (Object.keys(atoms).length === Object.keys(this.atoms).length);
    }

    //        var currentCalphas = {};
    //        if(this.opts['sidec'] !== 'nothing') {
    //            currentCalphas = this.intHash(this.hAtoms, this.calphas);
    //        }

    var chemicalSchematicRadius = this.cylinderRadius * 0.5;

    // remove schematic labels
    //if(this.labels !== undefined) this.labels['schematic'] = undefined;
    if (this.labels !== undefined) delete this.labels['schematic'];

    for (var style in this.style2atoms) {
        // 14 styles: ribbon, strand, cylinder and plate, nucleotide cartoon, o3 trace, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, dot, nothing
        var atomHash = this.style2atoms[style];
        var bPhosphorusOnly = this.isCalphaPhosOnly(this.hash2Atoms(atomHash), "O3'", "O3*");

        if (style === 'ribbon') {
            this.createStrand(this.hash2Atoms(atomHash), 2, undefined, true, undefined, undefined, false, this.ribbonthickness, bHighlight);
        }
        else if (style === 'strand') {
            this.createStrand(this.hash2Atoms(atomHash), null, null, null, null, null, false, undefined, bHighlight);
        }
        else if (style === 'cylinder and plate') {
            this.createCylinderHelix(this.hash2Atoms(atomHash), this.cylinderHelixRadius, bHighlight);
        }
        else if (style === 'nucleotide cartoon') {
            if (bPhosphorusOnly) {
                this.createCylinderCurve(this.hash2Atoms(atomHash), ["P"], this.traceRadius, false, bHighlight);
            }
            else {
                this.drawCartoonNucleicAcid(this.hash2Atoms(atomHash), null, this.ribbonthickness, bHighlight);

                if (bHighlight !== 2) this.drawNucleicAcidStick(this.hash2Atoms(atomHash), bHighlight);
            }
        }
        else if (style === 'o3 trace') {
            if (bPhosphorusOnly) {
                this.createCylinderCurve(this.hash2Atoms(atomHash), ["P"], this.traceRadius, false, bHighlight);
            }
            else {
                this.createCylinderCurve(this.hash2Atoms(atomHash), ["O3'", "O3*"], this.traceRadius, false, bHighlight);
            }
        }
        //else if(style === 'phosphorus lines') {
        //  this.createCylinderCurve(this.hash2Atoms(atomHash), ["O3'", "O3*"], 0.2, true, bHighlight);
        //}
        else if (style === 'schematic') {
            // either proteins, nucleotides, or chemicals
            var firstAtom = this.getFirstAtomObj(atomHash);

            //if(firstAtom.het) { // chemicals
            if (this.chemicals.hasOwnProperty(firstAtom.serial)) { // chemicals
                this.addNonCarbonAtomLabels(this.hash2Atoms(atomHash));

                bSchematic = true;
                this.createStickRepresentation(this.hash2Atoms(atomHash), chemicalSchematicRadius, chemicalSchematicRadius, undefined, bHighlight, bSchematic);
            }
            else { // nucleotides or proteins
                this.addResiudeLabels(this.hash2Atoms(atomHash), true);

                if (bPhosphorusOnly) {
                    this.createCylinderCurve(this.hash2Atoms(atomHash), ["P"], this.traceRadius, false, bHighlight);
                }
                else {
                    this.createCylinderCurve(this.hash2Atoms(atomHash), ["O3'", "O3*"], this.traceRadius, false, bHighlight);
                }
                this.createCylinderCurve(this.hash2Atoms(atomHash), ['CA'], this.traceRadius, false, bHighlight);
            }
        }
        else if (style === 'c alpha trace') {
            this.createCylinderCurve(this.hash2Atoms(atomHash), ['CA'], this.traceRadius, false, bHighlight);
        }
        else if (style === 'b factor tube') {
            this.createTube(this.hash2Atoms(atomHash), 'CA', null, bHighlight);
        }
        else if (style === 'lines') {
            if (bHighlight === 1) {
                this.createStickRepresentation(this.hash2Atoms(atomHash), this.hlLineRadius, this.hlLineRadius, undefined, bHighlight);
            }
            else {
                this.createLineRepresentation(this.hash2Atoms(atomHash), bHighlight);
            }
        }
        else if (style === 'stick') {
            this.createStickRepresentation(this.hash2Atoms(atomHash), this.cylinderRadius, this.cylinderRadius, undefined, bHighlight);
        }
        else if (style === 'ball and stick') {
            this.createStickRepresentation(this.hash2Atoms(atomHash), this.cylinderRadius, this.cylinderRadius * 0.5, this.dotSphereScale, bHighlight);
        }
        else if (style === 'sphere') {
            this.createSphereRepresentation(this.hash2Atoms(atomHash), this.sphereRadius, undefined, undefined, bHighlight);
        }
        else if (style === 'dot') {
            this.createSphereRepresentation(this.hash2Atoms(atomHash), this.sphereRadius, false, this.dotSphereScale, bHighlight);
        }
    } // end for loop

    // hide the previous labels
    if (this.labels !== undefined && Object.keys(this.labels).length > 0) {
        this.hideLabels();

        // labels
        this.createLabelRepresentation(this.labels);
    }
};

iCn3D.prototype.hideLabels = function () {
    var me = this;
    // remove previous labels
    if (this.mdl !== undefined) {
        for (var i = 0, il = this.mdl.children.length; i < il; ++i) {
            var mesh = this.mdl.children[i];
            if (mesh !== undefined && mesh.type === 'Sprite') {
                this.mdl.remove(mesh); // somehow didn't work
            }
        }
    }
};

iCn3D.prototype.setStyle2Atoms = function (atoms) {
    this.style2atoms = {};

    for (var i in atoms) {
        if (this.style2atoms[this.atoms[i].style] === undefined) this.style2atoms[this.atoms[i].style] = {};

        this.style2atoms[this.atoms[i].style][i] = 1;

        // side chains
        if (this.atoms[i].style2 !== undefined && this.atoms[i].style2 !== 'nothing') {
            if (this.style2atoms[this.atoms[i].style2] === undefined) this.style2atoms[this.atoms[i].style2] = {};

            this.style2atoms[this.atoms[i].style2][i] = 1;
        }
    }

    /*
          for(var i in this.atoms) {
              if(atoms.hasOwnProperty(i)) {
                if(this.style2atoms[this.atoms[i].style] === undefined) this.style2atoms[this.atoms[i].style] = {};
    
                this.style2atoms[this.atoms[i].style][i] = 1;
    
                // side chains
                if(this.style2atoms[this.atoms[i].style2] === undefined) this.style2atoms[this.atoms[i].style2] = {};
    
                this.style2atoms[this.atoms[i].style2][i] = 1;
              }
              else if(this.atoms[i].style == 'schematic') { // always display schematic
                if(this.style2atoms[this.atoms[i].style] === undefined) this.style2atoms[this.atoms[i].style] = {};
                this.style2atoms[this.atoms[i].style][i] = 1;
              }
          }
    */
};

// set atom style when loading a structure
iCn3D.prototype.setAtomStyleByOptions = function (options) {
    if (options === undefined) options = this.opts;

    var selectedAtoms;

    if (options.proteins !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.proteins);
        for (var i in selectedAtoms) {
            this.atoms[i].style = options.proteins.toLowerCase();
        }
    }

    // side chain use style2
    if (options.sidec !== undefined && options.sidec !== 'nothing') {
        selectedAtoms = this.intHash(this.hAtoms, this.sidec);
        //var sidec_calpha = this.unionHash(this.calphas, this.sidec);
        //selectedAtoms = this.intHash(this.hAtoms, sidec_calpha);

        for (var i in selectedAtoms) {
            this.atoms[i].style2 = options.sidec.toLowerCase();
        }
    }

    if (options.chemicals !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.chemicals);
        for (var i in selectedAtoms) {
            this.atoms[i].style = options.chemicals.toLowerCase();
        }
    }

    if (options.ions !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.ions);
        for (var i in selectedAtoms) {
            this.atoms[i].style = options.ions.toLowerCase();
        }
    }

    if (options.water !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.water);
        for (var i in selectedAtoms) {
            this.atoms[i].style = options.water.toLowerCase();
        }
    }

    if (options.nucleotides !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.nucleotides);
        for (var i in selectedAtoms) {
            this.atoms[i].style = options.nucleotides.toLowerCase();
        }
    }
};

iCn3D.prototype.rebuildSceneBase = function (options) {
    var me = this;
    jQuery.extend(me.opts, options);

    this.cam_z = this.maxD * 2;
    //this.cam_z = -this.maxD * 2;


    if (this.scene !== undefined) {
        for (var i = this.scene.children.length - 1; i >= 0; i--) {
            var obj = this.scene.children[i];
            this.scene.remove(obj);
        }
    }
    else {
        this.scene = new THREE.Scene();
    }

    if (this.scene_ghost !== undefined) {
        for (var i = this.scene_ghost.children.length - 1; i >= 0; i--) {
            var obj = this.scene_ghost.children[i];
            this.scene_ghost.remove(obj);
        }
    }
    else {
        this.scene_ghost = new THREE.Scene();
    }

    //this.directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.2);
    this.directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);

    if (this.cam_z > 0) {
        this.directionalLight.position.set(0, 0, 1);
    }
    else {
        this.directionalLight.position.set(0, 0, -1);
    }

    //var ambientLight = new THREE.AmbientLight(0x202020);
    //var ambientLight = new THREE.AmbientLight(0xdddddd, 0.2);
    var ambientLight = new THREE.AmbientLight(0x404040);

    this.scene.add(this.directionalLight);
    this.scene.add(ambientLight);

    //this.group = new THREE.Object3D();  // regular display

    this.mdl = new THREE.Object3D();  // regular display
    //this.mdlPicking = new THREE.Object3D();  // pk display
    this.mdlImpostor = new THREE.Object3D();  // Impostor display

    //this.scene.add(this.mdlPicking);
    this.scene.add(this.mdl);
    this.scene.add(this.mdlImpostor);

    // highlight on impostors
    this.mdl_ghost = new THREE.Object3D();  // Impostor display
    this.scene_ghost.add(this.mdl_ghost);

    //this.scene_ghost.add(this.directionalLight);
    //this.scene_ghost.add(ambientLight);

    // related to pk
    this.objects = []; // define objects for pk, not all elements are used for pk
    this.objects_ghost = []; // define objects for pk, not all elements are used for pk
    this.raycaster = new THREE.Raycaster();
    this.projector = new THREE.Projector();
    this.mouse = new THREE.Vector2();

    var background = this.backgroundColors[this.opts.background.toLowerCase()];

    if (this.opts.background.toLowerCase() === 'transparent') {
        this.renderer.setClearColor(background, 0);
    }
    else {
        this.renderer.setClearColor(background, 1);
    }

    this.perspectiveCamera = new THREE.PerspectiveCamera(20, this.container.whratio, 0.1, 10000);
    this.perspectiveCamera.position.set(0, 0, this.cam_z);
    this.perspectiveCamera.lookAt(new THREE.Vector3(0, 0, 0));

    this.orthographicCamera = new THREE.OrthographicCamera();
    this.orthographicCamera.position.set(0, 0, this.cam_z);
    this.orthographicCamera.lookAt(new THREE.Vector3(0, 0, 0));

    this.cams = {
        perspective: this.perspectiveCamera,
        orthographic: this.orthographicCamera,
    };
};

iCn3D.prototype.setCamera = function () {
    this.cam = this.cams[this.opts.camera.toLowerCase()];

    if (this.cam === this.perspectiveCamera) {
        if (this.cam_z > 0) {
            this.cam.position.z = this.maxD * 2; // forperspective, the z positionshould be large enough to see the whole molecule
        }
        else {
            this.cam.position.z = -this.maxD * 2; // forperspective, the z positionshould be large enough to see the whole molecule
        }

        if (this.opts['slab'] === 'yes') {
            this.cam.near = this.maxD * 2;
        }
        else {
            this.cam.near = 0.1;
        }
        this.cam.far = 10000;

        this.controls = new THREE.TrackballControls(this.cam, document.getElementById(this.id), this);
    }
    else if (this.cam === this.orthographicCamera) {
        this.cam.right = this.maxD / 2 * 2.5;
        this.cam.left = -this.cam.right;
        this.cam.top = this.cam.right / this.container.whratio;
        this.cam.bottom = -this.cam.right / this.container.whratio;

        if (this.opts['slab'] === 'yes') {
            this.cam.near = this.maxD * 2;
        }
        else {
            this.cam.near = 0;
        }

        this.cam.far = 10000;

        this.controls = new THREE.OrthographicTrackballControls(this.cam, document.getElementById(this.id), this);
    }

    this.cam.updateProjectionMatrix();
};

iCn3D.prototype.render = function () {
    this.directionalLight.position.copy(this.cam.position);

    this.renderer.gammaInput = true
    this.renderer.gammaOutput = true

    this.renderer.setPixelRatio(window.devicePixelRatio); // r71
    this.renderer.render(this.scene, this.cam);
    //this.renderer.render(this.scene_ghost, this.cam);
};

iCn3D.prototype.clearImpostors = function () {
    this.posArray = [];
    this.colorArray = [];
    this.pos2Array = [];
    this.color2Array = [];
    this.radiusArray = [];

    this.posArraySphere = [];
    this.colorArraySphere = [];
    this.radiusArraySphere = [];
};

iCn3D.prototype.applyTransformation = function (_zoomFactor, mouseChange, quaternion) {
    var para = {};
    para.update = false;

    // zoom
    para._zoomFactor = _zoomFactor;

    // translate
    para.mouseChange = new THREE.Vector2();
    para.mouseChange.copy(mouseChange);

    // rotation
    para.quaternion = new THREE.Quaternion();
    para.quaternion.copy(quaternion);

    this.controls.update(para);
};

iCn3D.prototype.applyCenterOptions = function (options) {
    if (options === undefined) options = this.opts;

    switch (options.rotationcenter.toLowerCase()) {
        case 'molecule center':
            // move the molecule to the origin
            if (this.center !== undefined) {
                this.setRotationCenter(this.center);
            }
            break;
        case 'pick center':
            if (this.pAtom !== undefined) {
                this.setRotationCenter(this.pAtom.coord);
            }
            break;
        case 'display center':
            var center = this.centerAtoms(this.dAtoms).center;
            this.setRotationCenter(center);
            break;
        case 'highlight center':
            var center = this.centerAtoms(this.hAtoms).center;
            this.setRotationCenter(center);
            break;
    }
};

iCn3D.prototype.setRotationCenter = function (coord) {
    this.mdl.position.set(0, 0, 0);
    this.mdlImpostor.position.set(0, 0, 0);
    this.mdl_ghost.position.set(0, 0, 0);

    //this.mdlPicking.position.sub(coord);
    this.mdl.position.sub(coord);
    this.mdlImpostor.position.sub(coord);
    this.mdl_ghost.position.sub(coord);
};

iCn3D.prototype.applyOriginalColor = function (atoms) {
    if (atoms === undefined) atoms = this.atoms;

    for (var i in atoms) {
        var atom = atoms[i];
        var chainid = atom.structure + '_' + atom.chain;

        if (this.chainsColor.hasOwnProperty(chainid)) {
            atom.color = this.chainsColor[chainid];
        }
        else {
            //atom.color = this.atomColors[atom.elem];
            break;
        }
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.setParametersForShader = function () {
    var me = this;
    var modelViewMatrix = new THREE.Uniform(new THREE.Matrix4())
        .onUpdate(function (object) {
            this.value.copy(object.modelViewMatrix);
        });

    var modelViewMatrixInverse = new THREE.Uniform(new THREE.Matrix4())
        .onUpdate(function (object) {
            this.value.getInverse(object.modelViewMatrix);
        });

    var modelViewMatrixInverseTranspose = new THREE.Uniform(new THREE.Matrix4())
        .onUpdate(function (object) {
            this.value.getInverse(object.modelViewMatrix).transpose();
        });

    var modelViewProjectionMatrix = new THREE.Uniform(new THREE.Matrix4())
        .onUpdate(function (object) {
            this.value.multiplyMatrices(me.cam.projectionMatrix, object.modelViewMatrix);
        });

    var modelViewProjectionMatrixInverse = new THREE.Uniform(new THREE.Matrix4())
        .onUpdate(function (object) {
            var tmpMatrix = new THREE.Matrix4();
            tmpMatrix.multiplyMatrices(me.cam.projectionMatrix, object.modelViewMatrix);
            this.value.getInverse(tmpMatrix);
        });

    var projectionMatrix = new THREE.Uniform(new THREE.Matrix4())
        .onUpdate(function () {
            this.value.copy(me.cam.projectionMatrix);
        });

    var projectionMatrixInverse = new THREE.Uniform(new THREE.Matrix4())
        .onUpdate(function () {
            this.value.getInverse(me.cam.projectionMatrix);
        });

    var background = this.backgroundColors[this.opts.background.toLowerCase()];
    var near = 2 * this.maxD;
    //var far = 2.5 * this.maxD;
    var far = 3 * this.maxD;

    this.uniforms = THREE.UniformsUtils.merge([
        THREE.UniformsLib.common,
        {
            modelViewMatrix: modelViewMatrix,
            modelViewMatrixInverse: modelViewMatrixInverse,
            modelViewMatrixInverseTranspose: modelViewMatrixInverseTranspose,
            modelViewProjectionMatrix: modelViewProjectionMatrix,
            modelViewProjectionMatrixInverse: modelViewProjectionMatrixInverse,
            projectionMatrix: projectionMatrix,
            projectionMatrixInverse: projectionMatrixInverse,
            //ambientLightColor: { type: "v3", value: [0.25, 0.25, 0.25] },
            diffuse: { type: "v3", value: [1.0, 1.0, 1.0] },
            emissive: { type: "v3", value: [0.0, 0.0, 0.0] },
            roughness: { type: "f", value: 0.5 }, // 0.4
            metalness: { type: "f", value: 0.3 }, // 0.5
            opacity: { type: "f", value: 1.0 },
            nearClip: { type: "f", value: 0.1 },
            ortho: { type: "f", value: 0.0 },
            shrink: { type: "f", value: 0.13 },
            fogColor: { type: "v3", value: [background.r, background.g, background.b] },
            fogNear: { type: "f", value: near },
            fogFar: { type: "f", value: far },
            fogDensity: { type: "f", value: 2.0 }
        },
        THREE.UniformsLib.ambient,
        THREE.UniformsLib.lights
    ]);

    /*
    //fog_pars_fragment
    #ifdef USE_FOG
        uniform vec3 fogColor;
        #ifdef FOG_EXP2
            uniform float fogDensity;
        #else
            uniform float fogNear;
            uniform float fogFar;
        #endif
    #endif
    */

    this.defines = {
        USE_COLOR: 1,
        //PICKING: 1,
        NEAR_CLIP: 1,
        CAP: 1
    };

    if (this.opts['fog'] === 'yes') {
        this.defines['USE_FOG'] = 1;
        if (this.opts['camera'] === 'orthographic') {
            this.defines['FOG_EXP2'] = 1;
        }
    }

    if (this.bExtFragDepth) {
        this.defines['USE_LOGDEPTHBUF_EXT'] = 1;
    }
};

iCn3D.prototype.drawImpostorShader = function () {
    var me = this;
    this.setParametersForShader();

    this.createImpostorShaderSphere("SphereImpostor");
    this.createImpostorShaderCylinder("CylinderImpostor");
    //this.createImpostorShaderCylinder("HyperballStickImpostor");
};

iCn3D.prototype.getShader = function (name) {
    var me = this;
    var shaderText = $NGL_shaderTextHash[name];
    var reInclude = /#include\s+(\S+)/gmi;

    shaderText = shaderText.replace(reInclude, function (match, p1) {

        var chunk;
        if (THREE.ShaderChunk.hasOwnProperty(p1)) {
            chunk = THREE.ShaderChunk[p1];
        }

        return chunk ? chunk : "";

    });

    return shaderText;
};

iCn3D.prototype.createImpostorShaderBase = function (shaderName, mapping, mappingIndices, data, attributeData, count, mappingSize, mappingIndicesSize, mappingItemSize) {
    var me = this;
    var shaderMaterial =
        new THREE.ShaderMaterial({
            defines: me.defines,
            uniforms: me.uniforms,
            vertexShader: me.getShader(shaderName + ".vert"),
            fragmentShader: me.getShader(shaderName + ".frag"),
            depthTest: true,
            depthWrite: true,
            needsUpdate: true,
            lights: true
        });

    shaderMaterial.extensions.fragDepth = true;

    //MappedBuffer
    var attributeSize = count * mappingSize;

    var n = count * mappingIndicesSize;
    var TypedArray = attributeSize > 65535 ? Uint32Array : Uint16Array;
    var index = new TypedArray(n);

    //makeIndex();
    var ix, it;

    for (var v = 0; v < count; v++) {
        ix = v * mappingIndicesSize;
        it = v * mappingSize;

        index.set(mappingIndices, ix);

        for (var s = 0; s < mappingIndicesSize; ++s) {
            index[ix + s] += it;
        }
    }


    var geometry = new THREE.BufferGeometry();

    // buffer.js
    var dynamic = true;

    if (index) {
        geometry.setIndex(
            new THREE.BufferAttribute(index, 1)
        );
        geometry.getIndex().setDynamic(dynamic);
    }

    // add attributes from buffer.js
    var itemSize = {
        "f": 1, "v2": 2, "v3": 3, "c": 3
    };

    for (var name in attributeData) {

        var buf;
        var a = attributeData[name];

        buf = new Float32Array(
            attributeSize * itemSize[a.type]
        );

        geometry.addAttribute(
            name,
            new THREE.BufferAttribute(buf, itemSize[a.type])
                .setDynamic(dynamic)
        );

    }

    // set attributes from mapped-buffer.js
    var attributes = geometry.attributes;

    var a, d, itemSize2, array, i, j;

    for (var name in data) {

        d = data[name];
        a = attributes[name];
        itemSize2 = a.itemSize;
        array = a.array;

        for (var k = 0; k < count; ++k) {

            n = k * itemSize2;
            i = n * mappingSize;

            for (var l = 0; l < mappingSize; ++l) {

                j = i + (itemSize2 * l);

                for (var m = 0; m < itemSize2; ++m) {

                    array[j + m] = d[n + m];

                }

            }

        }

        a.needsUpdate = true;

    }

    // makemapping
    var aMapping = geometry.attributes.mapping.array;

    for (var v = 0; v < count; v++) {
        aMapping.set(mapping, v * mappingItemSize * mappingSize);
    }

    var mesh = new THREE.Mesh(geometry, shaderMaterial);

    // important: https://stackoverflow.com/questions/21184061/mesh-suddenly-disappears-in-three-js-clipping
    // You are moving the camera in the CPU. You are moving the vertices of the plane in the GPU
    mesh.frustumCulled = false;

    mesh.scale.x = mesh.scale.y = mesh.scale.z = 1.0;

    this.mdlImpostor.add(mesh);

    //this.objects.push(mesh);
};

iCn3D.prototype.createImpostorShaderCylinder = function (shaderName) {
    var me = this;
    var positions = new Float32Array(me.posArray);
    var colors = new Float32Array(me.colorArray);
    var positions2 = new Float32Array(me.pos2Array);
    var colors2 = new Float32Array(me.color2Array);
    var radii = new Float32Array(me.radiusArray);

    // cylinder
    var mapping = new Float32Array([
        -1.0, 1.0, -1.0,
        -1.0, -1.0, -1.0,
        1.0, 1.0, -1.0,
        1.0, 1.0, 1.0,
        1.0, -1.0, -1.0,
        1.0, -1.0, 1.0
    ]);

    var mappingIndices = new Uint16Array([
        0, 1, 2,
        1, 4, 2,
        2, 4, 3,
        4, 5, 3
    ]);

    var mappingIndicesSize = 12;
    var mappingType = "v3";
    var mappingSize = 6;
    var mappingItemSize = 3;


    var count = positions.length / 3;

    var data = {
        "position1": positions,
        "color": colors,
        "position2": positions2,
        "color2": colors2,
        "radius": radii
    };

    var attributeData = {
        "position1": { type: "v3", value: null },
        "color": { type: "v3", value: null },
        "position2": { type: "v3", value: null },
        "color2": { type: "v3", value: null },
        "radius": { type: "f", value: null },
        "mapping": { type: mappingType, value: null }
    };

    this.createImpostorShaderBase(shaderName, mapping, mappingIndices, data, attributeData, count, mappingSize, mappingIndicesSize, mappingItemSize);
};

iCn3D.prototype.createImpostorShaderSphere = function (shaderName) {
    var me = this;
    var positions = new Float32Array(me.posArraySphere);
    var colors = new Float32Array(me.colorArraySphere);
    var radii = new Float32Array(me.radiusArraySphere);

    // sphere
    var mapping = new Float32Array([
        -1.0, 1.0,
        -1.0, -1.0,
        1.0, 1.0,
        1.0, -1.0
    ]);

    var mappingIndices = new Uint16Array([
        0, 1, 2,
        1, 3, 2
    ]);

    var mappingIndicesSize = 6;
    var mappingType = "v2";
    var mappingSize = 4;
    var mappingItemSize = 2;

    var count = positions.length / 3;

    var data = {
        "position": positions,
        "color": colors,
        "radius": radii
    };

    var attributeData = {
        "position": { type: "v3", value: null },
        "color": { type: "v3", value: null },
        "radius": { type: "f", value: null },
        "mapping": { type: mappingType, value: null }
    };

    this.createImpostorShaderBase(shaderName, mapping, mappingIndices, data, attributeData, count, mappingSize, mappingIndicesSize, mappingItemSize);
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.positionFromGeometry = function (mesh) {
    var geometry = mesh.geometry;

    var vertices = geometry.vertices;

    var meshPosition = mesh.position;
    var scale = mesh.scale;
    var matrix = mesh.matrix;

    var j, v3;
    var n = vertices.length;
    //var position = new Float32Array( n * 3 );
    var position = [];

    for (var v = 0; v < n; v++) {

        j = v * 3;

        if (geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry') {
            v3 = vertices[v].clone().multiply(scale).add(meshPosition);
        }
        else if (geometry.type == 'CylinderGeometry') {
            v3 = vertices[v].clone().applyMatrix4(matrix);
        }
        else {
            v3 = vertices[v];
        }

        position[j + 0] = v3.x;
        position[j + 1] = v3.y;
        position[j + 2] = v3.z;
    }

    return position;

};


iCn3D.prototype.colorFromGeometry = function (mesh) {
    var geometry = mesh.geometry;

    var meshColor = new THREE.Color(1, 1, 1);
    if (geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
        if (mesh.material !== undefined) meshColor = mesh.material.color;
    }

    var faces = geometry.faces;
    var vn = geometry.vertices.length;

    var bSurfaceVertex = (geometry.type == 'Surface') ? true : false;

    var j, f, c1, c2, c3;
    var n = faces.length;
    //var color = new Float32Array( vn * 3 );
    var color = [];

    for (var v = 0; v < n; v++) {

        f = faces[v];

        if (geometry.type == 'Surface') {
            c1 = f.vertexColors[0];
            c2 = f.vertexColors[1];
            c3 = f.vertexColors[2];
        }
        else if (geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
            c1 = meshColor;
            c2 = meshColor;
            c3 = meshColor;
        }
        else {
            c1 = f.color;
            c2 = f.color;
            c3 = f.color;
        }

        j = f.a * 3;
        color[j + 0] = c1.r;
        color[j + 1] = c1.g;
        color[j + 2] = c1.b;

        j = f.b * 3;
        color[j + 0] = c2.r;
        color[j + 1] = c2.g;
        color[j + 2] = c2.b;

        j = f.c * 3;
        color[j + 0] = c3.r;
        color[j + 1] = c3.g;
        color[j + 2] = c3.b;

    }

    return color;

};


iCn3D.prototype.indexFromGeometry = function (mesh) {
    var geometry = mesh.geometry;

    var faces = geometry.faces;

    var j, f;
    var n = faces.length;
    //var TypedArray = n * 3 > 65535 ? Uint32Array : Uint16Array;
    //var index = new TypedArray( n * 3 );
    var index = [];

    for (var v = 0; v < n; v++) {

        j = v * 3;
        f = faces[v];

        index[j + 0] = f.a;
        index[j + 1] = f.b;
        index[j + 2] = f.c;

    }

    return index;

};


iCn3D.prototype.normalFromGeometry = function (mesh) {
    var geometry = mesh.geometry;

    var faces = geometry.faces;
    var vn = geometry.vertices.length;

    var j, f, nn, n1, n2, n3;
    var n = faces.length;
    //var normal = new Float32Array( vn * 3 );
    var normal = [];

    for (var v = 0; v < n; v++) {

        f = faces[v];
        nn = f.vertexNormals;
        n1 = nn[0];
        n2 = nn[1];
        n3 = nn[2];

        j = f.a * 3;
        normal[j + 0] = n1.x;
        normal[j + 1] = n1.y;
        normal[j + 2] = n1.z;

        j = f.b * 3;
        normal[j + 0] = n2.x;
        normal[j + 1] = n2.y;
        normal[j + 2] = n2.z;

        j = f.c * 3;
        normal[j + 0] = n3.x;
        normal[j + 1] = n3.y;
        normal[j + 2] = n3.z;

    }

    return normal;

};

iCn3D.prototype.hashvalue2array = function (hash) {
    return $.map(hash, function (v) { return v; });
};

iCn3D.prototype.drawSymmetryMates = function () {
    if (this.bInstanced) {
        this.drawSymmetryMatesInstancing();
    }
    else {
        this.drawSymmetryMatesNoInstancing();
    }
}

iCn3D.prototype.drawSymmetryMatesNoInstancing = function () {
    if (this.biomtMatrices === undefined || this.biomtMatrices.length == 0) return;
    var cnt = 1; // itself
    var centerSum = this.center.clone();

    var identity = new THREE.Matrix4();
    identity.identity();

    for (var i = 0; i < this.biomtMatrices.length; i++) {  // skip itself
        var mat = this.biomtMatrices[i];
        if (mat === undefined) continue;

        /*
              var matArray = mat.toArray();
        
              // skip itself
              var bItself = 1;
              for(var j = 0, jl = matArray.length; j < jl; ++j) {
                if(j == 0 || j == 5 || j == 10) {
                  if(parseInt(1000*matArray[j]) != 1000) bItself = 0;
                }
                else if(j != 0 && j != 5 && j != 10 && j != 15) {
                  if(parseInt(1000*matArray[j]) != 0) bItself = 0;
                }
              }
        
              if(bItself) continue;
        */

        // skip itself
        if (mat.equals(identity)) continue;

        var symmetryMate = this.mdl.clone();
        symmetryMate.applyMatrix(mat);

        this.mdl.add(symmetryMate);

        symmetryMate = this.mdlImpostor.clone();
        symmetryMate.applyMatrix(mat);

        this.mdlImpostor.add(symmetryMate);

        //symmetryMate = this.mdlPicking.clone();
        //symmetryMate.applyMatrix(mat);

        //this.mdlPicking.add(symmetryMate);

        symmetryMate = this.mdl_ghost.clone();
        symmetryMate.applyMatrix(mat);

        this.mdl_ghost.add(symmetryMate);

        var center = this.center.clone();
        center.applyMatrix4(mat);
        centerSum.add(center);

        ++cnt;
    }

    this.maxD *= Math.sqrt(cnt);
    //this.center = centerSum.multiplyScalar(1.0 / cnt);

    // recenter the mdl* caused the impostor shifted somehow!!! disable the centering for now
    //       this.mdl.position.add(this.center).sub(centerSum.multiplyScalar(1.0 / cnt));
    //       this.mdlImpostor.position.add(this.center).sub(centerSum.multiplyScalar(1.0 / cnt));
    //this.mdlPicking.position.add(this.center).sub(centerSum.multiplyScalar(1.0 / cnt));

    //       this.mdl_ghost.position.add(this.center).sub(centerSum.multiplyScalar(1.0 / cnt));

    // reset cameara
    this.setCamera();
};

iCn3D.prototype.createInstancedGeometry = function (mesh) {
    var baseGeometry = mesh.geometry;

    var geometry = new THREE.InstancedBufferGeometry();

    var positionArray = [];
    var normalArray = [];
    var colorArray = [];
    var indexArray = [];

    var radiusArray = [];
    var mappingArray = [];
    var position2Array = [];
    var color2Array = [];

    if (baseGeometry.vertices && baseGeometry.faces) {
        this.instancedMaterial = this.getInstancedMaterial('Instancing');

        positionArray = positionArray.concat(this.positionFromGeometry(mesh));
        normalArray = normalArray.concat(this.normalFromGeometry(mesh));
        colorArray = colorArray.concat(this.colorFromGeometry(mesh));
        indexArray = indexArray.concat(this.indexFromGeometry(mesh));

        var bCylinderArray = [];
        var bCylinder = (baseGeometry.type == 'CylinderGeometry') ? 1.0 : 0.0;
        for (var i = 0, il = positionArray.length / 3; i < il; ++i) {
            bCylinderArray.push(bCylinder);
        }

        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
        geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normalArray), 3));
        geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), 3));

        geometry.addAttribute('cylinder', new THREE.BufferAttribute(new Float32Array(bCylinderArray), 1));
        geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));
    }
    else if (this.bImpo && baseGeometry.attributes.color2 !== undefined) { // cylinder
        this.instancedMaterial = this.getInstancedMaterial('CylinderInstancing');

        positionArray = positionArray.concat(this.hashvalue2array(baseGeometry.attributes.position1.array));
        colorArray = colorArray.concat(this.hashvalue2array(baseGeometry.attributes.color.array));

        position2Array = position2Array.concat(this.hashvalue2array(baseGeometry.attributes.position2.array));
        color2Array = color2Array.concat(this.hashvalue2array(baseGeometry.attributes.color2.array));

        indexArray = indexArray.concat(this.hashvalue2array(baseGeometry.index.array));
        radiusArray = radiusArray.concat(this.hashvalue2array(baseGeometry.attributes.radius.array));
        mappingArray = mappingArray.concat(this.hashvalue2array(baseGeometry.attributes.mapping.array));

        geometry.addAttribute('position1', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
        geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), 3));

        geometry.addAttribute('position2', new THREE.BufferAttribute(new Float32Array(position2Array), 3));
        geometry.addAttribute('color2', new THREE.BufferAttribute(new Float32Array(color2Array), 3));

        geometry.addAttribute('radius', new THREE.BufferAttribute(new Float32Array(radiusArray), 1));
        geometry.addAttribute('mapping', new THREE.BufferAttribute(new Float32Array(mappingArray), 3));
        geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));
    }
    else if (this.bImpo && baseGeometry.attributes.color !== undefined) { // sphere
        this.instancedMaterial = this.getInstancedMaterial('SphereInstancing');

        positionArray = positionArray.concat(this.hashvalue2array(baseGeometry.attributes.position.array));
        colorArray = colorArray.concat(this.hashvalue2array(baseGeometry.attributes.color.array));
        indexArray = indexArray.concat(this.hashvalue2array(baseGeometry.index.array));
        radiusArray = radiusArray.concat(this.hashvalue2array(baseGeometry.attributes.radius.array));
        mappingArray = mappingArray.concat(this.hashvalue2array(baseGeometry.attributes.mapping.array));

        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
        geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), 3));
        geometry.addAttribute('radius', new THREE.BufferAttribute(new Float32Array(radiusArray), 1));
        geometry.addAttribute('mapping', new THREE.BufferAttribute(new Float32Array(mappingArray), 2));
        geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));
    }

    positionArray = [];
    normalArray = [];
    colorArray = [];
    indexArray = [];

    radiusArray = [];
    mappingArray = [];
    position2Array = [];
    color2Array = [];

    var matricesAttribute1 = new THREE.InstancedBufferAttribute(new Float32Array(this.matricesElements1), 4);
    var matricesAttribute2 = new THREE.InstancedBufferAttribute(new Float32Array(this.matricesElements2), 4);
    var matricesAttribute3 = new THREE.InstancedBufferAttribute(new Float32Array(this.matricesElements3), 4);
    var matricesAttribute4 = new THREE.InstancedBufferAttribute(new Float32Array(this.matricesElements4), 4);

    geometry.addAttribute('matrix1', matricesAttribute1);
    geometry.addAttribute('matrix2', matricesAttribute2);
    geometry.addAttribute('matrix3', matricesAttribute3);
    geometry.addAttribute('matrix4', matricesAttribute4);

    return geometry;
};

iCn3D.prototype.getInstancedMaterial = function (name) {
    //var material = new THREE.RawShaderMaterial({
    var material = new THREE.ShaderMaterial({
        defines: this.defines,
        uniforms: this.uniforms,
        vertexShader: this.getShader(name + ".vert"),
        fragmentShader: this.getShader(name + ".frag"),
        depthTest: true,
        depthWrite: true,
        needsUpdate: true,
        lights: true
    });

    material.extensions.fragDepth = true;
    //https://stackoverflow.com/questions/33094496/three-js-shadermaterial-flatshading
    material.extensions.derivatives = '#extension GL_OES_standard_derivatives : enable';

    return material;
}

iCn3D.prototype.drawSymmetryMatesInstancing = function () {
    if (this.biomtMatrices === undefined || this.biomtMatrices.length == 0) return;
    var cnt = 1; // itself
    var centerSum = this.center.clone();

    this.setParametersForShader();

    if (this.bSetInstancing === undefined || !this.bSetInstancing) {
        //this.offsets = [];
        //this.orientations = [];
        this.matricesElements1 = [];
        this.matricesElements2 = [];
        this.matricesElements3 = [];
        this.matricesElements4 = [];

        var identity = new THREE.Matrix4();
        identity.identity();

        for (var i = 0; i < this.biomtMatrices.length; i++) {  // skip itself
            var mat = this.biomtMatrices[i];
            if (mat === undefined) continue;

            var matArray = mat.toArray();

            // skip itself
            if (mat.equals(identity)) continue;

            this.matricesElements1.push(matArray[0], matArray[1], matArray[2], matArray[3]);
            this.matricesElements2.push(matArray[4], matArray[5], matArray[6], matArray[7]);
            this.matricesElements3.push(matArray[8], matArray[9], matArray[10], matArray[11]);
            this.matricesElements4.push(matArray[12], matArray[13], matArray[14], matArray[15]);

            var center = this.center.clone();
            center.applyMatrix4(mat);
            centerSum.add(center);

            ++cnt;
        }
    }

    for (var i = 0, il = this.mdl.children.length; i < il; ++i) {
        var mesh = this.mdl.children[i];

        if (mesh.type === 'Sprite') continue;

        var geometry = this.createInstancedGeometry(mesh);
        var mesh2 = new THREE.Mesh(geometry, this.instancedMaterial);

        // important: https://stackoverflow.com/questions/21184061/mesh-suddenly-disappears-in-three-js-clipping
        // You are moving the camera in the CPU. You are moving the vertices of the plane in the GPU
        mesh2.frustumCulled = false;

        geometry = undefined;

        this.mdl.add(mesh2);
    }

    for (var i = 0, il = this.mdlImpostor.children.length; i < il; ++i) {
        var mesh = this.mdlImpostor.children[i];

        var geometry = this.createInstancedGeometry(mesh);
        var mesh2 = new THREE.Mesh(geometry, this.instancedMaterial);

        // important: https://stackoverflow.com/questions/21184061/mesh-suddenly-disappears-in-three-js-clipping
        // You are moving the camera in the CPU. You are moving the vertices of the plane in the GPU
        mesh2.frustumCulled = false;

        geometry = undefined;

        this.mdlImpostor.add(mesh2);
    }

    if (this.bSetInstancing === undefined || !this.bSetInstancing) {
        this.maxD *= Math.sqrt(cnt);

        this.center = centerSum.multiplyScalar(1.0 / cnt);

        this.maxDAssembly = this.maxD;

        this.centerAssembly = this.center.clone();

        this.setCenter(this.center);

        // reset cameara
        this.setCamera();
    }
    else {
        this.maxD = this.maxDAssembly;

        this.center = this.centerAssembly.clone();

        this.setCenter(this.center);

        // reset cameara
        this.setCamera();
    }

    this.bSetInstancing = true;
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.cloneHash = function (from) {
    var to = {};
    for (var i in from) {
        to[i] = from[i];
    }

    return to;
};

iCn3D.prototype.residueName2Abbr = function (residueName) {
    if (residueName !== undefined && residueName.charAt(0) !== ' ' && residueName.charAt(1) === ' ') {
        //residueName = 'n' + residueName.charAt(0);
        residueName = residueName.charAt(0);
    }

    switch (residueName) {
        case '  A':
            return 'A';
            break;
        case '  C':
            return 'C';
            break;
        case '  G':
            return 'G';
            break;
        case '  T':
            return 'T';
            break;
        case '  U':
            return 'U';
            break;
        case '  I':
            return 'I';
            break;
        case ' DA':
            return 'A';
            break;
        case ' DC':
            return 'C';
            break;
        case ' DG':
            return 'G';
            break;
        case ' DT':
            return 'T';
            break;
        case ' DU':
            return 'U';
            break;
        case ' DI':
            return 'I';
            break;
        case 'ALA':
            return 'A';
            break;
        case 'ARG':
            return 'R';
            break;
        case 'ASN':
            return 'N';
            break;
        case 'ASP':
            return 'D';
            break;
        case 'CYS':
            return 'C';
            break;
        case 'GLU':
            return 'E';
            break;
        case 'GLN':
            return 'Q';
            break;
        case 'GLY':
            return 'G';
            break;
        case 'HIS':
            return 'H';
            break;
        case 'ILE':
            return 'I';
            break;
        case 'LEU':
            return 'L';
            break;
        case 'LYS':
            return 'K';
            break;
        case 'MET':
            return 'M';
            break;
        case 'PHE':
            return 'F';
            break;
        case 'PRO':
            return 'P';
            break;
        case 'SER':
            return 'S';
            break;
        case 'THR':
            return 'T';
            break;
        case 'TRP':
            return 'W';
            break;
        case 'TYR':
            return 'Y';
            break;
        case 'VAL':
            return 'V';
            break;
        case 'SEC':
            return 'U';
            break;
        //        case 'PYL':
        //          return 'O';
        //          break;

        case 'HOH':
            return 'O';
            break;
        case 'WAT':
            return 'O';
            break;

        default:
            return residueName;
    }
};

iCn3D.prototype.intHash = function (atoms1, atoms2) {
    var results = {};

    if (Object.keys(atoms1).length < Object.keys(atoms2).length) {
        for (var i in atoms1) {
            if (atoms2 !== undefined && atoms2[i]) {
                results[i] = atoms1[i];
            }
        }
    }
    else {
        for (var i in atoms2) {
            if (atoms1 !== undefined && atoms1[i]) {
                results[i] = atoms2[i];
            }
        }
    }

    atoms1 = {};
    atoms2 = {};

    return results;
};

// get atoms in allAtoms, but not in "atoms"
iCn3D.prototype.exclHash = function (includeAtoms, excludeAtoms) {
    var results = {};

    for (var i in includeAtoms) {
        if (!(i in excludeAtoms)) {
            results[i] = includeAtoms[i];
        }
    }

    includeAtoms = {};
    excludeAtoms = {};

    return results;
};

iCn3D.prototype.unionHash = function (atoms1, atoms2) {
    // The commented-out version has a problem: atom1 became undefined.
    //jQuery.extend(atoms1, atoms2);

    //return atoms1;

    return this.unionHashNotInPlace(atoms1, atoms2);
};

iCn3D.prototype.unionHashNotInPlace = function (atoms1, atoms2) {
    var results = jQuery.extend({}, atoms1, atoms2);
    atoms1 = {};
    atoms2 = {};

    return results;
};

iCn3D.prototype.intHash2Atoms = function (atoms1, atoms2) {
    return this.hash2Atoms(this.intHash(atoms1, atoms2));
};

// get atoms in allAtoms, but not in "atoms"
iCn3D.prototype.exclHash2Atoms = function (includeAtoms, excludeAtoms) {
    return this.hash2Atoms(this.exclHash(includeAtoms, excludeAtoms));
};

iCn3D.prototype.unionHash2Atoms = function (atoms1, atoms2) {
    return this.hash2Atoms(this.unionHash(atoms1, atoms2));
};

iCn3D.prototype.hash2Atoms = function (hash) {
    var atoms = {};
    for (var i in hash) {
        atoms[i] = this.atoms[i];
    }

    hash = {};

    return atoms;
};

// from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.exportCanvas = function () {
    this.render();
    window.open(this.renderer.domElement.toDataURL('image/png'));
};

// zoom
iCn3D.prototype.zoomIn = function (normalizedFactor) { // 0.1
    var para = {};
    para._zoomFactor = 1 - normalizedFactor;
    para.update = true;
    this.controls.update(para);
    this.render();
};

iCn3D.prototype.zoomOut = function (normalizedFactor) { // 0.1
    var para = {};
    para._zoomFactor = 1 + normalizedFactor;
    para.update = true;
    this.controls.update(para);
    this.render();
};

// rotate
iCn3D.prototype.rotateLeft = function (degree) { // 5
    var axis = new THREE.Vector3(0, 1, 0);
    var angle = -degree / 180.0 * Math.PI;

    axis.applyQuaternion(this.cam.quaternion).normalize();

    var quaternion = new THREE.Quaternion();
    quaternion.setFromAxisAngle(axis, -angle);

    var para = {};
    para.quaternion = quaternion;
    para.update = true;

    this.controls.update(para);
    this.render();
};

iCn3D.prototype.rotateRight = function (degree) { // 5
    var axis = new THREE.Vector3(0, 1, 0);
    var angle = degree / 180.0 * Math.PI;

    axis.applyQuaternion(this.cam.quaternion).normalize();

    var quaternion = new THREE.Quaternion();
    quaternion.setFromAxisAngle(axis, -angle);

    var para = {};
    para.quaternion = quaternion;
    para.update = true;

    this.controls.update(para);
    this.render();
};

iCn3D.prototype.rotateUp = function (degree) { // 5
    var axis = new THREE.Vector3(1, 0, 0);
    var angle = -degree / 180.0 * Math.PI;

    axis.applyQuaternion(this.cam.quaternion).normalize();

    var quaternion = new THREE.Quaternion();
    quaternion.setFromAxisAngle(axis, -angle);

    var para = {};
    para.quaternion = quaternion;
    para.update = true;

    this.controls.update(para);
    this.render();
};

iCn3D.prototype.rotateDown = function (degree) { // 5
    var axis = new THREE.Vector3(1, 0, 0);
    var angle = degree / 180.0 * Math.PI;

    axis.applyQuaternion(this.cam.quaternion).normalize();

    var quaternion = new THREE.Quaternion();
    quaternion.setFromAxisAngle(axis, -angle);

    var para = {};
    para.quaternion = quaternion;
    para.update = true;

    this.controls.update(para);
    this.render();
};

// translate
iCn3D.prototype.translateLeft = function (percentScreenSize) { // 1
    var mouseChange = new THREE.Vector2(0, 0);

    // 1 means the full screen size
    mouseChange.x -= percentScreenSize / 100.0;

    var para = {};
    para.mouseChange = mouseChange;
    para.update = true;

    this.controls.update(para);
    this.render();
};

iCn3D.prototype.translateRight = function (percentScreenSize) { // 1
    var mouseChange = new THREE.Vector2(0, 0);

    mouseChange.x += percentScreenSize / 100.0;

    var para = {};
    para.mouseChange = mouseChange;
    para.update = true;

    this.controls.update(para);
    this.render();
};

iCn3D.prototype.translateUp = function (percentScreenSize) { // 1
    var mouseChange = new THREE.Vector2(0, 0);

    mouseChange.y -= percentScreenSize / 100.0;

    var para = {};
    para.mouseChange = mouseChange;
    para.update = true;

    this.controls.update(para);
    this.render();
};

iCn3D.prototype.translateDown = function (percentScreenSize) { // 1
    var mouseChange = new THREE.Vector2(0, 0);

    mouseChange.y += percentScreenSize / 100.0;

    var para = {};
    para.mouseChange = mouseChange;
    para.update = true;

    this.controls.update(para);
    this.render();
};

iCn3D.prototype.showPickingBase = function (atom) {
    if (!this.bShift && !this.bCtrl) this.removeHlObjects();

    this.pickedAtomList = {};
    if (this.pk === 1) {
        this.pickedAtomList[atom.serial] = 1;
    }
    else if (this.pk === 2) {
        var residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
        this.pickedAtomList = this.residues[residueid];
    }
    else if (this.pk === 3) {
        this.pickedAtomList = this.selectStrandHelixFromAtom(atom);
    }
    else if (this.pk === 4) {
        var chainid = atom.structure + '_' + atom.chain;
        this.pickedAtomList = this.chains[chainid];
    }

    if (this.pk === 0) {
        this.bShowHighlight = false;
    }
    else {
        this.bShowHighlight = true;
    }

    var intersectAtoms = (Object.keys(this.hAtoms).length == Object.keys(this.atoms).length) ? {} : this.intHash(this.hAtoms, this.pickedAtomList);
    var intersectAtomsSize = Object.keys(intersectAtoms).length;

    if (!this.bShift && !this.bCtrl) {
        //if(intersectAtomsSize > 0) {
        //    this.hAtoms = this.exclHash(this.hAtoms, this.pickedAtomList);
        //}
        //else {
        //    this.hAtoms = this.cloneHash(this.pickedAtomList);
        //}
        this.hAtoms = this.cloneHash(this.pickedAtomList);
    }
    else if (this.bShift) { // select a range

        if (this.prevPickedAtomList === undefined) {
            this.hAtoms = this.unionHash(this.hAtoms, this.pickedAtomList);
        }
        else {
            var prevAtom = this.getFirstAtomObj(this.prevPickedAtomList);
            var currAtom = this.getFirstAtomObj(this.pickedAtomList);

            var prevChainid = prevAtom.structure + '_' + prevAtom.chain;
            var currChainid = currAtom.structure + '_' + currAtom.chain;

            if (prevChainid != currChainid) {
                this.hAtoms = this.unionHash(this.hAtoms, this.pickedAtomList);
            }
            else { // range in the same chain only
                var combinedAtomList = this.unionHash(this.prevPickedAtomList, this.pickedAtomList);

                var firstAtom = this.getFirstAtomObj(combinedAtomList);
                var lastAtom = this.getLastAtomObj(combinedAtomList);

                for (var i = firstAtom.serial; i <= lastAtom.serial; ++i) {
                    this.hAtoms[i] = 1;
                }
            }
        }

        // remember this shift selection
        this.prevPickedAtomList = this.cloneHash(this.pickedAtomList);
    }
    else if (this.bCtrl) {
        if (intersectAtomsSize > 0) {
            this.hAtoms = this.exclHash(this.hAtoms, this.pickedAtomList);
        }
        else {
            this.hAtoms = this.unionHash(this.hAtoms, this.pickedAtomList);
        }
    }

    this.removeHlObjects();
    this.addHlObjects();
};

iCn3D.prototype.showPicking = function (atom) {
    this.showPickingBase(atom); // including render step

    //var text = '#' + atom.structure + '.' + atom.chain + ':' + atom.resi + '@' + atom.name;
    var residueText = '.' + atom.chain + ':' + atom.resi;
    var text = residueText + '@' + atom.name;

    var labels = {};
    labels['picking'] = [];

    var label = {};
    label.position = new THREE.Vector3(atom.coord.x + 1, atom.coord.y + 1, atom.coord.z + 1); // shifted by 1

    if (this.pk === 1) {
        label.text = text;
    }
    else if (this.pk === 2) {
        label.text = residueText;
    }
    //  else if(this.pk === 3) {
    //    label.text = residueText;
    //  }

    if (this.pk === 1 || this.pk === 2) {
        labels['picking'].push(label);

        //http://www.johannes-raida.de/tutorials/three.js/tutorial13/tutorial13.htm
        this.createLabelRepresentation(labels);
    }
};

iCn3D.prototype.removeHlObjects = function () {
    // remove prevous highlight
    for (var i in this.prevHighlightObjects) {
        //this.mdlPicking.remove(this.prevHighlightObjects[i]);
        this.mdl.remove(this.prevHighlightObjects[i]);
    }

    this.prevHighlightObjects = [];

    // remove prevous highlight
    for (var i in this.prevHighlightObjects_ghost) {
        //this.mdlPicking.remove(this.prevHighlightObjects_ghost[i]);
        this.mdl.remove(this.prevHighlightObjects_ghost[i]);
    }

    this.prevHighlightObjects_ghost = [];

};

iCn3D.prototype.addHlObjects = function (color, bRender, atomsHash) {
    if (color === undefined) color = this.hColor;
    if (atomsHash === undefined) atomsHash = this.hAtoms;

    this.applyDisplayOptions(this.opts, this.intHash(atomsHash, this.dAtoms), this.bHighlight);

    if (bRender === undefined || bRender) this.render();
};

iCn3D.prototype.switchHighlightLevelBase = function () {
    var me = this;
    $(document).bind('keydown', function (e) {
        if (e.keyCode === 38) { // arrow up, select upper level of atoms
            e.preventDefault();

            if (!me.bShift && !me.bCtrl) me.removeHlObjects();

            if (me.highlightlevel === 1) { // atom -> residue
                me.highlightlevel = 2;

                var firstAtom = me.getFirstAtomObj(me.pickedAtomList);

                if (!me.bShift && !me.bCtrl) {
                    me.hAtoms = me.cloneHash(me.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
                }
                else {
                    me.hAtoms = me.unionHash(me.hAtoms, me.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
                }
            }
            else if (me.highlightlevel === 2) { // residue -> strand
                me.highlightlevel = 3;

                var firstAtom = me.getFirstAtomObj(me.pickedAtomList);
                if (!me.bShift && !me.bCtrl) {
                    me.hAtoms = me.cloneHash(me.selectStrandHelixFromAtom(firstAtom));
                }
                else {
                    me.hAtoms = me.unionHash(me.hAtoms, me.selectStrandHelixFromAtom(firstAtom));
                }
            }
            else if (me.highlightlevel === 3) { // strand -> chain
                me.highlightlevel = 4;

                var firstAtom = me.getFirstAtomObj(me.pickedAtomList);
                if (!me.bShift && !me.bCtrl) {
                    me.hAtoms = me.cloneHash(me.chains[firstAtom.structure + '_' + firstAtom.chain]);
                }
                else {
                    me.hAtoms = me.unionHash(me.hAtoms, me.chains[firstAtom.structure + '_' + firstAtom.chain]);
                }
            }
            else if (me.highlightlevel === 4 || me.highlightlevel === 5) { // chain -> structure
                me.highlightlevel = 5;

                var firstAtom = me.getFirstAtomObj(me.pickedAtomList);

                if (!me.bShift && !me.bCtrl) me.hAtoms = {};
                var chainArray = me.structures[firstAtom.structure];
                for (var i = 0, il = chainArray.length; i < il; ++i) {
                    me.hAtoms = me.unionHash(me.hAtoms, me.chains[chainArray[i]]);
                }
            }

            me.addHlObjects();
        }
        else if (e.keyCode === 40) { // arrow down, select down level of atoms
            e.preventDefault();

            me.removeHlObjects();

            if ((me.highlightlevel === 2 || me.highlightlevel === 1) && Object.keys(me.pickedAtomList).length === 1) { // residue -> atom
                me.highlightlevel = 1;

                me.hAtoms = me.cloneHash(me.pickedAtomList);
                if (!me.bShift && !me.bCtrl) {
                    me.hAtoms = me.cloneHash(me.pickedAtomList);
                }
                else {
                    me.hAtoms = me.unionHash(me.hAtoms, me.pickedAtomList);
                }
            }
            else if (me.highlightlevel === 3) { // strand -> residue
                var residueHash = {};

                for (var i in me.pickedAtomList) {
                    residueid = me.atoms[i].structure + '_' + me.atoms[i].chain + '_' + me.atoms[i].resi;
                    residueHash[residueid] = 1;
                }

                if (Object.keys(residueHash).length === 1) {
                    me.highlightlevel = 2;

                    var firstAtom = me.getFirstAtomObj(me.pickedAtomList);
                    if (!me.bShift && !me.bCtrl) {
                        me.hAtoms = me.cloneHash(me.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
                    }
                    else {
                        me.hAtoms = me.unionHash(me.hAtoms, me.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
                    }
                }
            }
            else if (me.highlightlevel === 4) { // chain -> strand
                me.highlightlevel = 3;

                var firstAtom = me.getFirstAtomObj(me.pickedAtomList);
                if (!me.bShift && !me.bCtrl) {
                    me.hAtoms = me.cloneHash(me.selectStrandHelixFromAtom(firstAtom));
                }
                else {
                    me.hAtoms = me.unionHash(me.hAtoms, me.selectStrandHelixFromAtom(firstAtom));
                }
            }
            else if (me.highlightlevel === 5) { // structure -> chain
                me.highlightlevel = 4;

                var firstAtom = me.getFirstAtomObj(me.pickedAtomList);
                if (!me.bShift && !me.bCtrl) {
                    me.hAtoms = me.cloneHash(me.chains[firstAtom.structure + '_' + firstAtom.chain]);
                }
                else {
                    me.hAtoms = me.unionHash(me.hAtoms, me.chains[firstAtom.structure + '_' + firstAtom.chain]);
                }
            }

            me.addHlObjects();
        }
    });
};

iCn3D.prototype.switchHighlightLevel = function () {
    var me = this;
    this.switchHighlightLevelBase();
};

iCn3D.prototype.resetOrientation = function () {
    var bSet = false;
    if (this.commands.length > 0) {
        var commandTransformation = this.commands[0].split('|||');

        if (commandTransformation.length == 2) {
            var transformation = JSON.parse(commandTransformation[1]);

            this._zoomFactor = transformation.factor;

            this.mouseChange.x = transformation.mouseChange.x;
            this.mouseChange.y = transformation.mouseChange.y;

            this.quaternion._x = transformation.quaternion._x;
            this.quaternion._y = transformation.quaternion._y;
            this.quaternion._z = transformation.quaternion._z;
            this.quaternion._w = transformation.quaternion._w;

            bSet = true;
        }
    }

    if (!bSet) {
        this._zoomFactor = 1.0;
        this.mouseChange = new THREE.Vector2(0, 0);
        this.quaternion = new THREE.Quaternion(0, 0, 0, 1);
    }

    //reset this.maxD
    this.maxD = this.oriMaxD;
    this.center = this.oriCenter.clone();

    if (this.ori_chemicalbinding == 'show') {
        this.bSkipChemicalbinding = false;
    }
    else if (this.ori_chemicalbinding == 'hide') {
        this.bSkipChemicalbinding = true;
    }
};

// from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.getAtomsFromPosition = function (point, threshold) {
    var i, atom;

    if (threshold === undefined || threshold === null) {
        threshold = 1;
    }

    for (i in this.atoms) {
        var atom = this.atoms[i];

        //if(atom.coord.x < point.x - threshold || atom.coord.x > point.x + threshold) continue;
        //if(atom.coord.y < point.y - threshold || atom.coord.y > point.y + threshold) continue;
        //if(atom.coord.z < point.z - threshold || atom.coord.z > point.z + threshold) continue;

        if (this.ions.hasOwnProperty(i) && this.opts['ions'] === 'sphere') {
            var adjust = this.vdwRadii[atom.elem];

            if (Math.abs(atom.coord.x - point.x) - adjust > threshold) continue;
            if (Math.abs(atom.coord.y - point.y) - adjust > threshold) continue;
            if (Math.abs(atom.coord.z - point.z) - adjust > threshold) continue;
        }
        else {
            if (atom.coord.x < point.x - threshold || atom.coord.x > point.x + threshold) continue;
            if (atom.coord.y < point.y - threshold || atom.coord.y > point.y + threshold) continue;
            if (atom.coord.z < point.z - threshold || atom.coord.z > point.z + threshold) continue;
        }

        return atom;
    }

    return null;
};

iCn3D.prototype.getFirstAtomObj = function (atomsHash) {
    var atomKeys = Object.keys(atomsHash);
    var firstIndex = atomKeys[0];

    return this.atoms[firstIndex];
};

iCn3D.prototype.getLastAtomObj = function (atomsHash) {
    var atomKeys = Object.keys(atomsHash);
    var lastIndex = atomKeys[atomKeys.length - 1];

    return this.atoms[lastIndex];
};

// http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
iCn3D.prototype.hexToRgb = function (hex, a) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
        a: a
    } : null;
};

iCn3D.prototype.selectStrandHelixFromAtom = function (atom) {
    var firstAtom = atom;
    var lastAtom = atom;

    var atomsHash = {};

    // fill the beginning
    var beginResi = firstAtom.resi;
    for (var i = firstAtom.resi - 1; i > 0; --i) {
        var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
        if (!this.residues.hasOwnProperty(residueid)) break;

        var atom = this.getFirstAtomObj(this.residues[residueid]);
        beginResi = atom.resi;

        if ((firstAtom.ss !== 'coil' && atom.ss === firstAtom.ss && atom.ssbegin) || (firstAtom.ss === 'coil' && atom.ss !== firstAtom.ss)) {
            if (firstAtom.ss === 'coil' && atom.ss !== firstAtom.ss) {
                beginResi = atom.resi + 1;
            }
            break;
        }
    }

    for (var i = beginResi; i <= firstAtom.resi; ++i) {
        var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
        atomsHash = this.unionHash(atomsHash, this.hash2Atoms(this.residues[residueid]));
    }

    // fill the end
    var endResi = lastAtom.resi;
    var endChainResi = this.getLastAtomObj(this.chains[lastAtom.structure + '_' + lastAtom.chain]).resi;
    for (var i = lastAtom.resi + 1; i <= endChainResi; ++i) {
        var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
        if (!this.residues.hasOwnProperty(residueid)) break;

        var atom = this.getFirstAtomObj(this.residues[residueid]);
        endResi = atom.resi;

        if ((lastAtom.ss !== 'coil' && atom.ss === lastAtom.ss && atom.ssend) || (lastAtom.ss === 'coil' && atom.ss !== lastAtom.ss)) {
            if (lastAtom.ss === 'coil' && atom.ss !== lastAtom.ss) {
                endResi = atom.resi - 1;
            }
            break;
        }
    }

    for (var i = lastAtom.resi + 1; i <= endResi; ++i) {
        var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
        atomsHash = this.unionHash(atomsHash, this.hash2Atoms(this.residues[residueid]));
    }

    return atomsHash;
};

iCn3D.prototype.addNonCarbonAtomLabels = function (atoms) {
    var size = 18;
    var background = "#FFFFFF";

    var atomsHash = this.intHash(this.hAtoms, atoms);

    if (this.labels['schematic'] === undefined) this.labels['schematic'] = [];

    for (var i in atomsHash) {
        var atom = this.atoms[i];

        //if(!atom.het) continue;
        if (!this.residues.hasOwnProperty(atom.structure + '_' + atom.chain + '_' + atom.resi)) continue;
        if (atom.elem === 'C') continue;

        var label = {}; // Each label contains 'position', 'text', 'color', 'background'

        label.position = atom.coord;

        label.bSchematic = 1;

        label.text = atom.elem;
        label.size = size;

        label.color = "#" + atom.color.getHexString();
        label.background = background;

        this.labels['schematic'].push(label);
    }

    this.removeHlObjects();
};

iCn3D.prototype.addResiudeLabels = function (atoms, bSchematic, alpha) {
    var size = 18;
    var background = "#CCCCCC";
    if (alpha === undefined) alpha = 1.0;

    var atomsHash = this.intHash(this.hAtoms, atoms);

    if (bSchematic) {
        if (this.labels['schematic'] === undefined) this.labels['schematic'] = [];
    }
    else {
        if (this.labels['residue'] === undefined) this.labels['residue'] = [];
    }

    var prevReidueID = '';
    for (var i in atomsHash) {
        var atom = this.atoms[i];

        // allow chemicals
        //if(atom.het) continue;

        var label = {}; // Each label contains 'position', 'text', 'color', 'background'

        var currReidueID = atom.structure + '_' + atom.chain + '_' + atom.resi;

        if ((!atom.het && (atom.name === 'CA' || atom.name === "O3'" || atom.name === "O3*"))
            || this.water.hasOwnProperty(atom.serial)
            || this.ions.hasOwnProperty(atom.serial)
            || (this.chemicals.hasOwnProperty(atom.serial) && currReidueID !== prevReidueID)) {
            label.position = atom.coord;

            label.bSchematic = 0;
            if (bSchematic) label.bSchematic = 1;

            label.text = this.residueName2Abbr(atom.resn);
            label.size = size;

            var atomColorStr = atom.color.getHexString().toUpperCase();
            label.color = (atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr;
            label.background = background;
            //label.alpha = alpha; // this.hideLabels() didn't work. Remove this line for now

            if (bSchematic) {
                this.labels['schematic'].push(label);
            }
            else {
                this.labels['residue'].push(label);
            }
        }

        prevReidueID = currReidueID;
    }

    this.removeHlObjects();
};

iCn3D.prototype.setCenter = function (center) {
    this.mdl.position.set(0, 0, 0);
    this.mdlImpostor.position.set(0, 0, 0);
    this.mdl_ghost.position.set(0, 0, 0);

    this.mdl.position.sub(center);
    //this.mdlPicking.position.sub(center);
    this.mdlImpostor.position.sub(center);
    this.mdl_ghost.position.sub(center);
};

/*
 * JavaScript Canvas to Blob
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 */

/* global atob, Blob, define */

; (function (window) {
    'use strict'

    var CanvasPrototype =
        window.HTMLCanvasElement && window.HTMLCanvasElement.prototype
    var hasBlobConstructor =
        window.Blob &&
        (function () {
            try {
                return Boolean(new Blob())
            } catch (e) {
                return false
            }
        })()
    var hasArrayBufferViewSupport =
        hasBlobConstructor &&
        window.Uint8Array &&
        (function () {
            try {
                return new Blob([new Uint8Array(100)]).size === 100
            } catch (e) {
                return false
            }
        })()
    var BlobBuilder =
        window.BlobBuilder ||
        window.WebKitBlobBuilder ||
        window.MozBlobBuilder ||
        window.MSBlobBuilder
    var dataURIPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/
    var dataURLtoBlob =
        (hasBlobConstructor || BlobBuilder) &&
        window.atob &&
        window.ArrayBuffer &&
        window.Uint8Array &&
        function (dataURI) {
            var matches,
                mediaType,
                isBase64,
                dataString,
                byteString,
                arrayBuffer,
                intArray,
                i,
                bb
            // Parse the dataURI components as per RFC 2397
            matches = dataURI.match(dataURIPattern)
            if (!matches) {
                throw new Error('invalid data URI')
            }
            // Default to text/plain;charset=US-ASCII
            mediaType = matches[2]
                ? matches[1]
                : 'text/plain' + (matches[3] || ';charset=US-ASCII')
            isBase64 = !!matches[4]
            dataString = dataURI.slice(matches[0].length)
            if (isBase64) {
                // Convert base64 to raw binary data held in a string:
                byteString = atob(dataString)
            } else {
                // Convert base64/URLEncoded data component to raw binary:
                byteString = decodeURIComponent(dataString)
            }
            // Write the bytes of the string to an ArrayBuffer:
            arrayBuffer = new ArrayBuffer(byteString.length)
            intArray = new Uint8Array(arrayBuffer)
            for (i = 0; i < byteString.length; i += 1) {
                intArray[i] = byteString.charCodeAt(i)
            }
            // Write the ArrayBuffer (or ArrayBufferView) to a blob:
            if (hasBlobConstructor) {
                return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {
                    type: mediaType
                })
            }
            bb = new BlobBuilder()
            bb.append(arrayBuffer)
            return bb.getBlob(mediaType)
        }
    if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
        if (CanvasPrototype.mozGetAsFile) {
            CanvasPrototype.toBlob = function (callback, type, quality) {
                var self = this
                setTimeout(function () {
                    if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
                        callback(dataURLtoBlob(self.toDataURL(type, quality)))
                    } else {
                        callback(self.mozGetAsFile('blob', type))
                    }
                })
            }
        } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
            CanvasPrototype.toBlob = function (callback, type, quality) {
                var self = this
                setTimeout(function () {
                    callback(dataURLtoBlob(self.toDataURL(type, quality)))
                })
            }
        }
    }
    if (typeof define === 'function' && define.amd) {
        define(function () {
            return dataURLtoBlob
        })
    } else if (typeof module === 'object' && module.exports) {
        module.exports = dataURLtoBlob
    } else {
        window.dataURLtoBlob = dataURLtoBlob
    }
})(window)

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.8
 * 2018-03-22 14:03:47
 *
 * By Eli Grey, https://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/src/FileSaver.js */

var saveAs = saveAs || (function (view) {
    "use strict";
    // IE <10 is explicitly unsupported
    if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
    }
    var
        doc = view.document
        // only get URL when necessary in case Blob.js hasn't overridden it yet
        , get_URL = function () {
            return view.URL || view.webkitURL || view;
        }
        , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
        , can_use_save_link = "download" in save_link
        , click = function (node) {
            var event = new MouseEvent("click");
            node.dispatchEvent(event);
        }
        , is_safari = /constructor/i.test(view.HTMLElement) || view.safari
        , is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent)
        , setImmediate = view.setImmediate || view.setTimeout
        , throw_outside = function (ex) {
            setImmediate(function () {
                throw ex;
            }, 0);
        }
        , force_saveable_type = "application/octet-stream"
        // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
        , arbitrary_revoke_timeout = 1000 * 40 // in ms
        , revoke = function (file) {
            var revoker = function () {
                if (typeof file === "string") { // file is an object URL
                    get_URL().revokeObjectURL(file);
                } else { // file is a File
                    file.remove();
                }
            };
            setTimeout(revoker, arbitrary_revoke_timeout);
        }
        , dispatch = function (filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver["on" + event_types[i]];
                if (typeof listener === "function") {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        }
        , auto_bom = function (blob) {
            // prepend BOM for UTF-8 XML and text/* types (including HTML)
            // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
            if (blob && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                return new Blob([String.fromCharCode(0xFEFF), blob], { type: blob.type });
            }
            return blob;
        }
        , FileSaver = function (blob, name, no_auto_bom) {
            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            // First try a.download, then web filesystem, then object URLs
            var
                filesaver = this
                , type = (blob) ? blob.type : undefined
                , force = type === force_saveable_type
                , object_url
                , dispatch_all = function () {
                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                }
                // on any filesys errors revert to saving with object URLs
                , fs_error = function () {
                    if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
                        // Safari doesn't allow downloading of blob urls
                        var reader = new FileReader();
                        reader.onloadend = function () {
                            var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                            var popup = view.open(url, '_blank');
                            if (!popup) view.location.href = url;
                            url = undefined; // release reference before dispatching
                            filesaver.readyState = filesaver.DONE;
                            dispatch_all();
                        };
                        reader.readAsDataURL(blob);
                        filesaver.readyState = filesaver.INIT;
                        return;
                    }
                    // don't create more object URLs than needed
                    if (!object_url) object_url = get_URL().createObjectURL(blob);
                    if (force) {
                        view.location.href = object_url;
                    } else {
                        var opened = view.open(object_url, "_blank");
                        if (!opened) {
                            // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                            view.location.href = object_url;
                        }
                    }
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                    revoke(object_url);
                }
                ;
            filesaver.readyState = filesaver.INIT;

            if (can_use_save_link) {
                if (!object_url) object_url = get_URL().createObjectURL(blob);
                setImmediate(function () {
                    save_link.href = object_url;
                    save_link.download = name;
                    click(save_link);
                    dispatch_all();
                    revoke(object_url);
                    filesaver.readyState = filesaver.DONE;
                }, 0);
                return;
            }

            fs_error();
        }
        , FS_proto = FileSaver.prototype
        , saveAs = function (blob, name, no_auto_bom) {
            return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
        }
        ;

    // IE 10+ (native saveAs)
    if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
        return function (blob, name, no_auto_bom) {
            name = name || blob.name || "download";

            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            return navigator.msSaveOrOpenBlob(blob, name);
        };
    }

    // todo: detect chrome extensions & packaged apps
    //save_link.target = "_blank";

    FS_proto.abort = function () { };
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;

    FS_proto.error =
        FS_proto.onwritestart =
        FS_proto.onprogress =
        FS_proto.onwrite =
        FS_proto.onabort =
        FS_proto.onerror =
        FS_proto.onwriteend =
        null;

    return saveAs;
}(
    typeof self !== "undefined" && self
    || typeof window !== "undefined" && window
    || this
));

/*! marchingcube.js
 * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */

var $3Dmol = $3Dmol || {};

//Encapsulate marching cube algorithm for isosurface generation
// (currently used by protein surface rendering and generic volumetric data reading)
$3Dmol.MarchingCubeInitializer = function () {

    //Marching cube algorithm - assume data has been pre-treated so isovalue is 0
    // (i.e. select points greater than 0)
    //origin -  vector of origin of volumetric data (default is (0,0,0))
    // nX, nY, nZ - specifies number of voxels in each dimension
    // scale - cube diagonal unit vector scale (3Dmol vector) (specifying distance between data points); diagonal of cube
    // - default is 1 - assumes unit cube (1,1,1) diag)
    // fulltable - if true, use full marching cubes and tritables - else use trimmed table (e.g. surf render)
    // voxel - if true, draws with a blocky voxel style (default false)
    // verts, faces - vertex and face arrays to fill up

    //to match with protein surface...
    var ISDONE = 2;
    var my = {};

    my.march = function (data, verts, faces, spec) {

        var fulltable = !!(spec.fulltable);
        var origin = (spec.hasOwnProperty('origin') && spec.origin.hasOwnProperty('x')) ? spec.origin : { x: 0, y: 0, z: 0 };
        var voxel = !!(spec.voxel);
        var transform = spec.matrix; //if this is set, it overrides origin and unitCube

        var nX = spec.nX || 0;
        var nY = spec.nY || 0;
        var nZ = spec.nZ || 0;

        var scale = spec.scale || 1.0;
        var unitCube = null;
        if (spec.unitCube) {
            unitCube = spec.unitCube;
        } else {
            unitCube = { x: scale, y: scale, z: scale };
        }

        //keep track of calculated vertices to avoid repeats
        var vertnums = new Int32Array(nX * nY * nZ);

        var i, il;

        for (i = 0, il = vertnums.length; i < il; ++i)
            vertnums[i] = -1;

        // create (or retrieve) a vertex at the appropriate point for
        // the edge (p1,p2)

        var getVertex = function (i, j, k, code, p1, p2) {
            var pt = { x: 0, y: 0, z: 0 };
            var val1 = !!(code & (1 << p1));
            var val2 = !!(code & (1 << p2));

            // p1 if they are the same or if !val1
            var p = p1;
            if (!val1 && val2)
                p = p2;

            // adjust i,j,k by p
            if (p & 1)
                k++;
            if (p & 2)
                j++;
            if (p & 4)
                i++;

            if (transform) {
                pt = new $3Dmol.Vector3(i, j, k);
                pt = pt.applyMatrix4(transform);
                pt = { x: pt.x, y: pt.y, z: pt.z }; //remove vector gunk
            } else {
                pt.x = origin.x + unitCube.x * i;
                pt.y = origin.y + unitCube.y * j;
                pt.z = origin.z + unitCube.z * k;
            }

            var index = ((nY * i) + j) * nZ + k;

            //Have to add option to do voxels
            if (!voxel) {

                if (vertnums[index] < 0) // not created yet
                {
                    vertnums[index] = verts.length;
                    verts.push(pt);
                }
                return vertnums[index];

            }

            else {
                verts.push(pt);
                return verts.length - 1;
            }

        };

        var intersects = new Int32Array(12);

        var etable = (fulltable) ? edgeTable2 : edgeTable;
        var tritable = (fulltable) ? triTable2 : triTable;

        //Run marching cubes algorithm
        for (i = 0; i < nX - 1; ++i) {

            for (var j = 0; j < nY - 1; ++j) {

                for (var k = 0; k < nZ - 1; ++k) {

                    var code = 0;

                    for (var p = 0; p < 8; ++p) {
                        var index = ((nY * (i + ((p & 4) >> 2))) + j + ((p & 2) >> 1)) *
                            nZ + k + (p & 1);

                        //TODO: Need to fix vpBits in protein surface for this to work
                        var val = !!(data[index] & ISDONE);
                        //var val = !!(data[index] > 0);

                        code |= val << p;
                    }

                    if (code === 0 || code === 255)
                        continue;

                    var ecode = etable[code];

                    if (ecode === 0)
                        continue;

                    var ttable = tritable[code];

                    if (ecode & 1)
                        intersects[0] = getVertex(i, j, k, code, 0, 1);
                    if (ecode & 2)
                        intersects[1] = getVertex(i, j, k, code, 1, 3);
                    if (ecode & 4)
                        intersects[2] = getVertex(i, j, k, code, 3, 2);
                    if (ecode & 8)
                        intersects[3] = getVertex(i, j, k, code, 2, 0);
                    if (ecode & 16)
                        intersects[4] = getVertex(i, j, k, code, 4, 5);
                    if (ecode & 32)
                        intersects[5] = getVertex(i, j, k, code, 5, 7);
                    if (ecode & 64)
                        intersects[6] = getVertex(i, j, k, code, 7, 6);
                    if (ecode & 128)
                        intersects[7] = getVertex(i, j, k, code, 6, 4);
                    if (ecode & 256)
                        intersects[8] = getVertex(i, j, k, code, 0, 4);
                    if (ecode & 512)
                        intersects[9] = getVertex(i, j, k, code, 1, 5);
                    if (ecode & 1024)
                        intersects[10] = getVertex(i, j, k, code, 3, 7);
                    if (ecode & 2048)
                        intersects[11] = getVertex(i, j, k, code, 2, 6);

                    for (var t = 0; t < ttable.length; t += 3) {

                        var a = intersects[ttable[t]],
                            b = intersects[ttable[t + 1]],
                            c = intersects[ttable[t + 2]];

                        if (voxel && t >= 3) {
                            verts.push(verts[a]); a = verts.length - 1;
                            verts.push(verts[b]); b = verts.length - 1;
                            verts.push(verts[c]); c = verts.length - 1;
                        }


                        faces.push(a); faces.push(b); faces.push(c);
                    }

                }

            }

        }


    };

    my.laplacianSmooth = function (numiter, verts, faces) {
        var tps = new Array(verts.length);
        var i, il, j, jl, k, kl;
        for (i = 0, il = verts.length; i < il; i++)
            tps[i] = {
                x: 0,
                y: 0,
                z: 0
            };
        var vertdeg = new Array(20);
        var flagvert;
        for (i = 0; i < 20; i++)
            vertdeg[i] = new Array(verts.length);
        for (i = 0, il = verts.length; i < il; i++)
            vertdeg[0][i] = 0;
        for (i = 0, il = faces.length / 3; i < il; i++) {
            var aoffset = i * 3, boffset = i * 3 + 1, coffset = i * 3 + 2;
            flagvert = true;
            for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
                if (faces[boffset] == vertdeg[j + 1][faces[aoffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if (flagvert) {
                vertdeg[0][faces[aoffset]]++;
                vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[boffset];
            }
            flagvert = true;
            for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
                if (faces[coffset] == vertdeg[j + 1][faces[aoffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if (flagvert) {
                vertdeg[0][faces[aoffset]]++;
                vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[coffset];
            }
            // b
            flagvert = true;
            for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
                if (faces[aoffset] == vertdeg[j + 1][faces[boffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if (flagvert) {
                vertdeg[0][faces[boffset]]++;
                vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[aoffset];
            }
            flagvert = true;
            for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
                if (faces[coffset] == vertdeg[j + 1][faces[boffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if (flagvert) {
                vertdeg[0][faces[boffset]]++;
                vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[coffset];
            }
            // c
            flagvert = true;
            for (j = 0; j < vertdeg[0][faces[coffset]]; j++) {
                if (faces[aoffset] == vertdeg[j + 1][faces[coffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if (flagvert) {
                vertdeg[0][faces[coffset]]++;
                vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[aoffset];
            }
            flagvert = true;
            for (j = 0, jl = vertdeg[0][faces[coffset]]; j < jl; j++) {
                if (faces[boffset] == vertdeg[j + 1][faces[coffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if (flagvert) {
                vertdeg[0][faces[coffset]]++;
                vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[boffset];
            }
        }

        var wt = 1.00;
        var wt2 = 0.50;
        var ssign;
        var scaleFactor = 1;
        var outwt = 0.75 / (scaleFactor + 3.5); // area-preserving
        for (k = 0; k < numiter; k++) {
            for (i = 0, il = verts.length; i < il; i++) {
                if (vertdeg[0][i] < 3) {
                    tps[i].x = verts[i].x;
                    tps[i].y = verts[i].y;
                    tps[i].z = verts[i].z;
                } else if (vertdeg[0][i] == 3 || vertdeg[0][i] == 4) {
                    tps[i].x = 0;
                    tps[i].y = 0;
                    tps[i].z = 0;
                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                        tps[i].x += verts[vertdeg[j + 1][i]].x;
                        tps[i].y += verts[vertdeg[j + 1][i]].y;
                        tps[i].z += verts[vertdeg[j + 1][i]].z;
                    }
                    tps[i].x += wt2 * verts[i].x;
                    tps[i].y += wt2 * verts[i].y;
                    tps[i].z += wt2 * verts[i].z;
                    tps[i].x /= wt2 + vertdeg[0][i];
                    tps[i].y /= wt2 + vertdeg[0][i];
                    tps[i].z /= wt2 + vertdeg[0][i];
                } else {
                    tps[i].x = 0;
                    tps[i].y = 0;
                    tps[i].z = 0;
                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                        tps[i].x += verts[vertdeg[j + 1][i]].x;
                        tps[i].y += verts[vertdeg[j + 1][i]].y;
                        tps[i].z += verts[vertdeg[j + 1][i]].z;
                    }
                    tps[i].x += wt * verts[i].x;
                    tps[i].y += wt * verts[i].y;
                    tps[i].z += wt * verts[i].z;
                    tps[i].x /= wt + vertdeg[0][i];
                    tps[i].y /= wt + vertdeg[0][i];
                    tps[i].z /= wt + vertdeg[0][i];
                }
            }
            for (i = 0, il = verts.length; i < il; i++) {
                verts[i].x = tps[i].x;
                verts[i].y = tps[i].y;
                verts[i].z = tps[i].z;
            }
            /*
             * computenorm(); for (var i = 0; i < vertnumber; i++) { if
             * (verts[i].inout) ssign = 1; else ssign = -1; verts[i].x += ssign *
             * outwt * verts[i].pn.x; verts[i].y += ssign * outwt *
             * verts[i].pn.y; verts[i].z += ssign * outwt * verts[i].pn.z; }
             */
        }
    };


    /*
     * These tables are based off those by Paul Bourke and Geoffrey Heller:
     * http://paulbourke.net/geometry/polygonise/
     * http://paulbourke.net/geometry/polygonise/table2.txt
     *
     * However, they have been substantially modified to reflect a more
     * sensible corner numbering scheme and the discrete nature of our voxel data
     * (resulting in fewer faces).
     */
    my.edgeTable = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0xb00, 0x0, 0x0, 0x0, 0x700, 0x0, 0xd00, 0xe00, 0xf00, 0x0, 0x0, 0x0,
        0x8a, 0x0, 0x15, 0x0, 0x86, 0x0, 0x0, 0x0, 0x28c, 0x0, 0x813, 0xf19,
        0xe10, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x126, 0x0, 0x0, 0x15, 0x1c,
        0x0, 0xf23, 0x419, 0xd20, 0x0, 0xa8, 0xa2, 0xaa, 0x0, 0x285, 0x9ab,
        0x8a2, 0x0, 0x2af, 0x125, 0xac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x45, 0x0, 0x384, 0x0, 0x0, 0x0, 0x700, 0x8a, 0x83,
        0x648, 0x780, 0x0, 0x51, 0x0, 0x81a, 0x54, 0x55, 0x54, 0x56, 0x0, 0x51,
        0x0, 0xe5c, 0x14a, 0x451, 0x759, 0x650, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x45,
        0x0, 0x1f6, 0x0, 0x0, 0x15, 0xdfc, 0x8a, 0x7f3, 0x4f9, 0x5f0, 0xb00,
        0x68, 0x921, 0x6a, 0x348, 0x245, 0x16f, 0x66, 0xb00, 0xe6f, 0xd65,
        0xc6c, 0x76a, 0x663, 0x569, 0x460, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0xf46, 0x0, 0x0, 0x45, 0x24c, 0x2a, 0x823, 0x29, 0xb40, 0x0, 0x0, 0x0,
        0x6ba, 0x0, 0x8f5, 0xfff, 0xef6, 0x0, 0xff, 0x2f5, 0x2fc, 0x9ea, 0x8f3,
        0xbf9, 0xaf0, 0x0, 0x0, 0x51, 0x152, 0x0, 0xf55, 0x45f, 0xd56, 0x54,
        0x357, 0x55, 0x154, 0x852, 0xb53, 0x59, 0x950, 0x700, 0x2c8, 0xc2,
        0x48a, 0xfc4, 0xec5, 0xdcf, 0xcc6, 0x2c4, 0x2cf, 0xc5, 0xcc, 0xbca,
        0xac3, 0x9c9, 0x8c0, 0x0, 0x0, 0x0, 0x0, 0xa8, 0x1a4, 0xa8, 0x7a6,
        0xa2, 0xa2, 0x2a4, 0xbac, 0xaa, 0xa3, 0x2a8, 0x3a0, 0xd00, 0xc18,
        0xd00, 0xe3a, 0x34, 0x35, 0x73f, 0x636, 0x924, 0x83f, 0xb35, 0xa3c,
        0x12a, 0x33, 0x339, 0x230, 0xe00, 0xe00, 0xc12, 0xd9a, 0x684, 0x795,
        0x49f, 0x596, 0x92, 0xb9f, 0x815, 0x99c, 0x9a, 0x393, 0x99, 0x190,
        0xf00, 0xe08, 0xd01, 0xc0a, 0x704, 0x605, 0x50f, 0x406, 0xb02, 0xa0f,
        0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0];

    var edgeTable = new Uint32Array(my.edgeTable);

    var triTable = my.triTable = [[], [], [], [], [], [], [], [11, 9, 8], [], [], [],
    [8, 10, 9], [], [10, 8, 11], [9, 11, 10],
    [8, 10, 9, 8, 11, 10], [], [], [], [1, 7, 3], [], [4, 2, 0], [],
    [2, 1, 7], [], [], [], [2, 7, 3, 2, 9, 7], [],
    [1, 4, 11, 1, 0, 4], [3, 8, 0, 11, 9, 4, 11, 10, 9],
    [4, 11, 9, 11, 10, 9], [], [], [], [5, 3, 1], [], [], [],
    [2, 5, 8, 2, 1, 5], [], [], [2, 4, 0], [3, 2, 4], [],
    [0, 9, 1, 8, 10, 5, 8, 11, 10], [3, 4, 0, 3, 10, 4],
    [5, 8, 10, 8, 11, 10], [], [3, 5, 7], [7, 1, 5],
    [1, 7, 3, 1, 5, 7], [], [9, 2, 0, 9, 7, 2],
    [0, 3, 8, 1, 7, 11, 1, 5, 7], [11, 1, 7, 1, 5, 7], [],
    [9, 1, 0, 5, 3, 2, 5, 7, 3], [8, 2, 5, 8, 0, 2],
    [2, 5, 3, 5, 7, 3], [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
    [9, 1, 0, 10, 7, 11, 10, 5, 7], [3, 8, 0, 7, 10, 5, 7, 11, 10],
    [11, 5, 7, 11, 10, 5], [], [], [], [], [], [0, 6, 2], [],
    [7, 2, 9, 7, 9, 8], [], [], [], [8, 10, 9], [7, 1, 3],
    [7, 1, 0], [6, 9, 3, 6, 10, 9], [7, 10, 8, 10, 9, 8], [],
    [6, 0, 4], [], [11, 1, 4, 11, 3, 1], [2, 4, 6],
    [2, 0, 4, 2, 4, 6], [2, 4, 6], [1, 4, 2, 4, 6, 2], [],
    [6, 0, 4], [], [2, 11, 3, 6, 9, 4, 6, 10, 9], [8, 6, 1, 8, 1, 3],
    [10, 0, 6, 0, 4, 6], [8, 0, 3, 9, 6, 10, 9, 4, 6],
    [10, 4, 6, 10, 9, 4], [], [], [], [5, 3, 1], [], [0, 6, 2], [],
    [7, 4, 8, 5, 2, 1, 5, 6, 2], [], [], [2, 4, 0],
    [7, 4, 8, 2, 11, 3, 10, 5, 6], [7, 1, 3],
    [5, 6, 10, 0, 9, 1, 8, 7, 4], [5, 6, 10, 7, 0, 3, 7, 4, 0],
    [10, 5, 6, 4, 8, 7], [9, 11, 8], [3, 5, 6],
    [0, 5, 11, 0, 11, 8], [6, 3, 5, 3, 1, 5], [3, 9, 6, 3, 8, 9],
    [9, 6, 0, 6, 2, 0], [0, 3, 8, 2, 5, 6, 2, 1, 5],
    [1, 6, 2, 1, 5, 6], [9, 11, 8], [1, 0, 9, 6, 10, 5, 11, 3, 2],
    [6, 10, 5, 2, 8, 0, 2, 11, 8], [3, 2, 11, 10, 5, 6],
    [10, 5, 6, 9, 3, 8, 9, 1, 3], [0, 9, 1, 5, 6, 10],
    [8, 0, 3, 10, 5, 6], [10, 5, 6], [], [], [], [], [], [], [],
    [1, 10, 2, 9, 11, 6, 9, 8, 11], [], [], [6, 0, 2],
    [3, 6, 9, 3, 2, 6], [3, 5, 1], [0, 5, 1, 0, 11, 5], [0, 3, 5],
    [6, 9, 11, 9, 8, 11], [], [], [], [4, 5, 9, 7, 1, 10, 7, 3, 1], [],
    [11, 6, 7, 2, 4, 5, 2, 0, 4],
    [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
    [6, 7, 11, 1, 10, 2, 9, 4, 5], [],
    [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2], [9, 4, 5, 0, 6, 7, 0, 2, 6],
    [4, 5, 9, 6, 3, 2, 6, 7, 3], [6, 7, 11, 5, 3, 8, 5, 1, 3],
    [6, 7, 11, 4, 1, 0, 4, 5, 1], [4, 5, 9, 3, 8, 0, 11, 6, 7],
    [9, 4, 5, 7, 11, 6], [], [], [0, 6, 4], [8, 6, 4, 8, 1, 6], [],
    [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
    [10, 2, 1, 6, 0, 3, 6, 4, 0], [10, 2, 1, 11, 4, 8, 11, 6, 4],
    [4, 2, 6], [1, 0, 9, 2, 4, 8, 2, 6, 4], [2, 4, 0, 2, 6, 4],
    [8, 2, 4, 2, 6, 4], [11, 4, 1, 11, 6, 4],
    [0, 9, 1, 4, 11, 6, 4, 8, 11], [3, 6, 0, 6, 4, 0],
    [8, 6, 4, 8, 11, 6], [10, 8, 9], [6, 3, 9, 6, 7, 3], [6, 7, 1],
    [10, 7, 1, 7, 3, 1], [7, 11, 6, 8, 10, 2, 8, 9, 10],
    [11, 6, 7, 10, 0, 9, 10, 2, 0], [2, 1, 10, 7, 11, 6, 8, 0, 3],
    [1, 10, 2, 6, 7, 11], [7, 2, 6, 7, 9, 2],
    [1, 0, 9, 3, 6, 7, 3, 2, 6], [7, 0, 6, 0, 2, 6],
    [2, 7, 3, 2, 6, 7], [7, 11, 6, 3, 9, 1, 3, 8, 9],
    [9, 1, 0, 11, 6, 7], [0, 3, 8, 11, 6, 7], [11, 6, 7], [], [], [],
    [], [5, 3, 7], [8, 5, 2, 8, 7, 5], [5, 3, 7],
    [1, 10, 2, 5, 8, 7, 5, 9, 8], [1, 7, 5], [1, 7, 5],
    [9, 2, 7, 9, 7, 5], [11, 3, 2, 8, 5, 9, 8, 7, 5],
    [1, 3, 7, 1, 7, 5], [0, 7, 1, 7, 5, 1], [9, 3, 5, 3, 7, 5],
    [9, 7, 5, 9, 8, 7], [8, 10, 11], [3, 4, 10, 3, 10, 11],
    [8, 10, 11], [5, 9, 4, 1, 11, 3, 1, 10, 11], [2, 4, 5],
    [5, 2, 4, 2, 0, 4], [0, 3, 8, 5, 9, 4, 10, 2, 1],
    [2, 1, 10, 9, 4, 5], [2, 8, 5, 2, 11, 8],
    [3, 2, 11, 1, 4, 5, 1, 0, 4], [9, 4, 5, 8, 2, 11, 8, 0, 2],
    [11, 3, 2, 9, 4, 5], [8, 5, 3, 5, 1, 3], [5, 0, 4, 5, 1, 0],
    [3, 8, 0, 4, 5, 9], [9, 4, 5], [11, 9, 10], [11, 9, 10],
    [1, 11, 4, 1, 10, 11], [8, 7, 4, 11, 1, 10, 11, 3, 1],
    [2, 7, 9, 2, 9, 10], [4, 8, 7, 0, 10, 2, 0, 9, 10],
    [2, 1, 10, 0, 7, 4, 0, 3, 7], [10, 2, 1, 8, 7, 4], [1, 7, 4],
    [3, 2, 11, 4, 8, 7, 9, 1, 0], [11, 4, 2, 4, 0, 2],
    [2, 11, 3, 7, 4, 8], [4, 1, 7, 1, 3, 7], [1, 0, 9, 8, 7, 4],
    [3, 4, 0, 3, 7, 4], [8, 7, 4], [8, 9, 10, 8, 10, 11],
    [3, 9, 11, 9, 10, 11], [0, 10, 8, 10, 11, 8],
    [10, 3, 1, 10, 11, 3], [2, 8, 10, 8, 9, 10], [9, 2, 0, 9, 10, 2],
    [8, 0, 3, 1, 10, 2], [10, 2, 1], [1, 11, 9, 11, 8, 9],
    [11, 3, 2, 0, 9, 1], [11, 0, 2, 11, 8, 0], [11, 3, 2],
    [8, 1, 3, 8, 9, 1], [9, 1, 0], [8, 0, 3], []];

    var edgeTable2 = [0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f,
        0xb06, 0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190,
        0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96, 0x596, 0x49f, 0x795,
        0x69c, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0xa3c,
        0xb35, 0x83f, 0x936, 0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39,
        0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6, 0x7a6,
        0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x8c0, 0x9c9, 0xac3,
        0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca,
        0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f,
        0x256, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650, 0xaf0,
        0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6, 0xef6, 0xfff, 0xcf5,
        0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0x36c,
        0x265, 0x16f, 0x66, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569,
        0x460, 0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x66,
        0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3,
        0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa,
        0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f,
        0xd56, 0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0,
        0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0x3c6, 0x2cf, 0x1c5,
        0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0, 0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac,
        0x5a5, 0x6af, 0x7a6, 0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9,
        0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636, 0x936,
        0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93,
        0xd9a, 0x69c, 0x795, 0x49f, 0x596, 0xa96, 0xb9f, 0x895, 0x99c, 0x29a,
        0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f,
        0x406, 0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0];

    var triTable2 = [[], [8, 3, 0], [9, 0, 1], [8, 3, 1, 8, 1, 9],
    [11, 2, 3], [11, 2, 0, 11, 0, 8], [11, 2, 3, 0, 1, 9],
    [2, 1, 11, 1, 9, 11, 11, 9, 8], [10, 1, 2], [8, 3, 0, 1, 2, 10],
    [9, 0, 2, 9, 2, 10], [3, 2, 8, 2, 10, 8, 8, 10, 9],
    [10, 1, 3, 10, 3, 11], [1, 0, 10, 0, 8, 10, 10, 8, 11],
    [0, 3, 9, 3, 11, 9, 9, 11, 10], [8, 10, 9, 8, 11, 10], [8, 4, 7],
    [3, 0, 4, 3, 4, 7], [1, 9, 0, 8, 4, 7],
    [9, 4, 1, 4, 7, 1, 1, 7, 3], [2, 3, 11, 7, 8, 4],
    [7, 11, 4, 11, 2, 4, 4, 2, 0], [3, 11, 2, 4, 7, 8, 9, 0, 1],
    [2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4], [10, 1, 2, 8, 4, 7],
    [2, 10, 1, 0, 4, 7, 0, 7, 3], [4, 7, 8, 0, 2, 10, 0, 10, 9],
    [2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9],
    [8, 4, 7, 11, 10, 1, 11, 1, 3],
    [11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4],
    [3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9],
    [7, 11, 4, 4, 11, 9, 11, 10, 9], [9, 5, 4], [3, 0, 8, 4, 9, 5],
    [5, 4, 0, 5, 0, 1], [4, 8, 5, 8, 3, 5, 5, 3, 1],
    [11, 2, 3, 9, 5, 4], [9, 5, 4, 8, 11, 2, 8, 2, 0],
    [3, 11, 2, 1, 5, 4, 1, 4, 0],
    [8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5], [2, 10, 1, 9, 5, 4],
    [0, 8, 3, 5, 4, 9, 10, 1, 2], [10, 5, 2, 5, 4, 2, 2, 4, 0],
    [3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5],
    [5, 4, 9, 1, 3, 11, 1, 11, 10],
    [0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10],
    [3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10],
    [4, 8, 5, 5, 8, 10, 8, 11, 10], [9, 5, 7, 9, 7, 8],
    [0, 9, 3, 9, 5, 3, 3, 5, 7], [8, 0, 7, 0, 1, 7, 7, 1, 5],
    [1, 7, 3, 1, 5, 7], [11, 2, 3, 8, 9, 5, 8, 5, 7],
    [9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7],
    [0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7],
    [2, 1, 11, 11, 1, 7, 1, 5, 7], [1, 2, 10, 5, 7, 8, 5, 8, 9],
    [9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3],
    [5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2],
    [10, 5, 2, 2, 5, 3, 5, 7, 3],
    [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
    [9, 1, 0, 10, 7, 11, 10, 5, 7], [3, 8, 0, 7, 10, 5, 7, 11, 10],
    [11, 5, 7, 11, 10, 5], [11, 7, 6], [0, 8, 3, 11, 7, 6],
    [9, 0, 1, 11, 7, 6], [7, 6, 11, 3, 1, 9, 3, 9, 8],
    [2, 3, 7, 2, 7, 6], [8, 7, 0, 7, 6, 0, 0, 6, 2],
    [1, 9, 0, 3, 7, 6, 3, 6, 2], [7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8],
    [1, 2, 10, 6, 11, 7], [2, 10, 1, 7, 6, 11, 8, 3, 0],
    [11, 7, 6, 10, 9, 0, 10, 0, 2],
    [7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9],
    [6, 10, 7, 10, 1, 7, 7, 1, 3],
    [6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8],
    [9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7],
    [6, 10, 7, 7, 10, 8, 10, 9, 8], [8, 4, 6, 8, 6, 11],
    [11, 3, 6, 3, 0, 6, 6, 0, 4], [0, 1, 9, 4, 6, 11, 4, 11, 8],
    [1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6],
    [3, 8, 2, 8, 4, 2, 2, 4, 6], [2, 0, 4, 2, 4, 6],
    [1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6], [9, 4, 1, 1, 4, 2, 4, 6, 2],
    [10, 1, 2, 11, 8, 4, 11, 4, 6],
    [10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4],
    [0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11],
    [2, 11, 3, 6, 9, 4, 6, 10, 9],
    [8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3],
    [1, 0, 10, 10, 0, 6, 0, 4, 6], [8, 0, 3, 9, 6, 10, 9, 4, 6],
    [10, 4, 6, 10, 9, 4], [9, 5, 4, 7, 6, 11],
    [4, 9, 5, 3, 0, 8, 11, 7, 6], [6, 11, 7, 4, 0, 1, 4, 1, 5],
    [6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1], [4, 9, 5, 6, 2, 3, 6, 3, 7],
    [9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2],
    [4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3], [7, 4, 8, 5, 2, 1, 5, 6, 2],
    [6, 11, 7, 1, 2, 10, 9, 5, 4],
    [11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4],
    [11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0],
    [7, 4, 8, 2, 11, 3, 10, 5, 6],
    [4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3],
    [5, 6, 10, 0, 9, 1, 8, 7, 4], [5, 6, 10, 7, 0, 3, 7, 4, 0],
    [10, 5, 6, 4, 8, 7], [5, 6, 9, 6, 11, 9, 9, 11, 8],
    [0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11],
    [0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8],
    [11, 3, 6, 6, 3, 5, 3, 1, 5], [9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2],
    [5, 6, 9, 9, 6, 0, 6, 2, 0], [0, 3, 8, 2, 5, 6, 2, 1, 5],
    [1, 6, 2, 1, 5, 6], [1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8],
    [1, 0, 9, 6, 10, 5, 11, 3, 2], [6, 10, 5, 2, 8, 0, 2, 11, 8],
    [3, 2, 11, 10, 5, 6], [10, 5, 6, 9, 3, 8, 9, 1, 3],
    [0, 9, 1, 5, 6, 10], [8, 0, 3, 10, 5, 6], [10, 5, 6],
    [10, 6, 5], [8, 3, 0, 10, 6, 5], [0, 1, 9, 5, 10, 6],
    [10, 6, 5, 9, 8, 3, 9, 3, 1], [3, 11, 2, 10, 6, 5],
    [6, 5, 10, 2, 0, 8, 2, 8, 11], [1, 9, 0, 6, 5, 10, 11, 2, 3],
    [1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11], [1, 2, 6, 1, 6, 5],
    [0, 8, 3, 2, 6, 5, 2, 5, 1], [5, 9, 6, 9, 0, 6, 6, 0, 2],
    [9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6], [11, 6, 3, 6, 5, 3, 3, 5, 1],
    [0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11],
    [0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6],
    [5, 9, 6, 6, 9, 11, 9, 8, 11], [10, 6, 5, 4, 7, 8],
    [5, 10, 6, 7, 3, 0, 7, 0, 4], [5, 10, 6, 0, 1, 9, 8, 4, 7],
    [4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1],
    [7, 8, 4, 2, 3, 11, 10, 6, 5],
    [11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4],
    [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
    [6, 7, 11, 1, 10, 2, 9, 4, 5], [7, 8, 4, 5, 1, 2, 5, 2, 6],
    [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],
    [9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6], [4, 5, 9, 6, 3, 2, 6, 7, 3],
    [6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3],
    [6, 7, 11, 4, 1, 0, 4, 5, 1], [4, 5, 9, 3, 8, 0, 11, 6, 7],
    [9, 4, 5, 7, 11, 6], [10, 6, 4, 10, 4, 9],
    [8, 3, 0, 9, 10, 6, 9, 6, 4], [1, 10, 0, 10, 6, 0, 0, 6, 4],
    [8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1],
    [2, 3, 11, 6, 4, 9, 6, 9, 10],
    [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
    [10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0],
    [10, 2, 1, 11, 4, 8, 11, 6, 4], [9, 1, 4, 1, 2, 4, 4, 2, 6],
    [1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4], [2, 4, 0, 2, 6, 4],
    [3, 2, 8, 8, 2, 4, 2, 6, 4],
    [1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4],
    [0, 9, 1, 4, 11, 6, 4, 8, 11], [11, 6, 3, 3, 6, 0, 6, 4, 0],
    [8, 6, 4, 8, 11, 6], [6, 7, 10, 7, 8, 10, 10, 8, 9],
    [9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3],
    [6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0],
    [6, 7, 10, 10, 7, 1, 7, 3, 1],
    [7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10],
    [11, 6, 7, 10, 0, 9, 10, 2, 0], [2, 1, 10, 7, 11, 6, 8, 0, 3],
    [1, 10, 2, 6, 7, 11], [7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9],
    [1, 0, 9, 3, 6, 7, 3, 2, 6], [8, 0, 7, 7, 0, 6, 0, 2, 6],
    [2, 7, 3, 2, 6, 7], [7, 11, 6, 3, 9, 1, 3, 8, 9],
    [9, 1, 0, 11, 6, 7], [0, 3, 8, 11, 6, 7], [11, 6, 7],
    [11, 7, 5, 11, 5, 10], [3, 0, 8, 7, 5, 10, 7, 10, 11],
    [9, 0, 1, 10, 11, 7, 10, 7, 5],
    [3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10],
    [10, 2, 5, 2, 3, 5, 5, 3, 7],
    [5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0],
    [9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7],
    [1, 10, 2, 5, 8, 7, 5, 9, 8], [2, 11, 1, 11, 7, 1, 1, 7, 5],
    [0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5],
    [9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5],
    [11, 3, 2, 8, 5, 9, 8, 7, 5], [1, 3, 7, 1, 7, 5],
    [8, 7, 0, 0, 7, 1, 7, 5, 1], [0, 3, 9, 9, 3, 5, 3, 7, 5],
    [9, 7, 5, 9, 8, 7], [4, 5, 8, 5, 10, 8, 8, 10, 11],
    [3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11],
    [0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11],
    [5, 9, 4, 1, 11, 3, 1, 10, 11],
    [3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10],
    [10, 2, 5, 5, 2, 4, 2, 0, 4], [0, 3, 8, 5, 9, 4, 10, 2, 1],
    [2, 1, 10, 9, 4, 5], [8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1],
    [3, 2, 11, 1, 4, 5, 1, 0, 4], [9, 4, 5, 8, 2, 11, 8, 0, 2],
    [11, 3, 2, 9, 4, 5], [4, 5, 8, 8, 5, 3, 5, 1, 3],
    [5, 0, 4, 5, 1, 0], [3, 8, 0, 4, 5, 9], [9, 4, 5],
    [7, 4, 11, 4, 9, 11, 11, 9, 10],
    [3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10],
    [11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0],
    [8, 7, 4, 11, 1, 10, 11, 3, 1],
    [2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10],
    [4, 8, 7, 0, 10, 2, 0, 9, 10], [2, 1, 10, 0, 7, 4, 0, 3, 7],
    [10, 2, 1, 8, 7, 4], [2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9],
    [3, 2, 11, 4, 8, 7, 9, 1, 0], [7, 4, 11, 11, 4, 2, 4, 0, 2],
    [2, 11, 3, 7, 4, 8], [9, 1, 4, 4, 1, 7, 1, 3, 7],
    [1, 0, 9, 8, 7, 4], [3, 4, 0, 3, 7, 4], [8, 7, 4],
    [8, 9, 10, 8, 10, 11], [0, 9, 3, 3, 9, 11, 9, 10, 11],
    [1, 10, 0, 0, 10, 8, 10, 11, 8], [10, 3, 1, 10, 11, 3],
    [3, 8, 2, 2, 8, 10, 8, 9, 10], [9, 2, 0, 9, 10, 2],
    [8, 0, 3, 1, 10, 2], [10, 2, 1], [2, 11, 1, 1, 11, 9, 11, 8, 9],
    [11, 3, 2, 0, 9, 1], [11, 0, 2, 11, 8, 0], [11, 3, 2],
    [8, 1, 3, 8, 9, 1], [9, 1, 0], [8, 0, 3], []];

    return my;
};

//each webworker needs its own marching cube object
$3Dmol.MarchingCube = $3Dmol.MarchingCubeInitializer();




/*! ProteinSurface4.js
 * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */

/*  ProteinSurface.js by biochem_fan

Ported and modified for Javascript based on EDTSurf,
  whose license is as follows.

Permission to use, copy, modify, and distribute this program for any
purpose, with or without fee, is hereby granted, provided that this
copyright notice and the reference information appear in all copies or
substantial portions of the Software. It is provided "as is" without
express or implied warranty.

Reference:
http://zhanglab.ccmb.med.umich.edu/EDTSurf/
D. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular Surfaces
by Euclidean Distance Transform. PLoS ONE 4(12): e8140.

=======

TODO: Improved performance on Firefox
      Reduce memory consumption
      Refactor!
 */


// dkoes
// Surface calculations.  This must be safe to use within a web worker.
if (typeof console === 'undefined') {
    // this should only be true inside of a webworker
    console = {
        log: function () {
        }
    };
}

$3Dmol.ProteinSurface = function (threshbox) {

    // constants for vpbits bitmasks
    /** @const */
    var INOUT = 1;
    /** @const */
    var ISDONE = 2;
    /** @const */
    var ISBOUND = 4;

    var ptranx = 0, ptrany = 0, ptranz = 0;
    var probeRadius = 1.4;
    var defaultScaleFactor = 2;
    var scaleFactor = defaultScaleFactor; // 2 is .5A grid; if this is made user configurable,
    // also have to adjust offset used to find non-shown
    // atoms
    var pHeight = 0, pWidth = 0, pLength = 0;
    var cutRadius = 0;
    var vpBits = null; // uint8 array of bitmasks
    var vpDistance = null; // floatarray of _squared_ distances
    var vpAtomID = null; // intarray
    var vertnumber = 0, facenumber = 0;
    var pminx = 0, pminy = 0, pminz = 0, pmaxx = 0, pmaxy = 0, pmaxz = 0;

    var vdwRadii = {
        "H": 1.2,
        "Li": 1.82,
        "Na": 2.27,
        "K": 2.75,
        "C": 1.7,
        "N": 1.55,
        "O": 1.52,
        "F": 1.47,
        "P": 1.80,
        "S": 1.80,
        "CL": 1.75,
        "BR": 1.85,
        "SE": 1.90,
        "ZN": 1.39,
        "CU": 1.4,
        "NI": 1.63,
        "X": 2
    };

    /** @param {AtomSpec} atom */
    var getVDWIndex = function (atom) {
        if (!atom.elem || typeof (vdwRadii[atom.elem]) == "undefined") {
            return "X";
        }
        return atom.elem;
    };

    var depty = {}, widxz = {};
    var faces, verts;
    var nb = [new Int32Array([1, 0, 0]), new Int32Array([-1, 0, 0]),
    new Int32Array([0, 1, 0]), new Int32Array([0, -1, 0]),
    new Int32Array([0, 0, 1]),
    new Int32Array([0, 0, -1]),
    new Int32Array([1, 1, 0]),
    new Int32Array([1, -1, 0]),
    new Int32Array([-1, 1, 0]),
    new Int32Array([-1, -1, 0]),
    new Int32Array([1, 0, 1]),
    new Int32Array([1, 0, -1]),
    new Int32Array([-1, 0, 1]),
    new Int32Array([-1, 0, -1]),
    new Int32Array([0, 1, 1]),
    new Int32Array([0, 1, -1]),
    new Int32Array([0, -1, 1]),
    new Int32Array([0, -1, -1]),
    new Int32Array([1, 1, 1]),
    new Int32Array([1, 1, -1]),
    new Int32Array([1, -1, 1]),
    new Int32Array([-1, 1, 1]),
    new Int32Array([1, -1, -1]),
    new Int32Array([-1, -1, 1]),
    new Int32Array([-1, 1, -1]),
    new Int32Array([-1, -1, -1])];

    var origextent;

    var inOrigExtent = function (x, y, z) {
        if (x < origextent[0][0] || x > origextent[1][0])
            return false;
        if (y < origextent[0][1] || y > origextent[1][1])
            return false;
        if (z < origextent[0][2] || z > origextent[1][2])
            return false;
        return true;
    };

    this.getFacesAndVertices = function (atomlist) {
        var atomsToShow = {};
        var i, il;
        for (i = 0, il = atomlist.length; i < il; i++)
            atomsToShow[atomlist[i]] = true;
        var vertices = verts;
        for (i = 0, il = vertices.length; i < il; i++) {
            vertices[i].x = vertices[i].x / scaleFactor - ptranx;
            vertices[i].y = vertices[i].y / scaleFactor - ptrany;
            vertices[i].z = vertices[i].z / scaleFactor - ptranz;
        }

        var finalfaces = [];
        for (i = 0, il = faces.length; i < il; i += 3) {
            //var f = faces[i];
            var fa = faces[i], fb = faces[i + 1], fc = faces[i + 2];
            var a = vertices[fa]['atomid'], b = vertices[fb]['atomid'], c = vertices[fc]['atomid'];

            // must be a unique face for each atom
            var which = a;
            if (b < which)
                which = b;
            if (c < which)
                which = c;
            if (!atomsToShow[which]) {
                continue;
            }
            var av = vertices[faces[i]];
            var bv = vertices[faces[i + 1]];
            var cv = vertices[faces[i + 2]];

            if (fa !== fb && fb !== fc && fa !== fc) {
                //finalfaces.push(fa);
                //finalfaces.push(fb);
                //finalfaces.push(fc);

                // !!! different between 3Dmol and iCn3D
                finalfaces.push({ "a": fa, "b": fb, "c": fc });
            }

        }

        //try to help the garbage collector
        vpBits = null; // uint8 array of bitmasks
        vpDistance = null; // floatarray
        vpAtomID = null; // intarray

        return {
            'vertices': vertices,
            'faces': finalfaces
        };
    };


    this.initparm = function (extent, btype, volume) {
        // !!! different between 3Dmol and iCn3D
        //if(volume > 1000000) //heuristical decrease resolution to avoid large memory consumption
        //    scaleFactor = defaultScaleFactor/2;

        var margin = (1 / scaleFactor) * 5.5; // need margin to avoid
        // boundary/round off effects
        origextent = extent;
        pminx = extent[0][0]; pmaxx = extent[1][0];
        pminy = extent[0][1]; pmaxy = extent[1][1];
        pminz = extent[0][2]; pmaxz = extent[1][2];

        if (!btype) {
            pminx -= margin;
            pminy -= margin;
            pminz -= margin;
            pmaxx += margin;
            pmaxy += margin;
            pmaxz += margin;
        } else {
            pminx -= probeRadius + margin;
            pminy -= probeRadius + margin;
            pminz -= probeRadius + margin;
            pmaxx += probeRadius + margin;
            pmaxy += probeRadius + margin;
            pmaxz += probeRadius + margin;
        }

        pminx = Math.floor(pminx * scaleFactor) / scaleFactor;
        pminy = Math.floor(pminy * scaleFactor) / scaleFactor;
        pminz = Math.floor(pminz * scaleFactor) / scaleFactor;
        pmaxx = Math.ceil(pmaxx * scaleFactor) / scaleFactor;
        pmaxy = Math.ceil(pmaxy * scaleFactor) / scaleFactor;
        pmaxz = Math.ceil(pmaxz * scaleFactor) / scaleFactor;

        ptranx = -pminx;
        ptrany = -pminy;
        ptranz = -pminz;

        // !!! different between 3Dmol and iCn3D
        // copied from surface.js from iview
        var boxLength = 128;
        scaleFactor = pmaxx - pminx;
        if ((pmaxy - pminy) > scaleFactor) scaleFactor = pmaxy - pminy;
        if ((pmaxz - pminz) > scaleFactor) scaleFactor = pmaxz - pminz;
        scaleFactor = (boxLength - 1.0) / scaleFactor;

        boxLength = Math.floor(boxLength * defaultScaleFactor / scaleFactor);
        scaleFactor = defaultScaleFactor;
        //var threshbox = 180; // maximum possible boxsize
        if (boxLength > threshbox) {
            var sfthresh = threshbox / boxLength;
            boxLength = Math.floor(threshbox);
            scaleFactor = scaleFactor * sfthresh;
        }
        // end of surface.js part

        pLength = Math.ceil(scaleFactor * (pmaxx - pminx)) + 1;
        pWidth = Math.ceil(scaleFactor * (pmaxy - pminy)) + 1;
        pHeight = Math.ceil(scaleFactor * (pmaxz - pminz)) + 1;

        this.boundingatom(btype);
        cutRadius = probeRadius * scaleFactor;

        vpBits = new Uint8Array(pLength * pWidth * pHeight);
        vpDistance = new Float64Array(pLength * pWidth * pHeight); // float 32
        // doesn't
        // play
        // nicely
        // with
        // native
        // floats
        vpAtomID = new Int32Array(pLength * pWidth * pHeight);
        //console.log("Box size: ", pLength, pWidth, pHeight, vpBits.length);
    };

    this.boundingatom = function (btype) {
        var tradius = [];
        var txz, tdept, sradius, idx;
        flagradius = btype;

        for (var i in vdwRadii) {
            if (!vdwRadii.hasOwnProperty(i))
                continue;
            var r = vdwRadii[i];
            if (!btype)
                tradius[i] = r * scaleFactor + 0.5;
            else
                tradius[i] = (r + probeRadius) * scaleFactor + 0.5;

            sradius = tradius[i] * tradius[i];
            widxz[i] = Math.floor(tradius[i]) + 1;
            depty[i] = new Int32Array(widxz[i] * widxz[i]);
            indx = 0;
            for (j = 0; j < widxz[i]; j++) {
                for (k = 0; k < widxz[i]; k++) {
                    txz = j * j + k * k;
                    if (txz > sradius)
                        depty[i][indx] = -1; // outside
                    else {
                        tdept = Math.sqrt(sradius - txz);
                        depty[i][indx] = Math.floor(tdept);
                    }
                    indx++;
                }
            }
        }
    };

    this.fillvoxels = function (atoms, atomlist) { // (int seqinit,int
        // seqterm,bool
        // atomtype,atom*
        // proseq,bool bcolor)
        var i, il;
        for (i = 0, il = vpBits.length; i < il; i++) {
            vpBits[i] = 0;
            vpDistance[i] = -1.0;
            vpAtomID[i] = -1;
        }

        for (i in atomlist) {
            var atom = atoms[atomlist[i]];
            if (atom === undefined)
                continue;
            this.fillAtom(atom, atoms);
        }

        for (i = 0, il = vpBits.length; i < il; i++)
            if (vpBits[i] & INOUT)
                vpBits[i] |= ISDONE;

    };


    this.fillAtom = function (atom, atoms) {
        var cx, cy, cz, ox, oy, oz, mi, mj, mk, i, j, k, si, sj, sk;
        var ii, jj, kk, n;
        //cx = Math.floor(0.5 + scaleFactor * (atom.x + ptranx));
        //cy = Math.floor(0.5 + scaleFactor * (atom.y + ptrany));
        //cz = Math.floor(0.5 + scaleFactor * (atom.z + ptranz));

        // !!! different between 3Dmol and iCn3D
        cx = Math.floor(0.5 + scaleFactor * (atom.coord.x + ptranx));
        cy = Math.floor(0.5 + scaleFactor * (atom.coord.y + ptrany));
        cz = Math.floor(0.5 + scaleFactor * (atom.coord.z + ptranz));

        var at = getVDWIndex(atom);
        var nind = 0;
        var cnt = 0;
        var pWH = pWidth * pHeight;

        for (i = 0, n = widxz[at]; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (depty[at][nind] != -1) {
                    for (ii = -1; ii < 2; ii++) {
                        for (jj = -1; jj < 2; jj++) {
                            for (kk = -1; kk < 2; kk++) {
                                if (ii !== 0 && jj !== 0 && kk !== 0) {
                                    mi = ii * i;
                                    mk = kk * j;
                                    for (k = 0; k <= depty[at][nind]; k++) {
                                        mj = k * jj;
                                        si = cx + mi;
                                        sj = cy + mj;
                                        sk = cz + mk;
                                        if (si < 0 || sj < 0 ||
                                            sk < 0 ||
                                            si >= pLength ||
                                            sj >= pWidth ||
                                            sk >= pHeight)
                                            continue;
                                        var index = si * pWH + sj * pHeight + sk;

                                        if (!(vpBits[index] & INOUT)) {
                                            vpBits[index] |= INOUT;
                                            vpAtomID[index] = atom.serial;
                                        } else {
                                            var atom2 = atoms[vpAtomID[index]];
                                            if (atom2.serial != atom.serial) {
                                                ox = cx + mi - Math.floor(0.5 + scaleFactor *
                                                    (atom2.x + ptranx));
                                                oy = cy + mj - Math.floor(0.5 + scaleFactor *
                                                    (atom2.y + ptrany));
                                                oz = cz + mk - Math.floor(0.5 + scaleFactor *
                                                    (atom2.z + ptranz));
                                                if (mi * mi + mj * mj + mk * mk < ox *
                                                    ox + oy * oy + oz * oz)
                                                    vpAtomID[index] = atom.serial;
                                            }
                                        }

                                    }// k
                                }// if
                            }// kk
                        }// jj
                    }// ii
                }// if
                nind++;
            }// j
        }// i
    };

    this.fillvoxelswaals = function (atoms, atomlist) {
        var i, il;
        for (i = 0, il = vpBits.length; i < il; i++)
            vpBits[i] &= ~ISDONE; // not isdone

        for (i in atomlist) {
            var atom = atoms[atomlist[i]];
            if (atom === undefined)
                continue;

            this.fillAtomWaals(atom, atoms);
        }
    };

    this.fillAtomWaals = function (atom, atoms) {
        var cx, cy, cz, ox, oy, oz, nind = 0;
        var mi, mj, mk, si, sj, sk, i, j, k, ii, jj, kk, n;
        //cx = Math.floor(0.5 + scaleFactor * (atom.x + ptranx));
        //cy = Math.floor(0.5 + scaleFactor * (atom.y + ptrany));
        //cz = Math.floor(0.5 + scaleFactor * (atom.z + ptranz));

        // !!! different between 3Dmol and iCn3D
        cx = Math.floor(0.5 + scaleFactor * (atom.coord.x + ptranx));
        cy = Math.floor(0.5 + scaleFactor * (atom.coord.y + ptrany));
        cz = Math.floor(0.5 + scaleFactor * (atom.coord.z + ptranz));

        var at = getVDWIndex(atom);
        var pWH = pWidth * pHeight;
        for (i = 0, n = widxz[at]; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (depty[at][nind] != -1) {
                    for (ii = -1; ii < 2; ii++) {
                        for (jj = -1; jj < 2; jj++) {
                            for (kk = -1; kk < 2; kk++) {
                                if (ii !== 0 && jj !== 0 && kk !== 0) {
                                    mi = ii * i;
                                    mk = kk * j;
                                    for (k = 0; k <= depty[at][nind]; k++) {
                                        mj = k * jj;
                                        si = cx + mi;
                                        sj = cy + mj;
                                        sk = cz + mk;
                                        if (si < 0 || sj < 0 ||
                                            sk < 0 ||
                                            si >= pLength ||
                                            sj >= pWidth ||
                                            sk >= pHeight)
                                            continue;
                                        var index = si * pWH + sj * pHeight + sk;
                                        if (!(vpBits[index] & ISDONE)) {
                                            vpBits[index] |= ISDONE;
                                            vpAtomID[index] = atom.serial;
                                        } else {
                                            var atom2 = atoms[vpAtomID[index]];
                                            if (atom2.serial != atom.serial) {
                                                ox = cx + mi - Math.floor(0.5 + scaleFactor *
                                                    (atom2.x + ptranx));
                                                oy = cy + mj - Math.floor(0.5 + scaleFactor *
                                                    (atom2.y + ptrany));
                                                oz = cz + mk - Math.floor(0.5 + scaleFactor *
                                                    (atom2.z + ptranz));
                                                if (mi * mi + mj * mj + mk * mk < ox *
                                                    ox + oy * oy + oz * oz)
                                                    vpAtomID[index] = atom.serial;
                                            }
                                        }
                                    }// k
                                }// if
                            }// kk
                        }// jj
                    }// ii
                }// if
                nind++;
            }// j
        }// i
    };

    this.buildboundary = function () {
        var pWH = pWidth * pHeight;
        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pHeight; j++) {
                for (k = 0; k < pWidth; k++) {
                    var index = i * pWH + k * pHeight + j;
                    if (vpBits[index] & INOUT) {
                        var flagbound = false;
                        var ii = 0;
                        while (ii < 26) {
                            var ti = i + nb[ii][0], tj = j + nb[ii][2], tk = k +
                                nb[ii][1];
                            if (ti > -1 &&
                                ti < pLength &&
                                tk > -1 &&
                                tk < pWidth &&
                                tj > -1 &&
                                tj < pHeight &&
                                !(vpBits[ti * pWH + tk * pHeight + tj] & INOUT)) {
                                vpBits[index] |= ISBOUND;
                                break;
                            } else
                                ii++;
                        }
                    }
                }
            }
        }
    };

    // a little class for 3d array, should really generalize this and
    // use throughout...
    var PointGrid = function (length, width, height) {
        // the standard says this is zero initialized
        var data = new Int32Array(length * width * height * 3);

        // set position x,y,z to pt, which has ix,iy,and iz
        this.set = function (x, y, z, pt) {
            var index = ((((x * width) + y) * height) + z) * 3;
            data[index] = pt.ix;
            data[index + 1] = pt.iy;
            data[index + 2] = pt.iz;
        };

        // return point at x,y,z
        this.get = function (x, y, z) {
            var index = ((((x * width) + y) * height) + z) * 3;
            return {
                ix: data[index],
                iy: data[index + 1],
                iz: data[index + 2]
            };
        };
    };

    this.fastdistancemap = function () {
        var eliminate = 0;
        var certificate;
        var i, j, k, n;

        var boundPoint = new PointGrid(pLength, pWidth, pHeight);
        var pWH = pWidth * pHeight;
        var cutRSq = cutRadius * cutRadius;

        var inarray = [];
        var outarray = [];

        var index;

        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pWidth; j++) {
                for (k = 0; k < pHeight; k++) {
                    index = i * pWH + j * pHeight + k;
                    vpBits[index] &= ~ISDONE; // isdone = false
                    if (vpBits[index] & INOUT) {
                        if (vpBits[index] & ISBOUND) {
                            var triple = {
                                ix: i,
                                iy: j,
                                iz: k
                            };
                            boundPoint.set(i, j, k, triple);
                            inarray.push(triple);
                            vpDistance[index] = 0;
                            vpBits[index] |= ISDONE;
                            vpBits[index] &= ~ISBOUND;
                        }
                    }
                }
            }
        }

        do {
            outarray = this.fastoneshell(inarray, boundPoint);
            inarray = [];
            for (i = 0, n = outarray.length; i < n; i++) {
                index = pWH * outarray[i].ix + pHeight *
                    outarray[i].iy + outarray[i].iz;
                vpBits[index] &= ~ISBOUND;
                if (vpDistance[index] <= 1.0404 * cutRSq) {
                    inarray.push({
                        ix: outarray[i].ix,
                        iy: outarray[i].iy,
                        iz: outarray[i].iz
                    });
                }
            }
        } while (inarray.length !== 0);

        inarray = [];
        outarray = [];
        boundPoint = null;

        var cutsf = scaleFactor - 0.5;
        if (cutsf < 0)
            cutsf = 0;
        var cutoff = cutRSq - 0.50 / (0.1 + cutsf);
        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pWidth; j++) {
                for (k = 0; k < pHeight; k++) {
                    index = i * pWH + j * pHeight + k;
                    vpBits[index] &= ~ISBOUND;
                    // ses solid
                    if (vpBits[index] & INOUT) {
                        if (!(vpBits[index] & ISDONE) ||
                            ((vpBits[index] & ISDONE) && vpDistance[index] >= cutoff)) {
                            vpBits[index] |= ISBOUND;
                        }
                    }
                }
            }
        }

    };

    this.fastoneshell = function (inarray, boundPoint) { // (int* innum,int
        // *allocout,voxel2
        // ***boundPoint, int*
        // outnum, int *elimi)
        var tx, ty, tz;
        var dx, dy, dz;
        var i, j, n;
        var square;
        var bp, index;
        var outarray = [];
        if (inarray.length === 0)
            return outarray;

        tnv = {
            ix: -1,
            iy: -1,
            iz: -1
        };
        var pWH = pWidth * pHeight;
        for (i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for (j = 0; j < 6; j++) {
                tnv.ix = tx + nb[j][0];
                tnv.iy = ty + nb[j][1];
                tnv.iz = tz + nb[j][2];

                if (tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
                    tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {

                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray.push({
                            ix: tnv.ix,
                            iy: tnv.iy,
                            iz: tnv.iz
                        });
                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if (square < vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);

                            vpDistance[index] = square;
                            if (!(vpBits[index] & ISBOUND)) {
                                vpBits[index] |= ISBOUND;
                                outarray.push({
                                    ix: tnv.ix,
                                    iy: tnv.iy,
                                    iz: tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        // console.log("part1", positout);

        for (i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for (j = 6; j < 18; j++) {
                tnv.ix = tx + nb[j][0];
                tnv.iy = ty + nb[j][1];
                tnv.iz = tz + nb[j][2];

                if (tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
                    tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {
                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray.push({
                            ix: tnv.ix,
                            iy: tnv.iy,
                            iz: tnv.iz
                        });
                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if (square < vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);
                            vpDistance[index] = square;
                            if (!(vpBits[index] & ISBOUND)) {
                                vpBits[index] |= ISBOUND;
                                outarray.push({
                                    ix: tnv.ix,
                                    iy: tnv.iy,
                                    iz: tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        // console.log("part2", positout);

        for (i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for (j = 18; j < 26; j++) {
                tnv.ix = tx + nb[j][0];
                tnv.iy = ty + nb[j][1];
                tnv.iz = tz + nb[j][2];

                if (tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
                    tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {
                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray.push({
                            ix: tnv.ix,
                            iy: tnv.iy,
                            iz: tnv.iz
                        });
                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if (square < vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);

                            vpDistance[index] = square;
                            if (!(vpBits[index] & ISBOUND)) {
                                vpBits[index] |= ISBOUND;
                                outarray.push({
                                    ix: tnv.ix,
                                    iy: tnv.iy,
                                    iz: tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        // console.log("part3", positout);
        return outarray;
    };

    this.marchingcubeinit = function (stype) {
        for (var i = 0, lim = vpBits.length; i < lim; i++) {
            if (stype == 1) {// vdw
                vpBits[i] &= ~ISBOUND;
            } else if (stype == 4) { // ses
                vpBits[i] &= ~ISDONE;
                if (vpBits[i] & ISBOUND)
                    vpBits[i] |= ISDONE;
                vpBits[i] &= ~ISBOUND;
            } else if (stype == 2) {// after vdw
                if ((vpBits[i] & ISBOUND) && (vpBits[i] & ISDONE))
                    vpBits[i] &= ~ISBOUND;
                else if ((vpBits[i] & ISBOUND) && !(vpBits[i] & ISDONE))
                    vpBits[i] |= ISDONE;
            } else if (stype == 3) { // sas
                vpBits[i] &= ~ISBOUND;
            }
        }
    };

    // this code allows me to empirically prune the marching cubes code tables
    // to more efficiently handle discrete data
    var counter = function () {
        var data = Array(256);
        for (var i = 0; i < 256; i++)
            data[i] = [];

        this.incrementUsed = function (i, j) {
            if (typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used: 0,
                    unused: 0
                };
            data[i][j].used++;
        };

        this.incrementUnused = function (i, j) {
            if (typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used: 0,
                    unused: 0
                };
            data[i][j].unused++;

        };

        var redoTable = function (triTable) {
            var str = "[";
            for (var i = 0; i < triTable.length; i++) {
                var code = 0;
                var table = triTable[i];
                for (var j = 0; j < table.length; j++) {
                    code |= (1 << (table[j]));
                }
                str += "0x" + code.toString(16) + ", ";
            }
            str += "]";
            //console.log(str);
        };

        this.print = function () {

            var table = MarchingCube.triTable;
            var str;
            var newtable = [];
            for (var i = 0; i < table.length; i++) {
                var newarr = [];
                for (var j = 0; j < table[i].length; j += 3) {
                    var k = j / 3;
                    if (typeof data[i][k] === 'undefined' || !data[i][k].unused) {
                        newarr.push(table[i][j]);
                        newarr.push(table[i][j + 1]);
                        newarr.push(table[i][j + 2]);
                    }
                    if (typeof data[i][k] === 'undefined')
                        console.log("undef " + i + "," + k);
                }
                newtable.push(newarr);
            }
            //console.log(JSON.stringify(newtable));
            redoTable(newtable);
        };
    };

    this.marchingcube = function (stype) {
        this.marchingcubeinit(stype);
        verts = []; faces = [];
        $3Dmol.MarchingCube.march(vpBits, verts, faces, {
            smooth: 1,
            nX: pLength,
            nY: pWidth,
            nZ: pHeight
        });

        var pWH = pWidth * pHeight;
        for (var i = 0, vlen = verts.length; i < vlen; i++) {
            verts[i]['atomid'] = vpAtomID[verts[i].x * pWH + pHeight *
                verts[i].y + verts[i].z];
        }

        $3Dmol.MarchingCube.laplacianSmooth(1, verts, faces);

    };


};

/*! setupsurface.js from SurfaceWorker.js
 * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */

$3Dmol.SetupSurface = function (data) {
    var me = this;

    //var $3Dmol = $3Dmol || {};

    //var vol = $3Dmol.volume(data.extent);
    var vol = undefined;

    var threshbox = data.threshbox; // maximum possible boxsize, default 180

    var ps = new $3Dmol.ProteinSurface(threshbox);
    ps.initparm(data.extent, (data.type === 1) ? false : true, vol);

    ps.fillvoxels(data.allatoms, data.extendedAtoms);

    ps.buildboundary();

    //if (data.type === 4 || data.type === 2) {
    if (data.type === 2) {
        ps.fastdistancemap();
        ps.boundingatom(false);
        ps.fillvoxelswaals(data.allatoms, data.extendedAtoms);
    }

    ps.marchingcube(data.type);

    ps.vpBits = null; // uint8 array of bitmasks
    ps.vpDistance = null; // floatarray of _squared_ distances
    ps.vpAtomID = null; // intarray
    ps.faces = null;
    ps.verts = null;

    return ps.getFacesAndVertices(data.atomsToShow);
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createSurfaceRepresentation = function (atoms, type, wireframe, opacity) {
    if (Object.keys(atoms).length == 0) return;

    var geo;

    var extent = this.getExtent(atoms);

    // surface from 3Dmol
    var distance = 5; // consider atom 5 angstrom from the selected atoms

    var extendedAtoms = [];

    if (this.bConsiderNeighbors) {
        extendedAtoms = Object.keys(this.unionHash(atoms, this.getAtomsWithinAtom(this.atoms, atoms, distance)));
    }
    else {
        extendedAtoms = Object.keys(atoms);
    }

    var ps = $3Dmol.SetupSurface({
        extent: extent,
        allatoms: this.atoms,
        atomsToShow: Object.keys(atoms),
        extendedAtoms: extendedAtoms,
        type: type,
        threshbox: this.threshbox
    });

    var verts = ps.vertices;
    var faces = ps.faces;

    var me = this;

    geo = new THREE.Geometry();
    geo.vertices = verts.map(function (v) {
        var r = new THREE.Vector3(v.x, v.y, v.z);
        r.atomid = v.atomid;
        return r;
    });
    geo.faces = faces.map(function (f) {
        //return new THREE.Face3(f.a, f.b, f.c);
        var vertexColors = ['a', 'b', 'c'].map(function (d) {
            var atomid = geo.vertices[f[d]].atomid;
            return me.atoms[atomid].color;
        });

        return new THREE.Face3(f.a, f.b, f.c, undefined, vertexColors);
    });

    // remove the reference
    ps = null;
    verts = null;
    faces = null;

    geo.computeFaceNormals();
    geo.computeVertexNormals(false);

    geo.colorsNeedUpdate = true;

    /*
        geo.faces.forEach(function (f) {
            f.vertexColors = ['a', 'b', 'c' ].map(function (d) {
                var atomid = geo.vertices[f[d]].atomid;
                return me.atoms[atomid].color;
            });
        });
    */

    geo.type = 'Surface'; // to be recognized in vrml.js for 3D printing

    /*
        var mesh = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ overdraw: me.overdraw,
            vertexColors: THREE.VertexColors,
            wireframe: wireframe,
            opacity: opacity,
            transparent: true,
        }));
    */
    var mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({
        overdraw: me.overdraw,
        specular: this.frac,
        shininess: 10, //30,
        emissive: 0x000000,
        vertexColors: THREE.VertexColors,
        wireframe: wireframe,
        opacity: opacity,
        transparent: true,
        side: THREE.DoubleSide
    }));

    me.mdl.add(mesh);

    this.prevSurfaces.push(mesh);

    // remove the reference
    geo = null;

    // do not add surface to raycasting objects for pk
};

// http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
iCn3D.prototype.buildAxes = function (radius) {
    var axes = new THREE.Object3D();

    axes.add(this.createSingleLine(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0 + radius, 0, 0), 0xFF0000, false, 0.5)); // +X
    axes.add(this.createSingleLine(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0 - radius, 0, 0), 0x800000, true, 0.5)); // -X

    axes.add(this.createSingleLine(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0 + radius, 0), 0x00FF00, false, 0.5)); // +Y
    axes.add(this.createSingleLine(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0 - radius, 0), 0x008000, true, 0.5)); // -Y

    axes.add(this.createSingleLine(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0 + radius), 0x0000FF, false, 0.5)); // +Z
    axes.add(this.createSingleLine(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0 - radius), 0x000080, true, 0.5)); // -Z

    this.scene.add(axes);
};

iCn3D.prototype.createLines = function (lines) { // show extra lines, not used for pk, so no this.objects
    if (lines !== undefined) {
        for (var name in lines) {
            var lineArray = lines[name];

            for (var i = 0, il = lineArray.length; i < il; ++i) {
                var line = lineArray[i];

                var p1 = line.position1;
                var p2 = line.position2;

                var dashed = (line.dashed) ? line.dashed : false;
                var dashSize = 0.3;

                //this.mdl.add(this.createSingleLine( p1, p2, colorHex, dashed, dashSize ));

                var radius = this.lineRadius;

                var colorStr = '#' + line.color.replace(/\#/g, '');

                var color = new THREE.Color(colorStr);

                if (!dashed) {
                    if (name == 'stabilizer') {
                        this.createBrick(p1, p2, radius, color);
                    }
                    else {
                        this.createCylinder(p1, p2, radius, color);
                    }
                }
                else {
                    var distance = p1.distanceTo(p2);

                    var nsteps = parseInt(distance / dashSize);
                    var step = p2.clone().sub(p1).multiplyScalar(dashSize / distance);

                    var start, end;
                    for (var j = 0; j < nsteps; ++j) {
                        if (j % 2 == 1) {
                            start = p1.clone().add(step.clone().multiplyScalar(j));
                            end = p1.clone().add(step.clone().multiplyScalar(j + 1));

                            if (name == 'stabilizer') {
                                this.createBrick(start, end, radius, color);
                            }
                            else {
                                this.createCylinder(start, end, radius, color);
                            }
                        }
                    }
                }
            }
        }
    }

    // do not add the artificial lines to raycasting objects
};

iCn3D.prototype.createBrick = function (p0, p1, radius, color) {
    var cylinderGeometry = new THREE.CylinderGeometry(1, 1, 1, 4, 1);

    var mesh = new THREE.Mesh(cylinderGeometry, new THREE.MeshPhongMaterial({ overdraw: this.overdraw, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));

    mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
    mesh.matrixAutoUpdate = false;
    mesh.lookAt(p0);
    mesh.updateMatrix();

    mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius, p0.distanceTo(p1))).multiply(new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

    this.mdl.add(mesh);
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.applyPrevColor = function () {
    for (var i in this.atoms) {
        var atom = this.atoms[i];
        atom.color = this.atomPrevColors[i];
    }
};

iCn3D.prototype.applyChemicalbindingOptions = function (options) {
    if (options === undefined) options = this.opts;

    // display mode
    if (options.chemicalbinding === 'show') {
        var startAtoms;
        if (this.chemicals !== undefined && Object.keys(this.chemicals).length > 0) { // show chemical-protein interaction
            startAtoms = this.hash2Atoms(this.chemicals);
        }

        // find atoms in chainid1, which interact with chainid2
        var radius = 4;

        if (startAtoms !== undefined) {
            var targetAtoms = this.getAtomsWithinAtom(this.atoms, startAtoms, radius);

            var residueHash = {};

            // draw sidec for these residues
            for (var i in targetAtoms) {
                if (startAtoms.hasOwnProperty(i)) continue;
                residueHash[this.atoms[i].structure + '_' + this.atoms[i].chain + '_' + this.atoms[i].resi] = 1;
            }

            var residueArray = Object.keys(residueHash);
            for (var i = 0, il = residueArray.length; i < il; ++i) {
                for (var j in this.residues[residueArray[i]]) {
                    // all atoms should be shown for hbonds
                    this.atoms[j].style2 = 'stick';
                }
            }

            // show hydrogens
            var threshold = 3.5;
            this.opts["hbonds"] = "yes";
            //this.opts["water"] = "dot";

            if (Object.keys(targetAtoms).length > 0) {
                this.calculateChemicalHbonds(startAtoms, targetAtoms, parseFloat(threshold));
            }

            // zoom in on the atoms
            this.zoominSelection(this.unionHash(startAtoms, targetAtoms));

            //this.opts['fog'] = 'yes';
        }
    }
    else if (options.chemicalbinding === 'hide') {
        // truen off hdonds
        this.hideHbonds();

        // center on the atoms
        this.zoominSelection(this.atoms);

        //this.opts['fog'] = 'no';
    }
};

iCn3D.prototype.hideHbonds = function () {
    this.opts["hbonds"] = "no";
    if (this.lines === undefined) this.lines = {};
    this.lines['hbond'] = [];
    this.hbondpnts = [];

    for (var i in this.atoms) {
        this.atoms[i].style2 = 'nothing';
    }

    for (var i in this.sidec) {
        this.atoms[i].style2 = this.opts["sidec"];
    }

    for (var i in this.water) {
        this.atoms[i].style = this.opts["water"];
    }
};

iCn3D.prototype.applySsbondsOptions = function (options) {
    if (options === undefined) options = this.opts;

    if (options.ssbonds.toLowerCase() === 'yes' && this.ssbondpnts !== undefined) {
        var color = '#FFFF00';
        var colorObj = new THREE.Color(0xFFFF00);

        var structureArray = Object.keys(this.structures);
        var start, end;

        if (this.bAlternate) {
            start = this.ALTERNATE_STRUCTURE;
            end = this.ALTERNATE_STRUCTURE + 1;
        }
        else {
            start = 0;
            end = structureArray.length;
        }

        this.lines['ssbond'] = [];

        for (var s = start, sl = end; s < sl; ++s) {
            var structure = structureArray[s];

            if (this.ssbondpnts[structure] === undefined) continue;

            for (var i = 0, lim = Math.floor(this.ssbondpnts[structure].length / 2); i < lim; i++) {
                var res1 = this.ssbondpnts[structure][2 * i], res2 = this.ssbondpnts[structure][2 * i + 1];
                var serial1, serial2;

                var line = {};
                line.color = color;
                line.dashed = true;

                var bFound = false;
                for (var j in this.residues[res1]) {
                    if (this.atoms[j].name === 'SG') {
                        serial1 = this.atoms[j].serial;
                        line.position1 = this.atoms[j].coord;
                        bFound = true;
                        break;
                    }
                }

                if (!bFound) {
                    for (var j in this.residues[res1]) {
                        if (this.atoms[j].name === 'CA') {
                            line.position1 = this.atoms[j].coord;
                            bFound = true;
                            break;
                        }
                    }
                }

                bFound = false;
                for (var j in this.residues[res2]) {
                    if (this.atoms[j].name === 'SG') {
                        serial2 = this.atoms[j].serial;
                        line.position2 = this.atoms[j].coord;
                        bFound = true;
                        break;
                    }
                }

                if (!bFound) {
                    for (var j in this.residues[res2]) {
                        if (this.atoms[j].name === 'CA') {
                            line.position2 = this.atoms[j].coord;
                            bFound = true;
                            break;
                        }
                    }
                }

                if (this.atoms[serial1].ids !== undefined) { // mmdb id asinput
                    // remove the originaldisulfide bonds
                    var pos = this.atoms[serial1].bonds.indexOf(serial2);
                    var array1, array2;
                    if (pos != -1) {
                        array1 = this.atoms[serial1].bonds.slice(0, pos);
                        array2 = this.atoms[serial1].bonds.slice(pos + 1);

                        this.atoms[serial1].bonds = array1.concat(array2);
                    }

                    pos = this.atoms[serial2].bonds.indexOf(serial1);
                    if (pos != -1) {
                        array1 = this.atoms[serial2].bonds.slice(0, pos);
                        array2 = this.atoms[serial2].bonds.slice(pos + 1);

                        this.atoms[serial2].bonds = array1.concat(array2);
                    }
                }

                //if(this.lines['ssbond'] === undefined) this.lines['ssbond'] = [];
                this.lines['ssbond'].push(line);

                // create bonds for disulfide bonds
                //this.createCylinder(line.position1, line.position2, this.cylinderRadius * 0.5, colorObj);
                this.createCylinder(line.position1, line.position2, this.cylinderRadius, colorObj);

                // show ball and stick for these two residues
                var residueAtoms = this.unionHash(this.residues[res1], this.residues[res2]);

                // show side chains for the selected atoms
                var atoms = this.intHash(residueAtoms, this.sidec);
                var calpha_atoms = this.intHash(residueAtoms, this.calphas);
                // include calphas
                atoms = this.unionHash(atoms, calpha_atoms);

                // draw sidec separatedly
                for (var j in atoms) {
                    this.atoms[j].style2 = 'stick';
                }
            } // for(var i = 0,
        } // for(var s = 0,
    } // if (options.ssbonds.toLowerCase() === 'yes'
};

iCn3D.prototype.applySurfaceOptions = function (options) {
    if (options === undefined) options = this.opts;

    //switch (options.wireframe.toLowerCase()) {
    switch (options.wireframe) {
        case 'yes':
            options.wireframe = true;
            break;
        case 'no':
            options.wireframe = false;
            break;
    }

    options.opacity = parseFloat(options.opacity);

    var atoms, currAtoms;

    // only show the surface for atoms which are displaying
    atoms = this.intHash(this.dAtoms, this.hAtoms);

    currAtoms = this.hash2Atoms(atoms);

    switch (options.surface.toLowerCase()) {
        case 'van der waals surface':
            this.createSurfaceRepresentation(currAtoms, 1, options.wireframe, options.opacity);
            break;
        //            case 'solvent excluded surface':
        //                this.createSurfaceRepresentation(currAtoms, 2, options.wireframe, options.opacity);
        //                break;
        case 'solvent accessible surface':
            this.createSurfaceRepresentation(currAtoms, 3, options.wireframe, options.opacity);
            break;
        case 'molecular surface':
            this.createSurfaceRepresentation(currAtoms, 2, options.wireframe, options.opacity);
            break;
        case 'van der waals surface with context':
            this.createSurfaceRepresentation(currAtoms, 1, options.wireframe, options.opacity);
            break;
        case 'solvent accessible surface with context':
            this.createSurfaceRepresentation(currAtoms, 3, options.wireframe, options.opacity);
            break;
        case 'molecular surface with context':
            this.createSurfaceRepresentation(currAtoms, 2, options.wireframe, options.opacity);
            break;
        case 'nothing':
            // remove surfaces
            this.removeSurfaces();
            break;
    }
};

iCn3D.prototype.setFog = function () {
    var background = this.backgroundColors[this.opts.background.toLowerCase()];

    // apply fog
    if (this.opts['fog'] === 'yes') {
        if (this.opts['camera'] === 'perspective') {        //perspective, orthographic
            //this.scene.fog = new THREE.Fog(background, this.cam_z, this.cam_z + 0.5 * this.maxD);
            //this.scene.fog = new THREE.Fog(background, 2 * this.maxD, 2.5 * this.maxD);
            this.scene.fog = new THREE.Fog(background, 2 * this.maxD, 3 * this.maxD);
        }
        else if (this.opts['camera'] === 'orthographic') {
            this.scene.fog = new THREE.FogExp2(background, 2);
            //this.scene.fog.near = this.cam_z;
            //this.scene.fog.far = this.cam_z + 0.5 * this.maxD;
            this.scene.fog.near = 2 * this.maxD;
            //this.scene.fog.far = 2.5 * this.maxD;
            this.scene.fog.far = 3 * this.maxD;
        }
    }
    else {
        this.scene.fog = undefined;
    }
};

// change the display atom when alternating
iCn3D.prototype.alternateStructures = function () {
    this.dAtoms = {};

    var hAtomsCount = Object.keys(this.hAtoms).length;
    var allAtomsCount = Object.keys(this.atoms).length;

    var moleculeArray = Object.keys(this.structures);
    for (var i = 0, il = moleculeArray.length; i < il; ++i) {
        var structure = moleculeArray[i];
        if (i > this.ALTERNATE_STRUCTURE || (this.ALTERNATE_STRUCTURE === il - 1 && i === 0)) {
            for (var k in this.structures[structure]) {
                var chain = this.structures[structure][k];
                this.dAtoms = this.unionHash(this.dAtoms, this.chains[chain]);
            }

            this.ALTERNATE_STRUCTURE = i;
            break;
        }
    }

    if (hAtomsCount < allAtomsCount) {
        this.dAtoms = this.intHash(this.dAtoms, this.hAtoms);

        this.bShowHighlight = false;
        this.opts['rotationcenter'] = 'highlight center';
    }

    // also alternating the surfaces
    this.removeSurfaces();
    this.applySurfaceOptions();

    this.draw();

    this.bShowHighlight = true;
    this.opts['rotationcenter'] = 'molecule center';
};

iCn3D.prototype.updateStabilizer = function () {
    this.stabilizerpnts = [];

    if (this.pairArray !== undefined) {
        for (var i = 0, il = this.pairArray.length; i < il; i += 2) {
            var coordI = this.getResidueRepPos(this.pairArray[i]);
            var coordJ = this.getResidueRepPos(this.pairArray[i + 1]);

            this.stabilizerpnts.push(coordI);
            this.stabilizerpnts.push(coordJ);
        }
    }
};

iCn3D.prototype.getResidueRepPos = function (serial) {
    var me = this;
    var atomIn = this.atoms[serial];
    var residueid = atomIn.structure + "_" + atomIn.chain + "_" + atomIn.resi;

    var pos;
    if (!this.proteins.hasOwnProperty(serial) && !this.nucleotides.hasOwnProperty(serial)) { // chemicals or ions
        pos = atomIn.coord;
    }
    else {
        for (var i in this.residues[residueid]) {
            var atom = this.atoms[i];
            if (atom.name === 'N3') { // nucleotide: N3
                pos = this.atoms[i].coord;
                break;
            }
            else if (atom.name === 'CA' && atom.ss == 'coil') { // protein coil: CA
                pos = this.atoms[i].coord;
                break;
            }
            else if (atom.name === 'CA' && (atom.ss == 'helix' || atom.ss == 'sheet')) { // protein secondary: CA
                pos = (this.atoms[i].coord2 !== undefined) ? this.atoms[i].coord2 : this.atoms[i].coord;
                break;
            }
        }
    }

    if (pos === undefined) pos = atomIn.coord;

    return pos;
};

iCn3D.prototype.applyOtherOptions = function (options) {
    if (options === undefined) options = this.opts;

    //common part options

    // lines
    //if (options.hbonds.toLowerCase() === 'yes' || options.ncbonds.toLowerCase() === 'yes') {
    if (options.hbonds.toLowerCase() === 'yes') {
        var color = '#00FF00';
        var pnts = this.hbondpnts;

        for (var i = 0, lim = Math.floor(pnts.length / 2); i < lim; i++) {
            var line = {};
            line.position1 = pnts[2 * i];
            line.position2 = pnts[2 * i + 1];
            line.color = color;
            line.dashed = true;

            if (this.lines['hbond'] === undefined) this.lines['hbond'] = [];
            this.lines['hbond'].push(line);
        }

        //this.createLines(this.lines);
    }

    if (this.pairArray !== undefined && this.pairArray.length > 0) {
        this.updateStabilizer(); // to update this.stabilizerpnts

        var color = '#FFFFFF';
        var pnts = this.stabilizerpnts;
        this.lines['stabilizer'] = []; // reset
        for (var i = 0, lim = Math.floor(pnts.length / 2); i < lim; i++) {
            var line = {};
            line.position1 = pnts[2 * i];
            line.position2 = pnts[2 * i + 1];
            line.color = color;
            line.dashed = false; // if true, there will be too many cylinders in the dashed lines

            this.lines['stabilizer'].push(line);
        }
    }

    this.createLines(this.lines);

    // surfaces
    if (this.prevSurfaces !== undefined) {
        for (var i = 0, il = this.prevSurfaces.length; i < il; ++i) {
            this.mdl.add(this.prevSurfaces[i]);
        }
    }

    this.applyCenterOptions(options);

    switch (options.axis.toLowerCase()) {
        case 'yes':
            this.axis = true;

            this.buildAxes(this.maxD / 2);

            break;
        case 'no':
            this.axis = false;
            break;
    }
    switch (options.pk.toLowerCase()) {
        case 'atom':
            this.pk = 1;
            break;
        case 'no':
            this.pk = 0;
            break;
        case 'residue':
            this.pk = 2;
            break;
        case 'strand':
            this.pk = 3;
            break;
    }
};

iCn3D.prototype.rebuildScene = function (options) {
    var me = this;
    this.rebuildSceneBase(options);

    if (this.bSkipChemicalbinding === undefined || !this.bSkipChemicalbinding) this.applyChemicalbindingOptions();
    this.bSkipChemicalbinding = true;

    // show disulfide bonds, set side chains
    this.applySsbondsOptions();

    this.applyDisplayOptions(this.opts, this.dAtoms);

    this.applyOtherOptions();

    this.setFog();

    this.setCamera();

    //https://stackoverflow.com/questions/15726560/three-js-raycaster-intersection-empty-when-objects-not-part-of-scene
    me.scene_ghost.updateMatrixWorld(true);
};

iCn3D.prototype.draw = function () {
    var me = this;
    this.rebuildScene();

    // Impostor display using the saved arrays
    if (this.bImpo) {
        this.drawImpostorShader();
    }

    this.applyPrevColor();

    //if(this.bSSOnly) this.drawHelixBrick(this.molid2ss, this.molid2color);

    if (this.biomtMatrices !== undefined && this.biomtMatrices.length > 1) {
        if (this.bAssembly) {
            this.drawSymmetryMates();
        }
        else {
            this.centerSelection();
        }
    }

    // show the hAtoms
    var hAtomsLen = (this.hAtoms !== undefined) ? Object.keys(this.hAtoms).length : 0;

    //if(hAtomsLen > 0 && hAtomsLen < Object.keys(this.atoms).length) {
    if (hAtomsLen > 0 && hAtomsLen < Object.keys(this.dAtoms).length) {
        this.removeHlObjects();
        if (this.bShowHighlight === undefined || this.bShowHighlight) this.addHlObjects();
    }

    if (this.bRender === true) {
        this.applyTransformation(this._zoomFactor, this.mouseChange, this.quaternion);
        this.render();

        // reset to hide the side chain
        //this.opts['sidec'] = 'nothing';
    }

    this.clearImpostors();
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// get hbonds between "molecule" and "chemical"
iCn3D.prototype.calculateChemicalHbonds = function (molecule, chemicals, threshold) {
    if (Object.keys(molecule).length === 0 || Object.keys(chemicals).length === 0) return;

    var atomHbond = {};
    var chain_resi_atom;

    var maxlengthSq = threshold * threshold;

    for (var i in molecule) {
        var atom = molecule[i];

        if (atom.elem === "N" || atom.elem === "O" || atom.elem === "F") { // calculate hydrogen bond
            chain_resi_atom = atom.structure + "_" + atom.chain + "_" + atom.resi + "_" + atom.name;

            atomHbond[chain_resi_atom] = atom;
        }
    } // end of for (var i in molecule) {

    var hbondsAtoms = {};

    for (var i in chemicals) {
        var atom = chemicals[i];

        if (atom.elem === "N" || atom.elem === "O" || atom.elem === "F") { // calculate hydrogen bond
            chain_resi_atom = atom.structure + "_" + atom.chain + "_" + atom.resi + "_" + atom.name;

            for (var j in atomHbond) {
                var xdiff = Math.abs(atom.coord.x - atomHbond[j].coord.x);
                if (xdiff > threshold) continue;

                var ydiff = Math.abs(atom.coord.y - atomHbond[j].coord.y);
                if (ydiff > threshold) continue;

                var zdiff = Math.abs(atom.coord.z - atomHbond[j].coord.z);
                if (zdiff > threshold) continue;

                var dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
                if (dist > maxlengthSq) continue;

                // output hydrogen bonds
                this.hbondpnts.push(atom.coord);
                this.hbondpnts.push(atomHbond[j].coord);

                hbondsAtoms = this.unionHash(hbondsAtoms, this.residues[atom.structure + "_" + atom.chain + "_" + atom.resi]);
                hbondsAtoms = this.unionHash(hbondsAtoms, this.residues[atomHbond[j].structure + "_" + atomHbond[j].chain + "_" + atomHbond[j].resi]);
            } // end of for (var j in atomHbond) {
        }
    } // end of for (var i in chemicals) {

    return hbondsAtoms;
};

iCn3D.prototype.getResiduesFromAtoms = function (atomsHash) {
    var residuesHash = {};
    for (var i in atomsHash) {
        var residueid = this.atoms[i].structure + '_' + this.atoms[i].chain + '_' + this.atoms[i].resi;
        residuesHash[residueid] = 1;
    }

    return residuesHash;
};

iCn3D.prototype.getChainsFromAtoms = function (atomsHash) {
    var chainsHash = {};
    for (var i in atomsHash) {
        var atom = this.atoms[i];
        var chainid = atom.structure + "_" + atom.chain;

        chainsHash[chainid] = 1;
    }

    return chainsHash;
};


iCn3D.prototype.getNeighboringAtoms = function (atomlist, atomlistTarget, distance) {
    var me = this;

    var extent = this.getExtent(atomlistTarget);

    var targetRadiusSq1 = (extent[2][0] - extent[0][0]) * (extent[2][0] - extent[0][0]) + (extent[2][1] - extent[0][1]) * (extent[2][1] - extent[0][1]) + (extent[2][2] - extent[0][2]) * (extent[2][2] - extent[0][2]);
    var targetRadiusSq2 = (extent[2][0] - extent[1][0]) * (extent[2][0] - extent[1][0]) + (extent[2][1] - extent[1][1]) * (extent[2][1] - extent[1][1]) + (extent[2][2] - extent[1][2]) * (extent[2][2] - extent[1][2]);
    var targetRadiusSq = (targetRadiusSq1 > targetRadiusSq2) ? targetRadiusSq1 : targetRadiusSq2;
    var targetRadius = Math.sqrt(targetRadiusSq);

    var maxDistSq = (targetRadius + distance) * (targetRadius + distance);

    var neighbors = {};
    for (var i in atomlist) {
        //var atom = atomlist[i];
        var atom = me.atoms[i];

        // exclude the target atoms
        if (atom.serial in atomlistTarget) continue;

        if (atom.coord.x < extent[0][0] - distance || atom.coord.x > extent[1][0] + distance) continue;
        if (atom.coord.y < extent[0][1] - distance || atom.coord.y > extent[1][1] + distance) continue;
        if (atom.coord.z < extent[0][2] - distance || atom.coord.z > extent[1][2] + distance) continue;

        // only show protein or DNA/RNA
        //if(atom.serial in this.proteins || atom.serial in this.nucleotides) {
        var atomDistSq = (atom.coord.x - extent[2][0]) * (atom.coord.x - extent[2][0]) + (atom.coord.y - extent[2][1]) * (atom.coord.y - extent[2][1]) + (atom.coord.z - extent[2][2]) * (atom.coord.z - extent[2][2]);

        if (atomDistSq < maxDistSq) {
            neighbors[atom.serial] = atom;
        }
        //}
    }

    return neighbors;
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.getAtomsWithinAtom = function (atomlist, atomlistTarget, distance) {
    var me = this;

    var neighbors = this.getNeighboringAtoms(atomlist, atomlistTarget, distance);

    var ret = {};
    for (var i in atomlistTarget) {
        //var oriAtom = atomlistTarget[i];
        var oriAtom = me.atoms[i];
        var radius = this.vdwRadii[oriAtom.elem] || this.defaultRadius;

        for (var j in neighbors) {
            var atom = neighbors[j];

            // exclude the target atoms
            if (atom.serial in atomlistTarget) continue;

            var atomDistSq = (atom.coord.x - oriAtom.coord.x) * (atom.coord.x - oriAtom.coord.x) + (atom.coord.y - oriAtom.coord.y) * (atom.coord.y - oriAtom.coord.y) + (atom.coord.z - oriAtom.coord.z) * (atom.coord.z - oriAtom.coord.z);

            var maxDistSq = (radius + distance) * (radius + distance);

            if (atomDistSq < maxDistSq) {
                ret[atom.serial] = atom;
            }
        }
    }

    return ret;
};

// from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.getExtent = function (atomlist) {
    var me = this;

    var xmin = ymin = zmin = 9999;
    var xmax = ymax = zmax = -9999;
    var xsum = ysum = zsum = cnt = 0;
    var i;
    for (i in atomlist) {
        //var atom = atomlist[i];
        var atom = me.atoms[i];
        cnt++;
        xsum += atom.coord.x; ysum += atom.coord.y; zsum += atom.coord.z;


        xmin = (xmin < atom.coord.x) ? xmin : atom.coord.x;

        ymin = (ymin < atom.coord.y) ? ymin : atom.coord.y;
        zmin = (zmin < atom.coord.z) ? zmin : atom.coord.z;
        xmax = (xmax > atom.coord.x) ? xmax : atom.coord.x;
        ymax = (ymax > atom.coord.y) ? ymax : atom.coord.y;
        zmax = (zmax > atom.coord.z) ? zmax : atom.coord.z;
    }

    return [[xmin, ymin, zmin], [xmax, ymax, zmax], [xsum / cnt, ysum / cnt, zsum / cnt]];
};

iCn3D.prototype.centerAtoms = function (atoms) {
    var pmin = new THREE.Vector3(9999, 9999, 9999);
    var pmax = new THREE.Vector3(-9999, -9999, -9999);
    var psum = new THREE.Vector3();
    var cnt = 0;

    for (var i in atoms) {
        var atom = this.atoms[i];
        var coord = atom.coord;
        psum.add(coord);
        pmin.min(coord);
        pmax.max(coord);
        ++cnt;
    }

    var maxD = pmax.distanceTo(pmin);

    return { "center": psum.multiplyScalar(1.0 / cnt), "maxD": maxD };
};

iCn3D.prototype.removeSurfaces = function () {
    // remove prevous highlight
    for (var i = 0, il = this.prevSurfaces.length; i < il; ++i) {
        this.mdl.remove(this.prevSurfaces[i]);
    }

    this.prevSurfaces = [];
};

iCn3D.prototype.removeLastSurface = function () {
    // remove prevous highlight
    if (this.prevSurfaces.length > 0) {
        this.mdl.remove(this.prevSurfaces[this.prevSurfaces.length - 1]);
        this.prevSurfaces.slice(this.prevSurfaces.length - 1, 1);
    }
};

iCn3D.prototype.zoominSelection = function (atoms) {
    if (atoms === undefined) {
        atoms = this.hash2Atoms(this.hAtoms);
    }

    // center on the hAtoms if more than one residue is selected
    if (Object.keys(atoms).length > 1) {
        var centerAtomsResults = this.centerAtoms(atoms);
        this.maxD = centerAtomsResults.maxD;
        if (this.maxD < 5) this.maxD = 5;

        this.mdl.position.set(0, 0, 0);
        this.mdlImpostor.position.set(0, 0, 0);
        this.mdl_ghost.position.set(0, 0, 0);

        this.mdl.position.sub(centerAtomsResults.center);
        //this.mdlPicking.position.sub(centerAtomsResults.center);
        this.mdlImpostor.position.sub(centerAtomsResults.center);
        this.mdl_ghost.position.sub(centerAtomsResults.center);

        this.center = centerAtomsResults.center;

        // reset cameara
        this.setCamera();
    }
};

iCn3D.prototype.centerSelection = function (atoms) {
    this.resetOrientation();

    if (atoms === undefined) {
        atoms = this.hash2Atoms(this.hAtoms);
    }

    // center on the hAtoms if more than one residue is selected
    if (Object.keys(atoms).length > 1) {
        var centerAtomsResults = this.centerAtoms(atoms);

        this.center = centerAtomsResults.center;
        this.setCenter(this.center);

        // reset cameara
        this.setCamera();
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// make dialog movable outside of the window
// http://stackoverflow.com/questions/6696461/jquery-ui-dialog-drag-question
if (!$.ui.dialog.prototype._makeDraggableBase) {
    $.ui.dialog.prototype._makeDraggableBase = $.ui.dialog.prototype._makeDraggable;
    $.ui.dialog.prototype._makeDraggable = function () {
        this._makeDraggableBase();
        this.uiDialog.draggable("option", "containment", false);
    };
}

var iCn3DUI = function (cfg) {
    var me = this;

    me.bFullUi = true;

    me.cfg = cfg;
    me.divid = me.cfg.divid;
    me.pre = me.divid + "_";

    me.inputid = '';

    me.WIDTH = 400; // total width of view area
    me.HEIGHT = 400; // total height of view area

    me.RESIDUE_WIDTH = 10;  // sequences
    me.MENU_HEIGHT = 40;

    // used to set the position for the log/command textarea
    //me.MENU_WIDTH = 690;
    me.MENU_WIDTH = 750;

    me.LESSWIDTH = 20;
    me.LESSWIDTH_RESIZE = 20;
    me.LESSHEIGHT = 20;

    me.ROT_DIR = 'right';
    me.bHideSelection = true;

    me.CMD_HEIGHT = 0.8 * me.MENU_HEIGHT;

    //me.EXTRAHEIGHT = 2*me.MENU_HEIGHT + me.CMD_HEIGHT;
    me.EXTRAHEIGHT = me.MENU_HEIGHT + me.CMD_HEIGHT;
    if (me.cfg.showmenu != undefined && me.cfg.showmenu == false) {
        //me.EXTRAHEIGHT -= 2*me.MENU_HEIGHT;
        me.EXTRAHEIGHT -= me.MENU_HEIGHT;
    }
    if (me.cfg.showcommand != undefined && me.cfg.showcommand == false) {
        me.EXTRAHEIGHT -= me.CMD_HEIGHT;
    }

    me.GREY8 = "#888888"; // style protein grey
    me.GREYB = "#BBBBBB";
    me.GREYC = "#CCCCCC"; // grey background
    me.GREYD = "#DDDDDD";
    me.ORANGE = "#FFA500";

    me.opts = {};
    me.opts['camera'] = 'perspective';        //perspective, orthographic
    me.opts['background'] = 'transparent';        //transparent, black, grey, white
    me.opts['color'] = 'chain';              //spectrum, secondary structure, charge, hydrophobic, conserved, chain, residue, atom, red, green, blue, magenta, yellow, cyan, white, grey, custom
    me.opts['proteins'] = 'ribbon';             //ribbon, strand, cylinder and plate, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, nothing
    me.opts['sidec'] = 'nothing';            //lines, stick, ball and stick, sphere, nothing
    me.opts['nucleotides'] = 'nucleotide cartoon'; //nucleotide cartoon, o3 trace, schematic, lines, stick,
    // nucleotides ball and stick, sphere, nothing
    me.opts['surface'] = 'nothing';            //Van der Waals surface, molecular surface, solvent accessible surface, nothing
    me.opts['opacity'] = '1.0';                //1.0, 0.9, 0.8, 0.7, 0.6, 0.5
    me.opts['wireframe'] = 'no';                 //yes, no
    me.opts['chemicals'] = 'stick';              //lines, stick, ball and stick, schematic, sphere, nothing
    me.opts['water'] = 'nothing';            //sphere, dot, nothing
    me.opts['ions'] = 'sphere';             //sphere, dot, nothing
    me.opts['hbonds'] = 'no';                 //yes, no
    //me.opts['stabilizer']           = 'no';                 //yes, no
    me.opts['ssbonds'] = 'yes';                 //yes, no
    me.opts['rotationcenter'] = 'molecule center';    //molecule center, pick center, display center
    me.opts['axis'] = 'no';                 //yes, no
    me.opts['fog'] = 'no';                 //yes, no
    me.opts['slab'] = 'no';                 //yes, no
    me.opts['pk'] = 'residue';            //no, atom, residue, strand, chain
    me.opts['chemicalbinding'] = 'hide';               //show, hide

    if (me.cfg.align !== undefined) me.opts['color'] = 'conserved';
    if (me.cfg.cid !== undefined) me.opts['color'] = 'atom';

    if (me.cfg.options !== undefined) jQuery.extend(me.opts, me.cfg.options);

    me.init();

    me.modifyIcn3d();


};

iCn3DUI.prototype = {

    constructor: iCn3DUI,

    init: function () {
        var me = this;
        me.bSelectResidue = false;
        me.bSelectAlignResidue = false;
        me.selectedResidues = {};

        me.bAnnoShown = false;
        me.bSetChainsAdvancedMenu = false;
        me.b2DShown = false;

        me.bCrashed = false;
        me.prevCommands = "";

        me.bAddCommands = true;
        me.bAddLogs = true;

        me.bNotLoadStructure = false;

        me.bInitial = true;

        $("#" + me.pre + "dl_annotations").html('');
        $("#" + me.pre + "dl_2ddgm").html('');
    },

    // modify iCn3D function
    modifyIcn3d: function () {
        var me = this;
        me.modifyIcn3dshowPicking();
        me.modifySwitchHighlightLevel();
    },

    allCustomEvents: function () {
        var me = this;
        // add custom events here
    },

    setCustomDialogs: function () {
        var me = this;
        var html = "";

        return html;
    },

    modifyIcn3dshowPicking: function () {
        var me = this;
        iCn3D.prototype.showPicking = function (atom) {
            this.showPickingBase(atom);

            // highlight the sequence background
            var idArray = this.id.split('_'); // id: div0_canvas
            me.pre = idArray[0] + "_";

            me.updateHlAll();

            var transformation = {};
            transformation.factor = this._zoomFactor;
            transformation.mouseChange = this.mouseChange;
            //transformation.quaternion = this.quaternion;
            transformation.quaternion = {};
            transformation.quaternion._x = parseFloat(this.quaternion._x).toPrecision(5);
            transformation.quaternion._y = parseFloat(this.quaternion._y).toPrecision(5);
            transformation.quaternion._z = parseFloat(this.quaternion._z).toPrecision(5);
            transformation.quaternion._w = parseFloat(this.quaternion._w).toPrecision(5);

            if (me.bAddCommands) {
                this.commands.push('pickatom ' + atom.serial + '|||' + me.getTransformationStr(transformation));
                this.optsHistory.push(this.cloneHash(this.opts));
                this.optsHistory[this.optsHistory.length - 1].hlatomcount = Object.keys(this.hAtoms).length;

                if (me.isSessionStorageSupported()) me.saveCommandsToSession();

                me.STATENUMBER = this.commands.length;
            }

            this.logs.push('pickatom ' + atom.serial + ' (chain: ' + atom.structure + '_' + atom.chain + ', residue: ' + atom.resn + ', number: ' + atom.resi + ', atom: ' + atom.name + ')');
            if ($("#" + me.pre + "logtext").length) {
                $("#" + me.pre + "logtext").val("> " + this.logs.join("\n> ") + "\n> ").scrollTop($("#" + me.pre + "logtext")[0].scrollHeight);
            }

            // add label
            var residueText = atom.resn + atom.resi;

            var text;
            if (me.cfg.cid !== undefined) {
                text = atom.name;
                this.pk = 1; // atom
            }
            else {
                text = residueText + '@' + atom.name;
                // do not chnage the picking option
                //this.pk = 2; // residue
            }

            var labels = {};
            labels['picking'] = [];

            var label = {};
            label.position = new THREE.Vector3(atom.coord.x + 1, atom.coord.y + 1, atom.coord.z + 1); // shifted by 1

            if (this.pk === 1) {
                label.text = text;
            }
            else if (this.pk === 2) {
                label.text = residueText;
            }

            label.background = "#CCCCCC";

            if (this.pk === 1 || this.pk === 2) {
                labels['picking'].push(label);

                //http://www.johannes-raida.de/tutorials/three.js/tutorial13/tutorial13.htm
                if (me.bMeasureDistance === undefined || !me.bMeasureDistance) this.createLabelRepresentation(labels);
            }
        };
    },

    modifySwitchHighlightLevel: function () {
        var me = this;
        iCn3D.prototype.switchHighlightLevel = function () {
            this.switchHighlightLevelBase();

            $(document).bind('keydown', function (e) {
                if (e.keyCode === 38 || e.keyCode === 40) { // arrow up/down, select upper/down level of atoms
                    me.updateHlAll();
                }
            });
        };
    },

    // ======= functions start==============
    // show3DStructure is the main function to show 3D structure
    show3DStructure: function () {
        var me = this;
        me.deferred = $.Deferred(function () {
            if (me.isSessionStorageSupported()) me.getCommandsBeforeCrash();

            me.setViewerWidthHeight();

            var width, height;

            if (me.cfg.width.toString().indexOf('%') !== -1) {
                width = me.WIDTH * me.cfg.width.substr(0, me.cfg.width.toString().indexOf('%')) / 100.0 - me.LESSWIDTH;
            }
            else {
                width = me.cfg.width;
            }

            if (me.cfg.height.toString().indexOf('%') !== -1) {
                height = me.HEIGHT * me.cfg.height.substr(0, me.cfg.height.toString().indexOf('%')) / 100.0 - me.EXTRAHEIGHT - me.LESSHEIGHT;
            }
            else {
                height = me.cfg.height;
            }

            me.realWidth = width;
            me.realHeight = height;

            me.setTopMenusHtml(me.divid);

            me.allEventFunctions();

            me.allCustomEvents();

            var extraHeight = 0;
            if (me.cfg.showmenu == undefined || me.cfg.showmenu) {
                //extraHeight += 2*me.MENU_HEIGHT;
                extraHeight += me.MENU_HEIGHT;
            }
            if (me.cfg.showcommand == undefined || me.cfg.showcommand) {
                extraHeight += me.CMD_HEIGHT;
            }

            if (me.cfg.showmenu != undefined && me.cfg.showmenu == false) {
                me.hideMenu();
            }
            else {
                me.showMenu();
            }

            $("#" + me.pre + "viewer").width(width).height(parseInt(height) + extraHeight);
            $("#" + me.pre + "canvas").width(width).height(parseInt(height));
            //$("#" + me.pre + "canvas").resizable(); // resizing behavor not good for canvas.

            me.icn3d = new iCn3D(me.pre + 'canvas');
            if (!me.isMobile()) me.icn3d.scaleFactor = 2.0;

            me.handleContextLost();

            me.icn3d.setWidthHeight(width, height);

            me.icn3d.ori_chemicalbinding = me.opts['chemicalbinding'];


            if (me.cfg.bCalphaOnly !== undefined) me.icn3d.bCalphaOnly = me.cfg.bCalphaOnly;

            //me.deferred = undefined; // sequential calls

            me.icn3d.opts = me.icn3d.cloneHash(me.opts);

            me.STATENUMBER = me.icn3d.commands.length;

            // If previously crashed, recover it
            if (me.isSessionStorageSupported() && me.bCrashed) {
                me.bCrashed = false;

                var loadCommand = me.commandsBeforeCrash.split('|||')[0];
                var id = loadCommand.substr(loadCommand.lastIndexOf(' ') + 1);

                // reload only if viewing the same structure
                if (id === me.cfg.mmtfid || id === me.cfg.pdbid || id === me.cfg.mmdbid || id === me.cfg.gi || id === me.cfg.cid || id === me.cfg.mmcifid || id === me.cfg.align) {
                    me.loadScript(me.commandsBeforeCrash, true);

                    return;
                }
            }

            me.icn3d.molTitle = '';

            if (me.cfg.url !== undefined) {
                var type_url = me.cfg.url.split('|');
                var type = type_url[0];
                var url = type_url[1];

                me.icn3d.molTitle = "";
                me.inputid = undefined;

                me.setLogCmd('load url ' + url + ' | type ' + type, true);

                me.downloadUrl(url, type);
            }
            else if (me.cfg.mmtfid !== undefined) {
                me.inputid = me.cfg.mmtfid;

                me.setLogCmd('load mmtf ' + me.cfg.mmtfid, true);

                me.downloadMmtf(me.cfg.mmtfid);
            }
            else if (me.cfg.pdbid !== undefined) {
                me.inputid = me.cfg.pdbid;

                me.setLogCmd('load pdb ' + me.cfg.pdbid, true);

                me.downloadPdb(me.cfg.pdbid);
            }
            else if (me.cfg.mmdbid !== undefined) {
                me.inputid = me.cfg.mmdbid;

                me.setLogCmd('load mmdb ' + me.cfg.mmdbid + ' | parameters ' + me.cfg.inpara, true);

                me.downloadMmdb(me.cfg.mmdbid);
            }
            else if (me.cfg.gi !== undefined) {
                me.setLogCmd('load gi ' + me.cfg.gi, true);

                me.downloadGi(me.cfg.gi);
            }
            else if (me.cfg.cid !== undefined) {
                me.inputid = me.cfg.cid;

                var url = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + me.inputid + "/description/jsonp";
                $.ajax({
                    url: url,
                    dataType: 'jsonp',
                    tryCount: 0,
                    retryLimit: 1,
                    success: function (data) {
                        if (data.InformationList !== undefined && data.InformationList.Information !== undefined) me.icn3d.molTitle = data.InformationList.Information[0].Title;
                    },
                    error: function (xhr, textStatus, errorThrown) {
                        this.tryCount++;
                        if (this.tryCount <= this.retryLimit) {
                            //try again
                            $.ajax(this);
                            return;
                        }
                        return;
                    }
                });

                me.setLogCmd('load cid ' + me.cfg.cid, true);

                me.downloadCid(me.cfg.cid);
            }
            else if (me.cfg.mmcifid !== undefined) {
                me.inputid = me.cfg.mmcifid;

                me.setLogCmd('load mmcif ' + me.cfg.mmcifid, true);

                me.downloadMmcif(me.cfg.mmcifid);
            }
            else if (me.cfg.align !== undefined) {
                var alignArray = me.cfg.align.split(','); // e.g., 6 IDs: 103701,1,4,68563,1,167 [mmdbid1,biounit,molecule,mmdbid2,biounit,molecule], or 2IDs: 103701,68563 [mmdbid1,mmdbid2]

                if (alignArray.length === 6) {
                    me.inputid = alignArray[0] + "_" + alignArray[3];
                }
                else if (alignArray.length === 2) {
                    me.inputid = alignArray[0] + "_" + alignArray[1];
                }

                me.setLogCmd('load alignment ' + me.cfg.align + ' | parameters ' + me.cfg.inpara, true);

                me.downloadAlignment(me.cfg.align);
            }
            else if (me.cfg.command !== undefined) {
                me.loadScript(me.cfg.command);
            }
            else {
                alert("Please use the \"File\" menu to retrieve a structure of interest or to display a local file.");
            }
        });

        return me.deferred.promise();
    },

    hideMenu: function () {
        var me = this;
        if ($("#" + me.pre + "mnlist")[0] !== undefined) $("#" + me.pre + "mnlist")[0].style.display = "none";
        if ($("#" + me.pre + "mnLogSection")[0] !== undefined) $("#" + me.pre + "mnLogSection")[0].style.display = "none";
        if ($("#" + me.pre + "cmdlog")[0] !== undefined) $("#" + me.pre + "cmdlog")[0].style.display = "none";
        //      if($("#" + me.pre + "selection")[0] !== undefined) $("#" + me.pre + "selection")[0].style.display = "none";

        //if($("#" + me.pre + "title")[0] !== undefined) $("#" + me.pre + "title")[0].style.display = "none";
        $("#" + me.pre + "title")[0].style.margin = "10px 0 0 10px";
    },

    showMenu: function () {
        var me = this;
        if ($("#" + me.pre + "mnlist")[0] !== undefined) $("#" + me.pre + "mnlist")[0].style.display = "block";
        if ($("#" + me.pre + "mnLogSection")[0] !== undefined) $("#" + me.pre + "mnLogSection")[0].style.display = "block";
        if ($("#" + me.pre + "cmdlog")[0] !== undefined) $("#" + me.pre + "cmdlog")[0].style.display = "block";
        //      if($("#" + me.pre + "selection")[0] !== undefined) $("#" + me.pre + "selection")[0].style.display = "block";

        if ($("#" + me.pre + "title")[0] !== undefined) $("#" + me.pre + "title")[0].style.display = "block";
    },

    saveSelectionIfSelected: function (id, value) {
        var me = this;
        if (me.bSelectResidue || me.bSelectAlignResidue) {
            var name = $("#" + me.pre + "seq_command_name2").val().replace(/\s+/g, '_');
            //var description = $("#" + me.pre + "seq_command_desc2").val();

            if (name === "") {
                name = $("#" + me.pre + "alignseq_command_name").val().replace(/\s+/g, '_');
                //description = $("#" + me.pre + "alignseq_command_desc").val();
            }

            if (name !== "") me.saveSelection(name, name);

            me.bSelectResidue = false;
            me.bSelectAlignResidue = false;
        }
    },

    setOption: function (id, value) {
        var me = this;
        //var options2 = {};
        //options2[id] = value;

        // remember the options
        me.icn3d.opts[id] = value;

        me.saveSelectionIfSelected();

        if (id === 'color') {
            me.icn3d.setColorByOptions(me.icn3d.opts, me.icn3d.hAtoms);

            me.icn3d.draw();

            var residueHash = me.icn3d.getResiduesFromAtoms(me.icn3d.hAtoms);
            me.changeSeqColor(Object.keys(residueHash));
        }
        else if (id === 'surface' || id === 'opacity' || id === 'wireframe') {
            if (id === 'opacity' || id === 'wireframe') {
                me.icn3d.removeLastSurface();
            }
            me.icn3d.applySurfaceOptions();
            //me.icn3d.render();
            me.icn3d.draw(); // to make surface work in assembly
        }
        else if (id === 'chemicalbinding') {
            me.icn3d.bSkipChemicalbinding = false;
            me.icn3d.draw();
        }
        else {
            me.icn3d.draw();
        }
    },

    setStyle: function (selectionType, style) {
        var me = this;
        var atoms = {};
        switch (selectionType) {
            case 'proteins':
                atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.proteins);
                break;
            case 'sidec':
                atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.sidec);
                calpha_atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.calphas);
                // include calphas
                atoms = me.icn3d.unionHash(atoms, calpha_atoms);
                break;
            case 'nucleotides':
                atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.nucleotides);
                break;
            case 'chemicals':
                atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.chemicals);
                break;
            case 'ions':
                atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.ions);
                break;
            case 'water':
                atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.water);
                break;
        }

        // draw sidec separatedly
        if (selectionType === 'sidec') {
            for (var i in atoms) {
                me.icn3d.atoms[i].style2 = style;
            }
        }
        else {
            for (var i in atoms) {
                me.icn3d.atoms[i].style = style;
            }
        }

        me.icn3d.opts[selectionType] = style;

        me.saveSelectionIfSelected();

        me.icn3d.draw();
    },

    setLogCmd: function (str, bSetCommand, bAddLogs) {
        var me = this;
        if (str.trim() === '') return false;

        var pos = str.indexOf('|||');
        if (pos !== -1) str = str.substr(0, pos);

        var transformation = {};
        transformation.factor = me.icn3d._zoomFactor;
        transformation.mouseChange = me.icn3d.mouseChange;

        transformation.quaternion = {};
        transformation.quaternion._x = parseFloat(me.icn3d.quaternion._x).toPrecision(5);
        transformation.quaternion._y = parseFloat(me.icn3d.quaternion._y).toPrecision(5);
        transformation.quaternion._z = parseFloat(me.icn3d.quaternion._z).toPrecision(5);
        transformation.quaternion._w = parseFloat(me.icn3d.quaternion._w).toPrecision(5);

        if (bSetCommand) {
            // save the command only when it's not a history command, i.e., not in the process of going back and forth
            if (me.bAddCommands) {
                // If a new command was called, remove the forward commands and push to the command array
                if (me.STATENUMBER < me.icn3d.commands.length) {
                    var oldCommand = me.icn3d.commands[me.STATENUMBER - 1];
                    var pos = oldCommand.indexOf('|||');
                    if (str !== oldCommand.substr(0, pos)) {
                        me.icn3d.commands = me.icn3d.commands.slice(0, me.STATENUMBER);

                        me.icn3d.commands.push(str + '|||' + me.getTransformationStr(transformation));
                        me.icn3d.optsHistory.push(me.icn3d.cloneHash(me.icn3d.opts));
                        me.icn3d.optsHistory[me.icn3d.optsHistory.length - 1].hlatomcount = Object.keys(me.icn3d.hAtoms).length;

                        if (me.isSessionStorageSupported()) me.saveCommandsToSession();

                        me.STATENUMBER = me.icn3d.commands.length;
                    }
                }
                else {
                    me.icn3d.commands.push(str + '|||' + me.getTransformationStr(transformation));

                    me.icn3d.optsHistory.push(me.icn3d.cloneHash(me.icn3d.opts));
                    if (me.icn3d.hAtoms !== undefined) me.icn3d.optsHistory[me.icn3d.optsHistory.length - 1].hlatomcount = Object.keys(me.icn3d.hAtoms).length;

                    if (me.isSessionStorageSupported()) me.saveCommandsToSession();

                    me.STATENUMBER = me.icn3d.commands.length;
                }
            }
        }

        if (me.bAddLogs && me.cfg.showcommand) {
            me.icn3d.logs.push(str);

            // move cursor to the end, and scroll to the end
            $("#" + me.pre + "logtext").val("> " + me.icn3d.logs.join("\n> ") + "\n> ").scrollTop($("#" + me.pre + "logtext")[0].scrollHeight);
        }

        me.adjustIcon();
    },

    renderStructure: function () {
        var me = this;
        if (me.bInitial) {
            if (me.cfg.command !== undefined && me.cfg.command !== '') {
                me.icn3d.bRender = false;

                jQuery.extend(me.icn3d.opts, me.opts);
                me.icn3d.draw();
            }
            else {
                jQuery.extend(me.icn3d.opts, me.opts);
                me.icn3d.draw();
            }

            if (Object.keys(me.icn3d.structures).length > 1) {
                $("#" + me.pre + "alternate").show();
            }
            else {
                $("#" + me.pre + "alternate").hide();
            }
        }
        else {
            me.saveSelectionIfSelected();

            me.icn3d.draw();
        }

        if (me.bInitial && me.cfg.command !== undefined && me.cfg.command !== '') {
            me.icn3d.bRender = true;
            me.loadScript(me.cfg.command);
        }

        // display the structure right away. load the mns and sequences later
        setTimeout(function () {
            if (me.bInitial) {
                if (me.cfg.showsets !== undefined && me.cfg.showsets) {
                    me.showSets();
                }

                if (me.cfg.align !== undefined) {
                    var bShowHighlight = false;
                    seqObj = me.getAlignSequencesAnnotations(Object.keys(me.icn3d.alnChains), undefined, undefined, bShowHighlight);

                    $("#" + me.pre + "dl_sequence2").html(seqObj.sequencesHtml);
                    $("#" + me.pre + "dl_sequence2").width(me.RESIDUE_WIDTH * seqObj.maxSeqCnt + 200);
                }

                //me.setProtNuclLigInMenu();

                if (me.cfg.showanno !== undefined && me.cfg.showanno) {
                    var cmd = "view annotations";
                    me.setLogCmd(cmd, true);

                    me.showAnnotations();
                    /*
                                       if(Object.keys(me.icn3d.proteins).length > 0) {
                                          $.when(me.applyCommandAnnotationsAndCddSite(cmd)).then(function() {
                                              // do something afterward
                                          });
                                       }
                                       else {
                                          me.applyCommandAnnotationsAndCddSiteBase(cmd);
                                       }
                    */
                }
            }
            else {
                me.updateHlAll();
            }

            me.bInitial = false;
        }, 0);
    },

    exportCustomAtoms: function () {
        var me = this;
        var html = "";

        var nameArray = (me.icn3d.defNames2Residues !== undefined) ? Object.keys(me.icn3d.defNames2Residues).sort() : [];

        for (var i = 0, il = nameArray.length; i < il; ++i) {
            var name = nameArray[i];
            var residueArray = me.icn3d.defNames2Residues[name];
            var description = me.icn3d.defNames2Descr[name];
            var command = me.icn3d.defNames2Command[name];
            command = command.replace(/,/g, ', ');

            html += name + "\tselect ";

            html += me.residueids2spec(residueArray);

            html += "\n";
        } // outer for

        nameArray = (me.icn3d.defNames2Atoms !== undefined) ? Object.keys(me.icn3d.defNames2Atoms).sort() : [];

        for (var i = 0, il = nameArray.length; i < il; ++i) {
            var name = nameArray[i];
            var atomArray = me.icn3d.defNames2Atoms[name];
            var description = me.icn3d.defNames2Descr[name];
            var command = me.icn3d.defNames2Command[name];
            command = command.replace(/,/g, ', ');

            html += name + "\tselect ";

            var residueHash = {};
            for (var j = 0, jl = atomArray.length; j < jl; ++j) {
                var atom = me.icn3d.atoms[atomArray[j]];
                var residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                residueHash[residueid] = 1;
            }

            var residueArray = Object.keys(residueHash);

            html += me.residueids2spec(residueArray);

            html += "\n";
        } // outer for

        return html;
    },

    residueids2spec: function (residueArray) {
        var me = this;
        var spec = "";

        if (residueArray !== undefined) {
            var residueArraySorted = residueArray.sort(function (a, b) {
                if (a !== '' && !isNaN(a)) {
                    return parseInt(a) - parseInt(b);
                }
                else {
                    var lastPosA = a.lastIndexOf('_');
                    var lastPosB = b.lastIndexOf('_');
                    if (a.substr(0, lastPosA) < b.substr(0, lastPosB)) return -1;
                    else if (a.substr(0, lastPosA) > b.substr(0, lastPosB)) return 1;
                    else if (a.substr(0, lastPosA) == b.substr(0, lastPosB)) {
                        if (parseInt(a.substr(lastPosA + 1)) < parseInt(b.substr(lastPosB + 1))) return -1;
                        else if (parseInt(a.substr(lastPosA + 1)) > parseInt(b.substr(lastPosB + 1))) return 1;
                        else if (parseInt(a.substr(lastPosA + 1)) == parseInt(b.substr(lastPosB + 1))) return 0;
                    }
                }
            });

            var prevChain = '', chain, prevResi = 0, resi, lastDashPos, firstDashPos, struturePart, chainPart;
            var startResi;
            var bMultipleStructures = (Object.keys(me.icn3d.structures).length == 1) ? false : true;
            for (var j = 0, jl = residueArraySorted.length; j < jl; ++j) {
                var residueid = residueArraySorted[j];

                lastDashPos = residueid.lastIndexOf('_');
                chain = residueid.substr(0, lastDashPos);
                resi = parseInt(residueid.substr(lastDashPos + 1));

                firstDashPos = prevChain.indexOf('_');
                struturePart = prevChain.substr(0, firstDashPos);
                chainPart = prevChain.substr(firstDashPos + 1);

                if (prevChain !== chain) {
                    if (j > 0) {
                        if (prevResi === startResi) {
                            if (bMultipleStructures) {
                                spec += '$' + struturePart + '.' + chainPart + ':' + startResi + ' or ';
                            }
                            else {
                                spec += '.' + chainPart + ':' + startResi + ' or ';
                            }
                        }
                        else {
                            if (bMultipleStructures) {
                                spec += '$' + struturePart + '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                            }
                            else {
                                spec += '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                            }
                        }
                    }

                    startResi = resi;
                }
                else if (prevChain === chain) {
                    if (resi !== prevResi + 1) {
                        if (prevResi === startResi) {
                            if (bMultipleStructures) {
                                spec += '$' + struturePart + '.' + chainPart + ':' + startResi + ' or ';
                            }
                            else {
                                spec += '.' + chainPart + ':' + startResi + ' or ';
                            }
                        }
                        else {
                            if (bMultipleStructures) {
                                spec += '$' + struturePart + '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                            }
                            else {
                                spec += '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                            }
                        }

                        startResi = resi;
                    }
                }

                prevChain = chain;
                prevResi = resi;
            }

            // last residue
            firstDashPos = prevChain.indexOf('_');
            struturePart = prevChain.substr(0, firstDashPos);
            chainPart = prevChain.substr(firstDashPos + 1);

            if (prevResi === startResi) {
                if (bMultipleStructures) {
                    spec += '$' + struturePart + '.' + chainPart + ':' + startResi;
                }
                else {
                    spec += '.' + chainPart + ':' + startResi;
                }
            }
            else {
                if (bMultipleStructures) {
                    spec += '$' + struturePart + '.' + chainPart + ':' + startResi + '-' + prevResi;
                }
                else {
                    spec += '.' + chainPart + ':' + startResi + '-' + prevResi;
                }
            }
        }

        return spec;
    },

    pickCustomSphere: function (radius) {
        var me = this; // me.icn3d.pAtom is set already
        //        me.removeHlMenus();

        var select = "select zone cutoff " + radius;

        var atomlistTarget = {};

        for (var i in me.icn3d.hAtoms) {
            atomlistTarget[i] = me.icn3d.atoms[i];
        }

        // select all atom, not just displayed atoms
        var atoms = me.icn3d.getAtomsWithinAtom(me.icn3d.atoms, atomlistTarget, parseFloat(radius));

        var residues = {}, atomArray = undefined;

        for (var i in atoms) {
            var atom = atoms[i];
            var residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
            residues[residueid] = 1;

            //atomArray.push(i);
        }

        var residueArray = Object.keys(residues);

        me.icn3d.hAtoms = {};
        for (var index = 0, indexl = residueArray.length; index < indexl; ++index) {
            var residueid = residueArray[index];
            for (var i in me.icn3d.residues[residueid]) {
                //var atom = me.icn3d.atoms[i];
                //atom.color = new THREE.Color(0xFF0000);

                //me.icn3d.atomPrevColors[i] = atom.color;

                me.icn3d.hAtoms[i] = 1;
            }
        }

        me.icn3d.dAtoms = me.icn3d.cloneHash(me.icn3d.atoms);

        var commandname, commanddesc;
        var firstAtom = me.icn3d.getFirstAtomObj(atomlistTarget);
        commandname = "sphere." + firstAtom.chain + ":" + me.icn3d.residueName2Abbr(firstAtom.resn.substr(0, 3)) + firstAtom.resi + "-" + $("#" + me.pre + "radius_aroundsphere").val() + "A";
        commanddesc = "select a sphere around currently selected " + Object.keys(me.icn3d.hAtoms).length + " atoms with a radius of " + radius + " angstrom";

        me.addCustomSelection(residueArray, commandname, commanddesc, select, true);

        var nameArray = [commandname];

        //me.changeCustomResidues(nameArray);

        me.saveSelectionIfSelected();

        me.icn3d.draw(); // show all neighbors, even not displayed before
    },

    // between the highlighted and the rest atoms
    showHbonds: function (threshold) {
        var me = this;
        me.icn3d.opts["hbonds"] = "yes";
        me.icn3d.opts["water"] = "dot";

        var select = 'hbonds ' + threshold;

        var complement = {};

        for (var i in me.icn3d.atoms) {
            if (!me.icn3d.hAtoms.hasOwnProperty(i) && me.icn3d.dAtoms.hasOwnProperty(i)) {
                complement[i] = me.icn3d.atoms[i];
            }
        }

        var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.hAtoms);

        if (Object.keys(complement).length > 0 && Object.keys(me.icn3d.hAtoms).length > 0) {
            var selectedAtoms = me.icn3d.calculateChemicalHbonds(complement, me.icn3d.intHash2Atoms(me.icn3d.dAtoms, me.icn3d.hAtoms), parseFloat(threshold));

            var residues = {}, atomArray = undefined;

            for (var i in selectedAtoms) {
                var residueid = me.icn3d.atoms[i].structure + '_' + me.icn3d.atoms[i].chain + '_' + me.icn3d.atoms[i].resi;
                residues[residueid] = 1;

                //atomArray.push(i);

                //me.icn3d.atoms[i].style2 = 'stick';
            }

            me.icn3d.hAtoms = {};
            for (var resid in residues) {
                for (var i in me.icn3d.residues[resid]) {
                    me.icn3d.hAtoms[i] = 1;
                    me.icn3d.atoms[i].style2 = 'stick';
                }
            }

            var commandname = 'hbonds_' + firstAtom.serial;
            var commanddesc = 'all atoms that are hydrogen-bonded with the selected atoms';
            me.addCustomSelection(Object.keys(residues), commandname, commanddesc, select, true);

            var nameArray = [commandname];

            //me.changeCustomResidues(nameArray);

            me.saveSelectionIfSelected();

            //me.setStyle('sidec', 'ball and stick');

            me.icn3d.draw();
        }
    },

    // show all disulfide bonds
    showSsbonds: function () {
        var me = this;
        me.icn3d.opts["ssbonds"] = "yes";

        var select = 'disulfide bonds';

        //         me.removeHlMenus();

        var residues = {}, atomArray = undefined;

        var structureArray = Object.keys(me.icn3d.structures);

        for (var s = 0, sl = structureArray.length; s < sl; ++s) {
            var structure = structureArray[s];

            if (me.icn3d.ssbondpnts[structure] === undefined) continue;

            for (var i = 0, lim = Math.floor(me.icn3d.ssbondpnts[structure].length / 2); i < lim; i++) {
                var res1 = me.icn3d.ssbondpnts[structure][2 * i], res2 = me.icn3d.ssbondpnts[structure][2 * i + 1];

                residues[res1] = 1;
                residues[res2] = 1;

                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[res1]);
                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[res2]);

            }
        }

        if (Object.keys(residues).length > 0) {
            var commandname = 'ssbonds';
            var commanddesc = 'all atoms that have disulfide bonds';
            me.addCustomSelection(Object.keys(residues), commandname, commanddesc, select, true);

            var nameArray = [commandname];

            //me.changeCustomResidues(nameArray);

            me.saveSelectionIfSelected();

            // show side chains for the selected atoms
            //me.setStyle('sidec', 'stick');

            me.icn3d.draw();
        }
    },

    addLabel: function (text, x, y, z, size, color, background, type) {
        var me = this;
        var label = {}; // Each label contains 'position', 'text', 'color', 'background'

        if (size === '0' || size === '' || size === 'undefined') size = undefined;
        if (color === '0' || color === '' || color === 'undefined') color = undefined;
        if (background === '0' || background === '' || background === 'undefined') background = undefined;

        var position = new THREE.Vector3();
        position.x = x;
        position.y = y;
        position.z = z;

        label.position = position;

        label.text = text;
        label.size = size;
        label.color = color;
        label.background = background;

        if (me.icn3d.labels[type] === undefined) me.icn3d.labels[type] = [];

        if (type !== undefined) {
            me.icn3d.labels[type].push(label);
        }
        else {
            me.icn3d.labels['custom'].push(label);
        }

        me.icn3d.removeHlObjects();

        //me.icn3d.draw();
    },

    addLine: function (x1, y1, z1, x2, y2, z2, color, dashed, type) {
        var me = this;
        var line = {}; // Each line contains 'position1', 'position2', 'color', and a boolean of 'dashed'
        line.position1 = new THREE.Vector3(x1, y1, z1);
        line.position2 = new THREE.Vector3(x2, y2, z2);
        line.color = color;
        line.dashed = dashed;

        if (me.icn3d.lines[type] === undefined) me.icn3d.lines[type] = [];

        if (type !== undefined) {
            me.icn3d.lines[type].push(line);
        }
        else {
            me.icn3d.lines['custom'].push(line);
        }

        me.icn3d.removeHlObjects();

        //me.icn3d.draw();
    },

    back: function () {
        var me = this;
        me.backForward = true;

        me.STATENUMBER--;

        // do not add to the array me.icn3d.commands
        me.bAddCommands = false;
        me.bAddLogs = false; // turn off log

        me.bNotLoadStructure = true;

        if (me.STATENUMBER < 1) {
            me.STATENUMBER = 1;
        }
        else {
            me.execCommands(0, me.STATENUMBER - 1, me.STATENUMBER);
        }

        me.adjustIcon();

        me.bAddCommands = true;
        me.bAddLogs = true;
    },

    forward: function () {
        var me = this;
        me.backForward = true;

        me.STATENUMBER++;

        // do not add to the array me.icn3d.commands
        me.bAddCommands = false;
        me.bAddLogs = false; // turn off log

        me.bNotLoadStructure = true;

        if (me.STATENUMBER > me.icn3d.commands.length) {
            me.STATENUMBER = me.icn3d.commands.length;
        }
        else {
            me.execCommands(0, me.STATENUMBER - 1, me.STATENUMBER);
        }

        me.adjustIcon();

        me.bAddCommands = true;
        me.bAddLogs = true;
    },

    toggleSelection: function () {
        var me = this;
        if (me.bHideSelection) {
            for (var i in me.icn3d.dAtoms) {
                if (me.icn3d.hAtoms.hasOwnProperty(i)) delete me.icn3d.dAtoms[i];
            }

            me.bHideSelection = false;
        }
        else {
            me.icn3d.dAtoms = me.icn3d.unionHash(me.icn3d.dAtoms, me.icn3d.hAtoms);

            me.bHideSelection = true;
        }

        me.icn3d.draw();
    },

    adjustIcon: function () {
        var me = this;
        if (me.STATENUMBER === 1) {
            if ($("#" + me.pre + "back").hasClass('icn3d-middleIcon')) {
                $("#" + me.pre + "back").toggleClass('icn3d-middleIcon');
                $("#" + me.pre + "back").toggleClass('icn3d-endIcon');
            }
        }
        else {
            if ($("#" + me.pre + "back").hasClass('icn3d-endIcon')) {
                $("#" + me.pre + "back").toggleClass('icn3d-middleIcon');
                $("#" + me.pre + "back").toggleClass('icn3d-endIcon');
            }
        }

        if (me.STATENUMBER === me.icn3d.commands.length) {
            if ($("#" + me.pre + "forward").hasClass('icn3d-middleIcon')) {
                $("#" + me.pre + "forward").toggleClass('icn3d-middleIcon');
                $("#" + me.pre + "forward").toggleClass('icn3d-endIcon');
            }
        }
        else {
            if ($("#" + me.pre + "forward").hasClass('icn3d-endIcon')) {
                $("#" + me.pre + "forward").toggleClass('icn3d-middleIcon');
                $("#" + me.pre + "forward").toggleClass('icn3d-endIcon');
            }
        }
    },

    toggle: function (id1, id2, id3, id4) {
        var me = this;
        $("#" + id1).toggleClass('ui-icon-plus');
        $("#" + id1).toggleClass('ui-icon-minus');

        $("#" + id2).toggleClass('ui-icon-plus');
        $("#" + id2).toggleClass('ui-icon-minus');

        $("#" + id1).toggleClass('icn3d-shown');
        $("#" + id1).toggleClass('icn3d-hidden');

        $("#" + id2).toggleClass('icn3d-shown');
        $("#" + id2).toggleClass('icn3d-hidden');

        $("#" + id3).toggleClass('icn3d-shown');
        $("#" + id3).toggleClass('icn3d-hidden');

        $("#" + id4).toggleClass('icn3d-shown');
        $("#" + id4).toggleClass('icn3d-hidden');
    },

    selectComplement: function () {
        var me = this;
        var complement = {};
        //var residueHash = {}, chainHash = {};
        //var residueid, chainid;

        for (var i in me.icn3d.atoms) {
            if (!me.icn3d.hAtoms.hasOwnProperty(i)) {
                complement[i] = 1;
                //chainid = me.icn3d.atoms[i].structure + '_' + me.icn3d.atoms[i].chain;
                //residueid = chainid + '_' + me.icn3d.atoms[i].resi;
                //chainHash[chainid] =1;
                //residueHash[residueid] = 1;
            }
        }

        me.icn3d.hAtoms = me.icn3d.cloneHash(complement);

        //me.highlightResidues(Object.keys(residueHash), Object.keys(chainHash));
        me.updateHlAll();
    },

    saveCommandsToSession: function () {
        var me = this;
        var dataStr = me.icn3d.commands.join('\n');
        var data = decodeURIComponent(dataStr);

        sessionStorage.setItem('commands', data);
    },

    addChainLabels: function (atoms) {
        var me = this;
        var size = 18;
        var background = "#CCCCCC";

        var atomsHash = me.icn3d.intHash(me.icn3d.hAtoms, atoms);

        if (me.icn3d.labels['chain'] === undefined) me.icn3d.labels['chain'] = [];

        var chainHash = me.icn3d.getChainsFromAtoms(atomsHash);

        for (var chainid in chainHash) {
            var label = {};

            label.position = me.icn3d.centerAtoms(me.icn3d.chains[chainid]).center;

            var pos = chainid.indexOf('_');
            var chainName = chainid.substr(pos + 1);
            var proteinName = me.getProteinName(chainid);
            if (proteinName.length > 20) proteinName = proteinName.substr(0, 20) + '...';

            label.text = 'Chain ' + chainName + ': ' + proteinName;
            label.size = size;

            var atomColorStr = me.icn3d.getFirstAtomObj(me.icn3d.chains[chainid]).color.getHexString().toUpperCase();
            label.color = (atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr;
            label.background = background;

            me.icn3d.labels['chain'].push(label);
        }

        me.icn3d.removeHlObjects();
    },

    //http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/
    getCommandsBeforeCrash: function () {
        var me = this;
        window.addEventListener('load', function () {
            sessionStorage.setItem('good_exit', 'pending');
        });

        window.addEventListener('beforeunload', function () {
            sessionStorage.setItem('good_exit', 'true');
        });

        if (sessionStorage.getItem('good_exit') && sessionStorage.getItem('good_exit') === 'pending') {
            if (!me.isMac()) me.bCrashed = true;  // this doesn't work in mac
            me.commandsBeforeCrash = sessionStorage.getItem('commands');
        }
    },

    addLineFromPicking: function (type) {
        var me = this;
        var size = 0, color, background = 0;
        var color = $("#" + me.pre + type + "color").val();

        var x = (me.icn3d.pAtom.coord.x + me.icn3d.pAtom2.coord.x) / 2;
        var y = (me.icn3d.pAtom.coord.y + me.icn3d.pAtom2.coord.y) / 2;
        var z = (me.icn3d.pAtom.coord.z + me.icn3d.pAtom2.coord.z) / 2;

        var dashed = (type == 'stabilizer') ? false : true;

        me.setLogCmd('add line | x1 ' + me.icn3d.pAtom.coord.x.toPrecision(4) + ' y1 ' + me.icn3d.pAtom.coord.y.toPrecision(4) + ' z1 ' + me.icn3d.pAtom.coord.z.toPrecision(4) + ' | x2 ' + me.icn3d.pAtom2.coord.x.toPrecision(4) + ' y2 ' + me.icn3d.pAtom2.coord.y.toPrecision(4) + ' z2 ' + me.icn3d.pAtom2.coord.z.toPrecision(4) + ' | color ' + color + ' | dashed ' + dashed + ' | type ' + type, true);

        me.addLine(me.icn3d.pAtom.coord.x, me.icn3d.pAtom.coord.y, me.icn3d.pAtom.coord.z, me.icn3d.pAtom2.coord.x, me.icn3d.pAtom2.coord.y, me.icn3d.pAtom2.coord.z, color, dashed, type);

        me.icn3d.pickpair = false;
    },

    setEntrezLinks: function (db) {
        var me = this;
        var structArray = Object.keys(me.icn3d.structures);

        var url;

        if (structArray.length === 1) {
            url = "https://www.ncbi.nlm.nih.gov/" + db + "/?term=" + structArray[0];
            me.setLogCmd("Entrez " + db + " about PDB " + structArray[0] + ": " + url, false);

            window.open(url, '_blank');
        }
        else if (structArray.length === 2) {
            url = "https://www.ncbi.nlm.nih.gov/" + db + "/?term=" + structArray[0] + " OR " + structArray[1];
            me.setLogCmd("Entrez " + db + " about PDB " + structArray[0] + " OR " + structArray[1] + ": " + url, false);

            window.open(url, '_blank');
        }
    },

    shareLinkUrl: function () {
        var me = this;
        var url = "https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?";

        var pos = -1;
        if (me.cfg.inpara !== undefined) pos = me.cfg.inpara.indexOf('&command=');
        var inparaWithoutCommand = (pos !== -1) ? me.cfg.inpara.substr(0, pos) : me.cfg.inpara;

        var start = 0;
        if (inparaWithoutCommand !== undefined) {
            url += inparaWithoutCommand.substr(1) + '&command=';
            start = 1;
        }
        else {
            url += 'command=';
            start = 0;
        }

        var transformation = {};
        transformation.factor = me.icn3d._zoomFactor;
        transformation.mouseChange = me.icn3d.mouseChange;
        transformation.quaternion = me.icn3d.quaternion;

        var bCommands = false;
        for (var i = start, il = me.icn3d.commands.length; i < il; ++i) {
            bCommands = true;

            var command_tf = me.icn3d.commands[i].split('|||');

            if (i === il - 1) {
                //var transformation = (command_tf.length > 1) ? ('|||' + command_tf[1]) : '';
                if (i !== 1 && i !== 0) {
                    url += '; ';
                }
                url += command_tf[0] + '|||' + me.getTransformationStr(transformation);
            }
            else if (i === 1) {
                url += command_tf[0];
            }
            else if (i !== 1 && i !== il - 1) {
                url += '; ' + command_tf[0];
            }
        }

        // remove "&command="
        if (!bCommands) {
            url = url.substr(0, url.length - 9);
        }

        return url;
    },

    shareLink: function () {
        var me = this;
        var url = me.shareLinkUrl();

        me.setLogCmd("share link: " + url, false);

        if (url.length > 4000) alert("The url is more than 4000 characters and may not work. Please export the 'State File' and open it in the viewer.");

        //window.open(url, '_blank');

        /*
                   //https://gist.github.com/hayageek/4584508
                   var request = gapi.client.urlshortener.url.insert({
                        'resource': {
                          'longUrl': url
                        }
                   });
                   request.execute(function(response) {
                        var shorturl = 'Problem in getting shortened URL';
                        if(response.id !== undefined) {
                            shorturl = response.id;
                        }
        
                        $("#" + me.pre + "ori_url").val(url);
                        $("#" + me.pre + "short_url").val(shorturl);
        
                        me.openDialog(me.pre + 'dl_copyurl', 'Copy a Share Link URL');
                   });
        */

        //https://firebase.google.com/docs/dynamic-links/rest
        //Web API Key: AIzaSyBxl9CgM0dY5lagHL4UOhEpLWE1fuwdnvc
        var fdlUrl = "https://firebasedynamiclinks.googleapis.com/v1/shortLinks?key=AIzaSyBxl9CgM0dY5lagHL4UOhEpLWE1fuwdnvc";
        $.ajax({
            url: fdlUrl,
            type: 'POST',
            //data : {'longDynamicLink': 'https://d55qc.app.goo.gl/?link=' + url, "suffix": {"option": "SHORT"}},
            data: { 'longDynamicLink': 'https://d55qc.app.goo.gl/?link=' + encodeURIComponent(url) },
            dataType: 'json',
            success: function (data) {
                var shorturl = 'Problem in getting shortened URL';
                if (data.shortLink !== undefined) {
                    shorturl = data.shortLink;
                }

                $("#" + me.pre + "ori_url").val(url);
                $("#" + me.pre + "short_url").val(shorturl);

                me.openDialog(me.pre + 'dl_copyurl', 'Copy a Share Link URL');
            },
            error: function (xhr, textStatus, errorThrown) {
                var shorturl = 'Problem in getting shortened URL';

                $("#" + me.pre + "ori_url").val(url);
                $("#" + me.pre + "short_url").val(shorturl);

                me.openDialog(me.pre + 'dl_copyurl', 'Copy a Share Link URL');
            }
        });
    },

    exportInteractions: function () {
        var me = this;
        var text = '<html><body><b>Interacting residues</b>:<br/><table border=1 cellpadding=0 cellspacing=0><tr><th>Base Chain: Residues</th><th>Interacting Chain</th></tr>';

        //me.chainids2resids[fisrtChainid][secondChainid].push(resid);
        for (var fisrtChainid in me.chainids2resids) {
            for (var secondChainid in me.chainids2resids[fisrtChainid]) {
                text += '<tr><td>' + fisrtChainid + ': ';
                text += me.residueids2spec(me.chainids2resids[fisrtChainid][secondChainid]);
                text += '</td><td>' + secondChainid + '</td></tr>';
            }
        }

        text += '</table><br/></body></html>';

        me.saveFile(me.inputid + '_interactions.html', 'html', text);
    },

    // ====== functions end ===============

    // ====== events start ===============
    // back and forward arrows
    clickBack: function () {
        var me = this;
        $("#" + me.pre + "back").add("#" + me.pre + "mn6_back").click(function (e) {
            e.preventDefault();

            me.setLogCmd("back", false);
            me.back();
        });
    },

    clickForward: function () {
        var me = this;
        $("#" + me.pre + "forward").add("#" + me.pre + "mn6_forward").click(function (e) {
            e.preventDefault();

            me.setLogCmd("forward", false);
            me.forward();
        });
    },

    clickToggle: function () {
        var me = this;
        $("#" + me.pre + "toggle").add("#" + me.pre + "mn2_toggle").click(function (e) {
            //me.setLogCmd("toggle selection", true);
            me.toggleSelection();
            me.setLogCmd("toggle selection", true);
        });
    },

    clickHlColorYellow: function () {
        var me = this;
        $("#" + me.pre + "mn2_hl_clrYellow").click(function (e) {
            me.setLogCmd("set highlight color yellow", true);
            me.icn3d.hColor = new THREE.Color(0xFFFF00);
            me.icn3d.matShader = me.icn3d.setOutlineColor('yellow');
            me.icn3d.draw(); // required to make it work properly
        });
    },

    clickHlColorGreen: function () {
        var me = this;
        $("#" + me.pre + "mn2_hl_clrGreen").click(function (e) {
            me.setLogCmd("set highlight color green", true);
            me.icn3d.hColor = new THREE.Color(0x00FF00);
            me.icn3d.matShader = me.icn3d.setOutlineColor('green');
            me.icn3d.draw(); // required to make it work properly
        });
    },

    clickHlColorRed: function () {
        var me = this;
        $("#" + me.pre + "mn2_hl_clrRed").click(function (e) {
            me.setLogCmd("set highlight color red", true);
            me.icn3d.hColor = new THREE.Color(0xFF0000);
            me.icn3d.matShader = me.icn3d.setOutlineColor('red');
            me.icn3d.draw(); // required to make it work properly
        });
    },

    clickHlStyleOutline: function () {
        var me = this;
        $("#" + me.pre + "mn2_hl_styleOutline").click(function (e) {
            me.setLogCmd("set highlight style outline", true);
            me.icn3d.bHighlight = 1;

            me.showHighlight();

            //me.icn3d.draw();
        });
    },

    clickHlStyleObject: function () {
        var me = this;
        $("#" + me.pre + "mn2_hl_styleObject").click(function (e) {
            me.setLogCmd("set highlight style 3d", true);
            me.icn3d.bHighlight = 2;

            me.showHighlight();

            //me.icn3d.draw();
        });
    },

    clickHlStyleNone: function () {
        var me = this;
        $("#" + me.pre + "mn2_hl_styleNone").click(function (e) {
            e.stopImmediatePropagation();

            me.clearHighlight();

            me.setLogCmd("clear selection", true);
        });
    },

    clickAlternate: function () {
        var me = this;
        $("#" + me.pre + "alternate").add("#" + me.pre + "mn2_alternate").click(function (e) {
            //me.setLogCmd("alternate structures", false);
            me.icn3d.bAlternate = true;

            me.icn3d.alternateStructures();

            me.icn3d.bAlternate = false;
            me.setLogCmd("alternate structures", false);
        });
    },

    //mn 1
    clkMn1_mmtfid: function () {
        var me = this;
        $("#" + me.pre + "mn1_mmtfid").click(function (e) {
            me.openDialog(me.pre + 'dl_mmtfid', 'Please input MMTF ID');
        });
    },

    clkMn1_pdbid: function () {
        var me = this;
        $("#" + me.pre + "mn1_pdbid").click(function (e) {
            me.openDialog(me.pre + 'dl_pdbid', 'Please input PDB ID');
        });
    },

    clkMn1_align: function () {
        var me = this;
        $("#" + me.pre + "mn1_align").click(function (e) {
            me.openDialog(me.pre + 'dl_align', 'Please input two PDB IDs or MMDB IDs');
        });
    },

    clkMn1_pdbfile: function () {
        var me = this;
        $("#" + me.pre + "mn1_pdbfile").click(function (e) {
            me.openDialog(me.pre + 'dl_pdbfile', 'Please input PDB File');
        });
    },

    clkMn1_mol2file: function () {
        var me = this;
        $("#" + me.pre + "mn1_mol2file").click(function (e) {
            me.openDialog(me.pre + 'dl_mol2file', 'Please input Mol2 File');
        });
    },
    clkMn1_sdffile: function () {
        var me = this;
        $("#" + me.pre + "mn1_sdffile").click(function (e) {
            me.openDialog(me.pre + 'dl_sdffile', 'Please input SDF File');
        });
    },
    clkMn1_xyzfile: function () {
        var me = this;
        $("#" + me.pre + "mn1_xyzfile").click(function (e) {
            me.openDialog(me.pre + 'dl_xyzfile', 'Please input XYZ File');
        });
    },
    clkMn1_urlfile: function () {
        var me = this;
        $("#" + me.pre + "mn1_urlfile").click(function (e) {
            me.openDialog(me.pre + 'dl_urlfile', 'Load data by URL');
        });
    },

    clkMn1_mmciffile: function () {
        var me = this;
        $("#" + me.pre + "mn1_mmciffile").click(function (e) {
            me.openDialog(me.pre + 'dl_mmciffile', 'Please input mmCIF File');
        });
    },

    clkMn1_mmcifid: function () {
        var me = this;
        $("#" + me.pre + "mn1_mmcifid").click(function (e) {
            me.openDialog(me.pre + 'dl_mmcifid', 'Please input mmCIF ID');
        });
    },

    clkMn1_mmdbid: function () {
        var me = this;
        $("#" + me.pre + "mn1_mmdbid").click(function (e) {
            me.openDialog(me.pre + 'dl_mmdbid', 'Please input MMDB ID');
        });
    },

    clkMn1_gi: function () {
        var me = this;
        $("#" + me.pre + "mn1_gi").click(function (e) {
            me.openDialog(me.pre + 'dl_gi', 'Please input protein gi');
        });
    },

    clkMn1_cid: function () {
        var me = this;
        $("#" + me.pre + "mn1_cid").click(function (e) {
            me.openDialog(me.pre + 'dl_cid', 'Please input PubChem CID');
        });
    },

    clkMn1_state: function () {
        var me = this;
        $("#" + me.pre + "mn1_state").click(function (e) {
            me.openDialog(me.pre + 'dl_state', 'Please input the state file');
        });
    },

    clkMn1_selection: function () {
        var me = this;
        $("#" + me.pre + "mn1_selection").click(function (e) {
            me.openDialog(me.pre + 'dl_selection', 'Please input the selection file');
        });
    },

    clkMn1_exportState: function () {
        var me = this;
        $("#" + me.pre + "mn1_exportState").click(function (e) {
            me.setLogCmd("export state file", false);

            me.saveFile(me.inputid + '_statefile.txt', 'command');
        });
    },

    exportStlFile: function (postfix) {
        var me = this;
        // assemblies
        if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly) {
            // use a smaller grid to build the surface for assembly
            me.icn3d.threshbox = 180 / Math.pow(me.icn3d.biomtMatrices.length, 0.33);

            me.icn3d.removeSurfaces();
            me.icn3d.applySurfaceOptions();
        }

        var text = me.saveStlFile();
        me.saveFile(me.inputid + postfix + '.stl', 'binary', text);

        // assemblies
        if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
            && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length > me.icn3d.maxAtoms3DMultiFile) {
            alert(me.icn3d.biomtMatrices.length + " files will be generated for this assembly. Please merge these files using some software and 3D print the merged file.");

            var identity = new THREE.Matrix4();
            identity.identity();

            var index = 1;
            for (var i = 0; i < me.icn3d.biomtMatrices.length; i++) {  // skip itself
                var mat = me.icn3d.biomtMatrices[i];
                if (mat === undefined) continue;

                // skip itself
                if (mat.equals(identity)) continue;

                var time = (i + 1) * 100;

                //https://stackoverflow.com/questions/1190642/how-can-i-pass-a-parameter-to-a-settimeout-callback
                setTimeout(function (mat, index) {
                    text = me.saveStlFile(mat);
                    me.saveFile(me.inputid + postfix + index + '.stl', 'binary', text);
                    text = '';
                }.bind(this, mat, index), time);

                ++index;
            }

            // reset grid to build the surface for assembly
            me.icn3d.threshbox = 180;
        }
    },

    exportVrmlFile: function (postfix) {
        var me = this;
        // assemblies
        if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly) {
            // use a smaller grid to build the surface for assembly
            me.icn3d.threshbox = 180 / Math.pow(me.icn3d.biomtMatrices.length, 0.33);

            me.icn3d.removeSurfaces();
            me.icn3d.applySurfaceOptions();
        }

        var text = me.saveVrmlFile();
        me.saveFile(me.inputid + postfix + '.wrl', 'text', text);

        // assemblies
        if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
            && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length > me.icn3d.maxAtoms3DMultiFile) {
            alert(me.icn3d.biomtMatrices.length + " files will be generated for this assembly. Please merge these files using some software and 3D print the merged file.");

            var identity = new THREE.Matrix4();
            identity.identity();

            var index = 1;
            for (var i = 0; i < me.icn3d.biomtMatrices.length; i++) {  // skip itself
                var mat = me.icn3d.biomtMatrices[i];
                if (mat === undefined) continue;

                // skip itself
                if (mat.equals(identity)) continue;

                var time = (i + 1) * 100;

                //https://stackoverflow.com/questions/1190642/how-can-i-pass-a-parameter-to-a-settimeout-callback
                setTimeout(function (mat, index) {
                    text = me.saveVrmlFile(mat);
                    me.saveFile(me.inputid + postfix + index + '.wrl', 'text', text);
                    text = '';
                }.bind(this, mat, index), time);

                ++index;
            }

            // reset grid to build the surface for assembly
            me.icn3d.threshbox = 180;
        }
    },

    clkMn1_exportStl: function () {
        var me = this;
        $("#" + me.pre + "mn1_exportStl").click(function (e) {
            me.setLogCmd("export stl file", false);

            //me.hideStabilizer();

            me.exportStlFile('');
        });
    },

    clkMn1_exportVrml: function () {
        var me = this;
        $("#" + me.pre + "mn1_exportVrml").click(function (e) {
            me.setLogCmd("export vrml file", false);

            //me.hideStabilizer();

            me.exportVrmlFile('');
        });
    },

    clkMn1_exportStlStab: function () {
        var me = this;
        $("#" + me.pre + "mn1_exportStlStab").click(function (e) {
            me.setLogCmd("export stl stabilizer file", false);

            //me.icn3d.bRender = false;

            me.hideStabilizer();
            me.resetAfter3Dprint();
            me.addStabilizer();

            me.exportStlFile('_stab');
        });
    },

    clkMn1_exportVrmlStab: function () {
        var me = this;
        $("#" + me.pre + "mn1_exportVrmlStab").click(function (e) {
            me.setLogCmd("export vrml stabilizer file", false);

            //me.icn3d.bRender = false;

            me.hideStabilizer();
            me.resetAfter3Dprint();
            me.addStabilizer();

            me.exportVrmlFile('_stab');
        });
    },

    clkMn6_exportInteraction: function () {
        var me = this;
        $("#" + me.pre + "mn6_exportInteraction").click(function (e) {
            me.setLogCmd("export interactions", false);

            me.exportInteractions();
        });
    },

    clkMn1_exportCanvas: function () {
        var me = this;
        $("#" + me.pre + "mn1_exportCanvas").click(function (e) {
            me.setLogCmd("export canvas", false);

            me.saveFile(me.inputid + '_image.png', 'png');
        });
    },

    clkMn1_exportCounts: function () {
        var me = this;
        $("#" + me.pre + "mn1_exportCounts").click(function (e) {
            me.setLogCmd("export counts", false);

            var text = '<html><body><b>Total Count for atoms with coordinates</b>:<br/><table border=1><tr><th>Structure Count</th><th>Chain Count</th><th>Residue Count</th><th>Atom Count</th></tr>';

            text += '<tr><td>' + Object.keys(me.icn3d.structures).length + '</td><td>' + Object.keys(me.icn3d.chains).length + '</td><td>' + Object.keys(me.icn3d.residues).length + '</td><td>' + Object.keys(me.icn3d.atoms).length + '</td></tr>';

            text += '</table><br/>';

            text += '<b>Counts by Chain for atoms with coordinates</b>:<br/><table border=1><tr><th>Structure</th><th>Chain</th><th>Residue Count</th><th>Atom Count</th></tr>';

            var chainArray = Object.keys(me.icn3d.chains);
            for (var i = 0, il = chainArray.length; i < il; ++i) {
                var chainid = chainArray[i];
                var pos = chainid.indexOf('_');
                var structure = chainid.substr(0, pos);
                var chain = chainid.substr(pos + 1);

                var residueHash = {};
                var atoms = me.icn3d.chains[chainid];
                for (var j in atoms) {
                    residueHash[me.icn3d.atoms[j].resi] = 1;
                }

                text += '<tr><td>' + structure + '</td><td>' + chain + '</td><td>' + Object.keys(residueHash).length + '</td><td>' + Object.keys(me.icn3d.chains[chainid]).length + '</td></tr>';
            }

            text += '</table><br/></body></html>';

            me.saveFile(me.inputid + '_counts.html', 'html', text);
        });
    },

    clkMn1_exportSelections: function () {
        var me = this;
        $("#" + me.pre + "mn1_exportSelections").click(function (e) {
            me.setLogCmd("export all selections", false);

            var text = me.exportCustomAtoms();

            me.saveFile(me.inputid + '_selections.txt', 'text', [text]);
        });
    },

    clkMn1_sharelink: function () {
        var me = this;
        $("#" + me.pre + "mn1_sharelink").click(function (e) {
            me.shareLink();
        });
    },

    clkMn1_link_structure: function () {
        var me = this;
        $("#" + me.pre + "mn1_link_structure").click(function (e) {
            var url = me.getLinkToStructureSummary(true);

            window.open(url, '_blank');
        });
    },

    clkMn1_link_bind: function () {
        var me = this;
        $("#" + me.pre + "mn1_link_bind").click(function (e) {
            url = "https://www.ncbi.nlm.nih.gov/pccompound?LinkName=pccompound_structure&from_uid=" + me.inputid;
            me.setLogCmd("link to 3D protein structures bound to CID " + me.inputid + ": " + url, false);

            window.open(url, '_blank');
        });
    },

    clkMn1_link_vast: function () {
        var me = this;
        $("#" + me.pre + "mn1_link_vast").click(function (e) {
            if (me.inputid === undefined) {
                url = "https://www.ncbi.nlm.nih.gov/pccompound?term=" + me.icn3d.molTitle;
                me.setLogCmd("link to compounds " + me.icn3d.molTitle + ": " + url, false);
            }
            else {
                if (me.cfg.cid !== undefined) {
                    url = "https://www.ncbi.nlm.nih.gov/pccompound?LinkName=pccompound_pccompound_3d&from_uid=" + me.inputid;
                    me.setLogCmd("link to compounds with structure similar to CID " + me.inputid + ": " + url, false);
                }
                else {
                    var idArray = me.inputid.split('_');

                    var url;
                    if (idArray.length === 1) {
                        url = "https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?uid=" + me.inputid;
                        me.setLogCmd("link to structures similar to " + me.inputid + ": " + url, false);
                    }
                    else if (idArray.length === 2) {
                        url = "https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?uid=" + idArray[0];
                        me.setLogCmd("link to structures similar to " + idArray[0] + ": " + url, false);
                    }
                }

                window.open(url, '_blank');
            }
        });
    },

    clkMn1_link_pubmed: function () {
        var me = this;
        $("#" + me.pre + "mn1_link_pubmed").click(function (e) {
            var url;
            if (me.inputid === undefined) {
                var url;
                url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + me.icn3d.molTitle;
                me.setLogCmd("link to literature about " + me.icn3d.molTitle + ": " + url, false);

                window.open(url, '_blank');
            }
            else if (me.pmid !== undefined) {
                var idArray = me.pmid.toString().split('_');

                var url;
                if (idArray.length === 1) {
                    url = "https://www.ncbi.nlm.nih.gov/pubmed/" + me.pmid;
                    me.setLogCmd("link to PubMed ID " + me.pmid + ": " + url, false);
                }
                else if (idArray.length === 2) {
                    url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + idArray[0] + " OR " + idArray[1];
                    me.setLogCmd("link to PubMed IDs " + idArray[0] + ", " + idArray[1] + ": " + url, false);
                }

                window.open(url, '_blank');
            }
            else if (isNaN(me.inputid)) {
                var idArray = me.inputid.toString().split('_');

                var url;
                if (idArray.length === 1) {
                    url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + me.inputid;
                    me.setLogCmd("link to literature about PDB " + me.inputid + ": " + url, false);
                }
                else if (idArray.length === 2) {
                    url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + idArray[0] + " OR " + idArray[1];
                    me.setLogCmd("link to literature about PDB " + idArray[0] + " OR " + idArray[1] + ": " + url, false);
                }

                window.open(url, '_blank');
            }
            else {
                if (me.cfg.cid !== undefined) {
                    alert("No literature information is available for this compound in the SDF file.");
                }
                else {
                    alert("No literature information is available for this structure.");
                }
            }
        });
    },

    clkMn1_link_protein: function () {
        var me = this;
        $("#" + me.pre + "mn1_link_protein").click(function (e) {
            //me.setEntrezLinks('protein');
            var structArray = Object.keys(me.icn3d.structures);

            var chainArray = Object.keys(me.icn3d.chains);
            var text = '';
            for (var i = 0, il = chainArray.length; i < il; ++i) {
                var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chainArray[i]]);

                if (me.icn3d.proteins.hasOwnProperty(firstAtom.serial) && chainArray[i].length == 6) {
                    text += chainArray[i] + '[accession] OR ';
                }
            }
            if (text.length > 0) text = text.substr(0, text.length - 4);

            var url = "https://www.ncbi.nlm.nih.gov/protein/?term=" + text;
            me.setLogCmd("link to Entrez protein about PDB " + structArray + ": " + url, false);

            window.open(url, '_blank');
        });
    },

    // mn 2
    clkMn2_selectannotations: function () {
        var me = this;
        $("#" + me.pre + "mn6_selectannotations").click(function (e) {
            me.showAnnotations();
            me.setLogCmd("view annotations", true);
        });
    },

    clkMn2_selectall: function () {
        var me = this;
        $("#" + me.pre + "mn2_selectall").click(function (e) {
            me.setLogCmd("select all", true);

            me.selectAll();

            // do not highlight
            //me.removeHlAll();
            me.removeSelection();

            //me.icn3d.addHlObjects();
            me.icn3d.draw();

        });

        $("#" + me.pre + "clearall").click(function (e) {
            me.setLogCmd("clear all", true);

            me.selectAll();

            me.removeHlAll();

            me.icn3d.draw();

        });

    },

    clkMn2_selectcomplement: function () {
        var me = this;
        $("#" + me.pre + "mn2_selectcomplement").click(function (e) {
            if (Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) {
                me.setLogCmd("select complement", true);

                me.selectComplement();
            }
        });
    },

    clkMn2_alignment: function () {
        var me = this;
        $("#" + me.pre + "mn2_alignment").click(function (e) {
            me.openDialog(me.pre + 'dl_alignment', 'Select residues in aligned sequences');
        });
    },

    clkMn2_command: function () {
        var me = this;
        $("#" + me.pre + "mn2_command").click(function (e) {
            me.openDialog(me.pre + 'dl_command', 'Selection by specification');
        });
    },

    clkMn2_definedsets: function () {
        var me = this;
        $("#" + me.pre + "mn2_definedsets").add("#" + me.pre + "definedsets").click(function (e) {
            me.showSets();

            me.setLogCmd('defined sets', true);
        });
    },

    clkMn2_pkNo: function () {
        var me = this;
        $("#" + me.pre + "mn2_pkNo").click(function (e) {
            me.icn3d.pk = 0;
            me.icn3d.opts['pk'] = 'no';
            me.setLogCmd('set pk off', true);

            me.icn3d.draw();
            me.icn3d.removeHlObjects();
        });
    },

    clkMn2_pkYes: function () {
        var me = this;
        $("#" + me.pre + "mn2_pkYes").click(function (e) {
            me.icn3d.pk = 1;
            me.icn3d.opts['pk'] = 'atom';
            me.setLogCmd('set pk atom', true);
        });
    },

    clkMn2_pkResidue: function () {
        var me = this;
        $("#" + me.pre + "mn2_pkResidue").click(function (e) {
            me.icn3d.pk = 2;
            me.icn3d.opts['pk'] = 'residue';
            me.setLogCmd('set pk residue', true);
        });
    },

    clkMn2_pkStrand: function () {
        var me = this;
        $("#" + me.pre + "mn2_pkStrand").click(function (e) {
            me.icn3d.pk = 3;
            me.icn3d.opts['pk'] = 'strand';
            me.setLogCmd('set pk strand', true);
        });
    },

    clkMn2_pkChain: function () {
        var me = this;
        $("#" + me.pre + "mn2_pkChain").click(function (e) {
            me.icn3d.pk = 4;
            me.icn3d.opts['pk'] = 'chain';
            me.setLogCmd('set pk chain', true);
        });
    },

    clkMn2_aroundsphere: function () {
        var me = this;
        $("#" + me.pre + "mn2_aroundsphere").click(function (e) {
            me.openDialog(me.pre + 'dl_aroundsphere', 'Select a sphere around current selection');
        });
    },

    clkMn2_select_chain: function () {
        var me = this;
        $("#" + me.pre + "mn2_select_chain").add("#" + me.pre + "definedSets").click(function (e) {
            me.openDialog(me.pre + 'dl_select_chain', 'Select Structure/Chain/Custom Selection');
        });
    },

    // mn 3
    clkMn3_proteinsRibbon: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsRibbon").click(function (e) {
            me.setStyle('proteins', 'ribbon');
            me.setLogCmd('style proteins ribbon', true);
        });
    },

    clkMn3_proteinsStrand: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsStrand").click(function (e) {
            me.setStyle('proteins', 'strand');

            me.setLogCmd('style proteins strand', true);
        });
    },

    clkMn3_proteinsCylinder: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsCylinder").click(function (e) {
            me.setStyle('proteins', 'cylinder and plate');
            me.setLogCmd('style proteins cylinder and plate', true);
        });
    },

    clkMn3_proteinsSchematic: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsSchematic").click(function (e) {
            me.setStyle('proteins', 'schematic');
            me.setLogCmd('style proteins schematic', true);
        });
    },

    clkMn3_proteinsCalpha: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsCalpha").click(function (e) {
            me.setStyle('proteins', 'c alpha trace');
            me.setLogCmd('style proteins c alpha trace', true);
        });
    },

    clkMn3_proteinsBfactor: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsBfactor").click(function (e) {
            me.setStyle('proteins', 'b factor tube');
            me.setLogCmd('style proteins b factor tube', true);
        });
    },

    clkMn3_proteinsLines: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsLines").click(function (e) {
            me.setStyle('proteins', 'lines');
            me.setLogCmd('style proteins lines', true);
        });
    },

    clkMn3_proteinsStick: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsStick").click(function (e) {
            me.setStyle('proteins', 'stick');
            me.setLogCmd('style proteins stick', true);
        });
    },

    clkMn3_proteinsBallstick: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsBallstick").click(function (e) {
            me.setStyle('proteins', 'ball and stick');
            me.setLogCmd('style proteins ball and stick', true);
        });
    },

    clkMn3_proteinsSphere: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsSphere").click(function (e) {
            me.setStyle('proteins', 'sphere');
            me.setLogCmd('style proteins sphere', true);
        });
    },

    clkMn3_proteinsNo: function () {
        var me = this;
        $("#" + me.pre + "mn3_proteinsNo").click(function (e) {
            me.setStyle('proteins', 'nothing');
            me.setLogCmd('style proteins nothing', true);
        });
    },

    clkMn3_sidecLines: function () {
        var me = this;
        $("#" + me.pre + "mn3_sidecLines").click(function (e) {
            me.setStyle('sidec', 'lines');
            me.setLogCmd('style sidec lines', true);
        });
    },

    clkMn3_sidecStick: function () {
        var me = this;
        $("#" + me.pre + "mn3_sidecStick").click(function (e) {
            me.setStyle('sidec', 'stick');
            me.setLogCmd('style sidec stick', true);
        });
    },

    clkMn3_sidecBallstick: function () {
        var me = this;
        $("#" + me.pre + "mn3_sidecBallstick").click(function (e) {
            me.setStyle('sidec', 'ball and stick');
            me.setLogCmd('style sidec ball and stick', true);
        });
    },

    clkMn3_sidecSphere: function () {
        var me = this;
        $("#" + me.pre + "mn3_sidecSphere").click(function (e) {
            me.setStyle('sidec', 'sphere');
            me.setLogCmd('style sidec sphere', true);
        });
    },

    clkMn3_sidecNo: function () {
        var me = this;
        $("#" + me.pre + "mn3_sidecNo").click(function (e) {
            me.setStyle('sidec', 'nothing');
            me.setLogCmd('style sidec nothing', true);
        });
    },


    clkMn3_nuclCartoon: function () {
        var me = this;
        $("#" + me.pre + "mn3_nuclCartoon").click(function (e) {
            me.setStyle('nucleotides', 'nucleotide cartoon');
            me.setLogCmd('style nucleotides nucleotide cartoon', true);
        });
    },

    clkMn3_nuclSchematic: function () {
        var me = this;
        $("#" + me.pre + "mn3_nuclSchematic").click(function (e) {
            me.setStyle('nucleotides', 'schematic');
            me.setLogCmd('style nucleotides schematic', true);
        });
    },

    clkMn3_nuclPhos: function () {
        var me = this;
        $("#" + me.pre + "mn3_nuclPhos").click(function (e) {
            me.setStyle('nucleotides', 'o3 trace');
            me.setLogCmd('style nucleotides o3 trace', true);
        });
    },

    clkMn3_nuclLines: function () {
        var me = this;
        $("#" + me.pre + "mn3_nuclLines").click(function (e) {
            me.setStyle('nucleotides', 'lines');
            me.setLogCmd('style nucleotides lines', true);
        });
    },

    clkMn3_nuclStick: function () {
        var me = this;
        $("#" + me.pre + "mn3_nuclStick").click(function (e) {
            me.setStyle('nucleotides', 'stick');
            me.setLogCmd('style nucleotides stick', true);
        });
    },

    clkMn3_nuclBallstick: function () {
        var me = this;
        $("#" + me.pre + "mn3_nuclBallstick").click(function (e) {
            me.setStyle('nucleotides', 'ball and stick');
            me.setLogCmd('style nucleotides ball and stick', true);
        });
    },

    clkMn3_nuclSphere: function () {
        var me = this;
        $("#" + me.pre + "mn3_nuclSphere").click(function (e) {
            me.setStyle('nucleotides', 'sphere');
            me.setLogCmd('style nucleotides sphere', true);
        });
    },

    clkMn3_nuclNo: function () {
        var me = this;
        $("#" + me.pre + "mn3_nuclNo").click(function (e) {
            me.setStyle('nucleotides', 'nothing');
            me.setLogCmd('style nucleotides nothing', true);
        });
    },

    clkMn3_ligLines: function () {
        var me = this;
        $("#" + me.pre + "mn3_ligLines").click(function (e) {
            me.setStyle('chemicals', 'lines');
            me.setLogCmd('style chemicals lines', true);
        });
    },

    clkMn3_ligStick: function () {
        var me = this;
        $("#" + me.pre + "mn3_ligStick").click(function (e) {
            me.setStyle('chemicals', 'stick');
            me.setLogCmd('style chemicals stick', true);
        });
    },

    clkMn3_ligBallstick: function () {
        var me = this;
        $("#" + me.pre + "mn3_ligBallstick").click(function (e) {
            me.setStyle('chemicals', 'ball and stick');
            me.setLogCmd('style chemicals ball and stick', true);
        });
    },

    clkMn3_ligSchematic: function () {
        var me = this;
        $("#" + me.pre + "mn3_ligSchematic").click(function (e) {
            me.setStyle('chemicals', 'schematic');
            me.setLogCmd('style chemicals schematic', true);
        });
    },

    clkMn3_ligSphere: function () {
        var me = this;
        $("#" + me.pre + "mn3_ligSphere").click(function (e) {
            me.setStyle('chemicals', 'sphere');
            me.setLogCmd('style chemicals sphere', true);
        });
    },

    clkMn3_ligNo: function () {
        var me = this;
        $("#" + me.pre + "mn3_ligNo").click(function (e) {
            me.setStyle('chemicals', 'nothing');
            me.setLogCmd('style chemicals nothing', true);
        });
    },

    clkMn3_ionsSphere: function () {
        var me = this;
        $("#" + me.pre + "mn3_ionsSphere").click(function (e) {
            me.setStyle('ions', 'sphere');
            me.setLogCmd('style ions sphere', true);
        });
    },

    clkMn3_ionsDot: function () {
        var me = this;
        $("#" + me.pre + "mn3_ionsDot").click(function (e) {
            me.setStyle('ions', 'dot');
            me.setLogCmd('style ions dot', true);
        });
    },

    clkMn3_ionsNo: function () {
        var me = this;
        $("#" + me.pre + "mn3_ionsNo").click(function (e) {
            me.setStyle('ions', 'nothing');
            me.setLogCmd('style ions nothing', true);
        });
    },

    clkMn3_waterSphere: function () {
        var me = this;
        $("#" + me.pre + "mn3_waterSphere").click(function (e) {
            me.setStyle('water', 'sphere');
            me.setLogCmd('style water sphere', true);
        });
    },

    clkMn3_waterDot: function () {
        var me = this;
        $("#" + me.pre + "mn3_waterDot").click(function (e) {
            me.setStyle('water', 'dot');
            me.setLogCmd('style water dot', true);
        });
    },

    clkMn3_waterNo: function () {
        var me = this;
        $("#" + me.pre + "mn3_waterNo").click(function (e) {
            me.setStyle('water', 'nothing');
            me.setLogCmd('style water nothing', true);
        });
    },

    // mn 4
    clkMn4_clrSpectrum: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrSpectrum").click(function (e) {
            me.setOption('color', 'spectrum');
            me.setLogCmd('color spectrum', true);
        });
    },

    clkMn4_clrChain: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrChain").click(function (e) {
            me.setOption('color', 'chain');
            me.setLogCmd('color chain', true);
        });
    },

    clkMn4_clrSS: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrSS").click(function (e) {
            me.setOption('color', 'secondary structure');
            me.setLogCmd('color secondary structure', true);
        });
    },

    clkMn4_clrResidue: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrResidue").click(function (e) {
            me.setOption('color', 'residue');
            me.setLogCmd('color residue', true);
        });
    },

    clkMn4_clrCharge: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrCharge").click(function (e) {
            me.setOption('color', 'charge');
            me.setLogCmd('color charge', true);
        });
    },

    clkMn4_clrHydrophobic: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrHydrophobic").click(function (e) {
            me.setOption('color', 'hydrophobic');
            me.setLogCmd('color hydrophobic', true);
        });
    },

    clkMn4_clrAtom: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrAtom").click(function (e) {
            me.setOption('color', 'atom');
            me.setLogCmd('color atom', true);
        });
    },

    clkMn4_clrConserved: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrConserved").click(function (e) {
            me.setOption('color', 'conserved');
            me.setLogCmd('color conserved', true);
        });
    },

    clkMn4_clrRed: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrRed").click(function (e) {
            me.setOption('color', 'red');
            me.setLogCmd('color red', true);
        });
    },

    clkMn4_clrGreen: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrGreen").click(function (e) {
            me.setOption('color', 'green');
            me.setLogCmd('color green', true);
        });
    },

    clkMn4_clrBlue: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrBlue").click(function (e) {
            me.setOption('color', 'blue');
            me.setLogCmd('color blue', true);
        });
    },

    clkMn4_clrMagenta: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrMagenta").click(function (e) {
            me.setOption('color', 'magenta');
            me.setLogCmd('color magenta', true);
        });
    },

    clkMn4_clrYellow: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrYellow").click(function (e) {
            me.setOption('color', 'yellow');
            me.setLogCmd('color yellow', true);
        });
    },

    clkMn4_clrCyan: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrCyan").click(function (e) {
            me.setOption('color', 'cyan');
            me.setLogCmd('color cyan', true);
        });
    },

    clkMn4_clrWhite: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrWhite").click(function (e) {
            me.setOption('color', 'white');
            me.setLogCmd('color white', true);
        });
    },

    clkMn4_clrGrey: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrGrey").click(function (e) {
            me.setOption('color', 'grey');
            me.setLogCmd('color grey', true);
        });
    },

    clkMn4_clrCustom: function () {
        var me = this;
        $("#" + me.pre + "mn4_clrCustom").click(function (e) {
            me.openDialog(me.pre + 'dl_clr', 'Color picker');
        });
    },

    // mn 5
    clkMn5_neighborsYes: function () {
        var me = this;
        $("#" + me.pre + "mn5_neighborsYes").click(function (e) {
            me.icn3d.bConsiderNeighbors = true;

            me.icn3d.removeLastSurface();
            me.icn3d.applySurfaceOptions();
            me.icn3d.render();

            me.setLogCmd('set surface neighbors on', true);
        });
    },

    clkMn5_neighborsNo: function () {
        var me = this;
        $("#" + me.pre + "mn5_neighborsNo").click(function (e) {
            me.icn3d.bConsiderNeighbors = false;

            me.icn3d.removeLastSurface();
            me.icn3d.applySurfaceOptions();
            me.icn3d.render();

            me.setLogCmd('set surface neighbors off', true);
        });
    },

    clkMn5_surfaceVDW: function () {
        var me = this;
        $("#" + me.pre + "mn5_surfaceVDW").click(function (e) {
            me.icn3d.bConsiderNeighbors = false;
            me.setOption('surface', 'Van der Waals surface');
            me.setLogCmd('set surface Van der Waals surface', true);
        });
    },

    clkMn5_surfaceSAS: function () {
        var me = this;
        $("#" + me.pre + "mn5_surfaceSAS").click(function (e) {
            me.icn3d.bConsiderNeighbors = false;
            me.setOption('surface', 'solvent accessible surface');
            me.setLogCmd('set surface solvent accessible surface', true);
        });
    },

    clkMn5_surfaceMolecular: function () {
        var me = this;
        $("#" + me.pre + "mn5_surfaceMolecular").click(function (e) {
            me.icn3d.bConsiderNeighbors = false;
            me.setOption('surface', 'molecular surface');
            me.setLogCmd('set surface molecular surface', true);
        });
    },

    clkMn5_surfaceVDWContext: function () {
        var me = this;
        $("#" + me.pre + "mn5_surfaceVDWContext").click(function (e) {
            me.icn3d.bConsiderNeighbors = true;
            me.setOption('surface', 'Van der Waals surface with context');
            me.setLogCmd('set surface Van der Waals surface with context', true);
        });
    },

    clkMn5_surfaceSASContext: function () {
        var me = this;
        $("#" + me.pre + "mn5_surfaceSASContext").click(function (e) {
            me.icn3d.bConsiderNeighbors = true;
            me.setOption('surface', 'solvent accessible surface with context');
            me.setLogCmd('set surface solvent accessible surface with context', true);
        });
    },

    clkMn5_surfaceMolecularContext: function () {
        var me = this;
        $("#" + me.pre + "mn5_surfaceMolecularContext").click(function (e) {
            me.icn3d.bConsiderNeighbors = true;
            me.setOption('surface', 'molecular surface with context');
            me.setLogCmd('set surface molecular surface with context', true);
        });
    },

    clkMn5_surfaceNo: function () {
        var me = this;
        $("#" + me.pre + "mn5_surfaceNo").click(function (e) {
            me.setOption('surface', 'nothing');
            me.setLogCmd('set surface nothing', true);
        });
    },

    clkMn5_opacity10: function () {
        var me = this;
        $("#" + me.pre + "mn5_opacity10").click(function (e) {
            me.setOption('opacity', '1.0');
            me.setLogCmd('set surface opacity 1.0', true);
        });
    },

    clkMn5_opacity09: function () {
        var me = this;
        $("#" + me.pre + "mn5_opacity09").click(function (e) {
            me.setOption('opacity', '0.9');
            me.setLogCmd('set surface opacity 0.9', true);
        });
    },

    clkMn5_opacity08: function () {
        var me = this;
        $("#" + me.pre + "mn5_opacity08").click(function (e) {
            me.setOption('opacity', '0.8');
            me.setLogCmd('set surface opacity 0.8', true);
        });
    },

    clkMn5_opacity07: function () {
        var me = this;
        $("#" + me.pre + "mn5_opacity07").click(function (e) {
            me.setOption('opacity', '0.7');
            me.setLogCmd('set surface opacity 0.7', true);
        });
    },

    clkMn5_opacity06: function () {
        var me = this;
        $("#" + me.pre + "mn5_opacity06").click(function (e) {
            me.setOption('opacity', '0.6');
            me.setLogCmd('set surface opacity 0.6', true);
        });
    },

    clkMn5_opacity05: function () {
        var me = this;
        $("#" + me.pre + "mn5_opacity05").click(function (e) {
            me.setOption('opacity', '0.5');
            me.setLogCmd('set surface opacity 0.5', true);
        });
    },

    clkMn5_wireframeYes: function () {
        var me = this;
        $("#" + me.pre + "mn5_wireframeYes").click(function (e) {
            me.setOption('wireframe', 'yes');
            me.setLogCmd('set surface wireframe on', true);
        });
    },

    clkMn5_wireframeNo: function () {
        var me = this;
        $("#" + me.pre + "mn5_wireframeNo").click(function (e) {
            me.setOption('wireframe', 'no');
            me.setLogCmd('set surface wireframe off', true);
        });
    },

    // mn 6
    clkMn6_assemblyYes: function () {
        var me = this;
        $("#" + me.pre + "mn6_assemblyYes").click(function (e) {
            me.icn3d.bAssembly = true;
            me.setLogCmd('set assembly on', true);
            me.icn3d.draw();
        });
    },

    clkMn6_assemblyNo: function () {
        var me = this;
        $("#" + me.pre + "mn6_assemblyNo").click(function (e) {
            me.icn3d.bAssembly = false;
            me.setLogCmd('set assembly off', true);
            me.icn3d.draw();
        });
    },

    clkMn6_addlabelResidues: function () {
        var me = this;
        $("#" + me.pre + "mn6_addlabelResidues").click(function (e) {
            //me.setLogCmd('add residue labels', true);

            me.icn3d.addResiudeLabels(me.icn3d.hAtoms);

            me.saveSelectionIfSelected();
            me.setLogCmd('add residue labels', true);
            me.icn3d.draw();
        });
    },

    clkMn6_addlabelChains: function () {
        var me = this;
        $("#" + me.pre + "mn6_addlabelChains").click(function (e) {
            me.addChainLabels(me.icn3d.hAtoms);

            me.saveSelectionIfSelected();
            me.setLogCmd('add chain labels', true);
            me.icn3d.draw();
        });
    },

    clkMn6_addlabelYes: function () {
        var me = this;
        $("#" + me.pre + "mn6_addlabelYes").click(function (e) {
            me.openDialog(me.pre + 'dl_addlabel', 'Add custom labels by selection');
            me.icn3d.pk = 1;
            me.icn3d.opts['pk'] = 'atom';
            me.icn3d.pickpair = true;
            me.icn3d.pAtomNum = 0;
        });
    },

    clkMn6_addlabelSelection: function () {
        var me = this;
        $("#" + me.pre + "mn6_addlabelSelection").click(function (e) {
            me.openDialog(me.pre + 'dl_addlabelselection', 'Add custom labels by the current selection');
        });
    },

    clkMn2_saveselection: function () {
        var me = this;
        $("#" + me.pre + "mn2_saveselection").click(function (e) {
            me.openDialog(me.pre + 'dl_saveselection', 'Save the current selection');
        });
    },

    clkMn6_addlabelNo: function () {
        var me = this;
        $("#" + me.pre + "mn6_addlabelNo").add("#" + me.pre + "removeLabels").click(function (e) {
            me.icn3d.pickpair = false;

            //me.icn3d.labels['residue'] = [];
            //me.icn3d.labels['custom'] = [];

            var select = "set labels off";
            me.setLogCmd(select, true);

            for (var name in me.icn3d.labels) {
                //if(name === 'residue' || name === 'custom') {
                me.icn3d.labels[name] = [];
                //}
            }

            me.icn3d.draw();
        });
    },

    clkMn6_distanceYes: function () {
        var me = this;
        $("#" + me.pre + "mn6_distanceYes").click(function (e) {
            me.openDialog(me.pre + 'dl_distance', 'Measure the distance of atoms');
            me.icn3d.pk = 1;
            me.icn3d.opts['pk'] = 'atom';
            me.icn3d.pickpair = true;
            me.icn3d.pAtomNum = 0;

            me.bMeasureDistance = true;
        });
    },

    clkMn6_distanceNo: function () {
        var me = this;
        $("#" + me.pre + "mn6_distanceNo").click(function (e) {
            me.icn3d.pickpair = false;

            var select = "set lines off";
            me.setLogCmd(select, true);

            me.icn3d.labels['distance'] = [];
            me.icn3d.lines['distance'] = [];

            me.icn3d.pk = 2;

            me.icn3d.draw();
        });
    },

    clkMn2_selectedcenter: function () {
        var me = this;
        $("#" + me.pre + "mn2_selectedcenter").add("#" + me.pre + "zoomin_selection").click(function (e) {
            //me.setLogCmd('zoom selection', true);

            me.icn3d.zoominSelection();
            me.icn3d.draw();
            me.setLogCmd('zoom selection', true);
        });
    },

    clkMn6_center: function () {
        var me = this;
        $("#" + me.pre + "mn6_center").click(function (e) {
            //me.setLogCmd('center selection', true);

            me.icn3d.centerSelection();
            me.icn3d.draw();
            me.setLogCmd('center selection', true);
        });
    },

    clkMn6_resetOrientation: function () {
        var me = this;
        $("#" + me.pre + "mn6_resetOrientation").add("#" + me.pre + "resetOrientation").click(function (e) {
            //me.setLogCmd('reset orientation', true);

            me.icn3d.resetOrientation();

            me.icn3d.applyOriginalColor();

            me.icn3d.draw();
            me.setLogCmd('reset orientation', true);
        });
    },

    clkMn6_chemicalbindingshow: function () {
        var me = this;
        $("#" + me.pre + "mn6_chemicalbindingshow").add("#" + me.pre + "chemicalbindingshow").click(function (e) {
            me.setOption('chemicalbinding', 'show');
            me.setLogCmd('set chemicalbinding show', true);
        });
    },

    clkMn6_chemicalbindinghide: function () {
        var me = this;
        $("#" + me.pre + "mn6_chemicalbindinghide").add("#" + me.pre + "chemicalbindinghide").click(function (e) {
            me.setOption('chemicalbinding', 'hide');
            me.setLogCmd('set chemicalbinding hide', true);
        });
    },

    clkMn6_rotateleft: function () {
        var me = this;
        $("#" + me.pre + "mn6_rotateleft").click(function (e) {
            me.setLogCmd('rotate left', true);

            me.icn3d.bStopRotate = false;
            me.icn3d.rotateCount = 0;
            me.icn3d.rotateCountMax = 6000;
            me.ROT_DIR = 'left';

            me.rotStruc('left');
        });
    },

    clkMn6_rotateright: function () {
        var me = this;
        $("#" + me.pre + "mn6_rotateright").click(function (e) {
            me.setLogCmd('rotate right', true);

            me.icn3d.bStopRotate = false;
            me.icn3d.rotateCount = 0;
            me.icn3d.rotateCountMax = 6000;
            me.ROT_DIR = 'right';

            me.rotStruc('right');
        });
    },

    clkMn6_rotateup: function () {
        var me = this;
        $("#" + me.pre + "mn6_rotateup").click(function (e) {
            me.setLogCmd('rotate up', true);

            me.icn3d.bStopRotate = false;
            me.icn3d.rotateCount = 0;
            me.icn3d.rotateCountMax = 6000;
            me.ROT_DIR = 'up';

            me.rotStruc('up');
        });
    },

    clkMn6_rotatedown: function () {
        var me = this;
        $("#" + me.pre + "mn6_rotatedown").click(function (e) {
            me.setLogCmd('rotate down', true);

            me.icn3d.bStopRotate = false;
            me.icn3d.rotateCount = 0;
            me.icn3d.rotateCountMax = 6000;
            me.ROT_DIR = 'down';

            me.rotStruc('down');
        });
    },

    clkMn6_cameraPers: function () {
        var me = this;
        $("#" + me.pre + "mn6_cameraPers").click(function (e) {
            me.setOption('camera', 'perspective');
            me.setLogCmd('set camera perspective', true);
        });
    },

    clkMn6_cameraOrth: function () {
        var me = this;
        $("#" + me.pre + "mn6_cameraOrth").click(function (e) {
            me.setOption('camera', 'orthographic');
            me.setLogCmd('set camera orthographic', true);
        });
    },

    clkMn6_bkgdBlack: function () {
        var me = this;
        $("#" + me.pre + "mn6_bkgdBlack").click(function (e) {
            me.setOption('background', 'black');
            me.setLogCmd('set background black', true);
        });
    },

    clkMn6_bkgdGrey: function () {
        var me = this;
        $("#" + me.pre + "mn6_bkgdGrey").click(function (e) {
            me.setOption('background', 'grey');
            me.setLogCmd('set background grey', true);
        });
    },

    clkMn6_bkgdWhite: function () {
        var me = this;
        $("#" + me.pre + "mn6_bkgdWhite").click(function (e) {
            me.setOption('background', 'white');
            me.setLogCmd('set background white', true);
        });
    },

    clkMn6_bkgdTransparent: function () {
        var me = this;
        $("#" + me.pre + "mn6_bkgdTransparent").click(function (e) {
            me.setOption('background', 'transparent');
            me.setLogCmd('set background transparent', true);
        });
    },

    clkMn6_showfogYes: function () {
        var me = this;
        $("#" + me.pre + "mn6_showfogYes").click(function (e) {
            me.setOption('fog', 'yes');
            me.setLogCmd('set fog on', true);
        });
    },

    clkMn6_showfogNo: function () {
        var me = this;
        $("#" + me.pre + "mn6_showfogNo").click(function (e) {
            me.setOption('fog', 'no');
            me.setLogCmd('set fog off', true);
        });
    },

    clkMn6_showslabYes: function () {
        var me = this;
        $("#" + me.pre + "mn6_showslabYes").click(function (e) {
            me.setOption('slab', 'yes');
            me.setLogCmd('set slab on', true);
        });
    },

    clkMn6_showslabNo: function () {
        var me = this;
        $("#" + me.pre + "mn6_showslabNo").click(function (e) {
            me.setOption('slab', 'no');
            me.setLogCmd('set slab off', true);
        });
    },

    clkMn6_showaxisYes: function () {
        var me = this;
        $("#" + me.pre + "mn6_showaxisYes").click(function (e) {
            me.setOption('axis', 'yes');
            me.setLogCmd('set axis on', true);
        });
    },

    clkMn6_showaxisNo: function () {
        var me = this;
        $("#" + me.pre + "mn6_showaxisNo").click(function (e) {
            me.setOption('axis', 'no');
            me.setLogCmd('set axis off', true);
        });
    },

    clkMn6_hbondsYes: function () {
        var me = this;
        $("#" + me.pre + "mn6_hbondsYes").click(function (e) {
            me.openDialog(me.pre + 'dl_hbonds', 'Hydrogen bonds to selection');
        });
    },

    clkMn6_hbondsNo: function () {
        var me = this;
        $("#" + me.pre + "mn6_hbondsNo").click(function (e) {
            var select = "set hbonds off";
            me.setLogCmd(select, true);

            me.icn3d.hideHbonds();
            me.icn3d.draw();
        });
    },

    clkmn1_stabilizerYes: function () {
        var me = this;
        $("#" + me.pre + "mn1_stabilizerYes").click(function (e) {
            //me.openDialog(me.pre + 'dl_stabilizer', 'Hydrogen bonds inside selection');

            var select = "stabilizer";

            me.addStabilizer();
            me.prepareFor3Dprint();
            //me.icn3d.draw();

            me.setLogCmd(select, true);
        });
    },

    clkmn1_stabilizerNo: function () {
        var me = this;
        $("#" + me.pre + "mn1_stabilizerNo").click(function (e) {
            var select = "set stabilizer off";
            me.setLogCmd(select, true);

            me.hideStabilizer();

            me.icn3d.draw();
        });
    },

    clkmn1_stabilizerOne: function () {
        var me = this;
        $("#" + me.pre + "mn1_stabilizerOne").click(function (e) {
            me.openDialog(me.pre + 'dl_stabilizer', 'Add One Stabilizer');
            me.icn3d.pk = 1;
            me.icn3d.opts['pk'] = 'atom';
            me.icn3d.pickpair = true;
            me.icn3d.pAtomNum = 0;
        });
    },

    clkmn1_stabilizerRmOne: function () {
        var me = this;
        $("#" + me.pre + "mn1_stabilizerRmOne").click(function (e) {
            me.openDialog(me.pre + 'dl_stabilizer_rm', 'Remove One Stabilizer');
            me.icn3d.pk = 1;
            me.icn3d.opts['pk'] = 'atom';
            me.icn3d.pickpair = true;
            me.icn3d.pAtomNum = 0;
        });
    },

    clkmn1_thicknessSet: function () {
        var me = this;
        $("#" + me.pre + "mn1_thicknessSet").click(function (e) {
            me.openDialog(me.pre + 'dl_thickness', 'Set Thickness for 3D Printing');
        });
    },

    clkmn1_thicknessReset: function () {
        var me = this;
        $("#" + me.pre + "mn1_thicknessReset").click(function (e) {
            var select = "reset thickness";
            me.setLogCmd(select, true);

            me.bSetThickness = false;

            me.resetAfter3Dprint();
            me.icn3d.draw();
        });
    },

    clkMn6_ssbondsYes: function () {
        var me = this;
        $("#" + me.pre + "mn6_ssbondsYes").click(function (e) {
            var select = "disulfide bonds";
            me.setLogCmd(select, true);

            me.showSsbonds();
        });
    },

    clkMn6_ssbondsNo: function () {
        var me = this;
        $("#" + me.pre + "mn6_ssbondsNo").click(function (e) {
            me.icn3d.opts["ssbonds"] = "no";

            var select = "set disulfide bonds off";
            me.setLogCmd(select, true);

            me.icn3d.lines['ssbond'] = [];

            me.setStyle('sidec', 'nothing');
        });
    },

    clkMn6_clbondsYes: function () {
        var me = this;
        $("#" + me.pre + "mn6_clbondsYes").click(function (e) {
            var select = "cross linkage";
            me.setLogCmd(select, true);

            me.icn3d.bShowCrossResidueBond = true;

            me.setStyle('proteins', 'lines')
            //me.icn3d.draw();
        });
    },

    clkMn6_clbondsNo: function () {
        var me = this;
        $("#" + me.pre + "mn6_clbondsNo").click(function (e) {
            me.icn3d.opts["clbonds"] = "no";

            var select = "set cross linkage off";
            me.setLogCmd(select, true);

            me.icn3d.bShowCrossResidueBond = false;
            //me.opts['proteins'] = 'ribbon';

            //me.icn3d.draw();
            me.setStyle('proteins', 'ribbon')
        });
    },

    // other
    clickViewswitch: function () {
        var me = this;
        /*
                $("#" + me.pre + "viewswitch").click(function (e) {
                    if($("#" + me.pre + "viewswitch")[0].checked) { // mode: Detailed View
                        me.setAnnoViewAndDisplay('overview');
                        me.setLogCmd("set view overview", true);
                    }
                    else { // mode: all
                        me.setAnnoViewAndDisplay('detailed view');
                        me.setLogCmd("set view detailed view", true);
                    }
                });
        */
        $("#" + me.pre + "anno_summary").click(function (e) {
            e.preventDefault();

            me.setAnnoViewAndDisplay('overview');
            me.setLogCmd("set view overview", true);
        });

        $("#" + me.pre + "anno_details").click(function (e) {
            e.preventDefault();

            me.setAnnoViewAndDisplay('detailed view');
            me.setLogCmd("set view detailed view", true);
        });
    },

    clickShow_annotations: function () {
        var me = this;
        $("#" + me.pre + "show_annotations").click(function (e) {
            me.showAnnotations();
            me.setLogCmd("view annotations", true);
        });
    },

    clickShowallchains: function () {
        var me = this;
        $("#" + me.pre + "showallchains").click(function (e) {
            me.showAnnoAllChains();
            me.setLogCmd("show annotations all chains", true);
        });
    },

    clickShow_alignsequences: function () {
        var me = this;
        $("#" + me.pre + "show_alignsequences").click(function (e) {
            me.openDialog(me.pre + 'dl_alignment', 'Select residues in aligned sequences');
        });
    },

    clickShow_2ddgm: function () {
        var me = this;
        $("#" + me.pre + "show_2ddgm").add("#" + me.pre + "mn2_2ddgm").click(function (e) {
            me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');
            if (!me.b2DShown) {
                if (me.cfg.align !== undefined) {
                    var structureArray = Object.keys(me.icn3d.structures);
                    me.set2DDiagramsForAlign(structureArray[0].toUpperCase(), structureArray[1].toUpperCase());
                }
                else {
                    me.download2Ddgm(me.inputid.toUpperCase());
                }
            }

            me.setLogCmd("view interactions", true);
        });
    },

    clickSearchSeq: function () {
        var me = this;
        $(document).on("click", "#" + me.pre + "search_seq_button", function (e) {
            e.stopImmediatePropagation();

            var select = $("#" + me.pre + "search_seq").val();
            if (isNaN(select) && select.indexOf('$') == -1 && select.indexOf('.') == -1 && select.indexOf(':') == -1 && select.indexOf('@') == -1) {
                select = ':' + select;
            }

            var commandname = select;
            //var commanddesc = "search with the one-letter sequence " + select;
            var commanddesc = select;

            me.selectByCommand(select, commandname, commanddesc);
            //me.setLogCmd('select ' + select + ' | name ' + commandname + ' | description ' + commanddesc, true);
            me.setLogCmd('select ' + select + ' | name ' + commandname, true);
        });
    },

    clickReload_mmtf: function () {
        var me = this;
        $("#" + me.pre + "reload_mmtf").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");

            me.setLogCmd("load mmtf " + $("#" + me.pre + "mmtfid").val(), false);

            window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?mmtfid=' + $("#" + me.pre + "mmtfid").val(), '_blank');
        });
    },

    clickReload_pdb: function () {
        var me = this;
        $("#" + me.pre + "reload_pdb").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");

            me.setLogCmd("load pdb " + $("#" + me.pre + "pdbid").val(), false);

            window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?pdbid=' + $("#" + me.pre + "pdbid").val(), '_blank');
        });
    },

    clickReload_align_refined: function () {
        var me = this;
        $("#" + me.pre + "reload_align_refined").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");

            var alignment = $("#" + me.pre + "alignid1").val() + "," + $("#" + me.pre + "alignid2").val();

            me.setLogCmd("load alignment " + alignment + ' | parameters &atype=1', false);

            window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?align=' + alignment + '&showalignseq=1&atype=1', '_blank');
        });
    },

    clickReload_align_ori: function () {
        var me = this;
        $("#" + me.pre + "reload_align_ori").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");

            var alignment = $("#" + me.pre + "alignid1").val() + "," + $("#" + me.pre + "alignid2").val();

            me.setLogCmd("load alignment " + alignment + ' | parameters &atype=0', false);

            window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?align=' + alignment + '&showalignseq=1&atype=0', '_blank');
        });
    },

    clickReload_mmcif: function () {
        var me = this;
        $("#" + me.pre + "reload_mmcif").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");

            me.setLogCmd("load mmcif " + $("#" + me.pre + "mmcifid").val(), false);

            window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?mmcifid=' + $("#" + me.pre + "mmcifid").val(), '_blank');
        });
    },

    clickReload_mmdb: function () {
        var me = this;
        $("#" + me.pre + "reload_mmdb").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");

            me.setLogCmd("load mmdb " + $("#" + me.pre + "mmdbid").val(), false);

            //me.downloadMmdb($("#" + me.pre + "mmdbid").val());
            window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?mmdbid=' + $("#" + me.pre + "mmdbid").val(), '_blank');
        });
    },

    clickReload_gi: function () {
        var me = this;
        $("#" + me.pre + "reload_gi").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");

            me.setLogCmd("load gi " + $("#" + me.pre + "gi").val(), false);

            window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?gi=' + $("#" + me.pre + "gi").val(), '_blank');
        });
    },

    clickReload_cid: function () {
        var me = this;
        $("#" + me.pre + "reload_cid").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");

            me.setLogCmd("load cid " + $("#" + me.pre + "cid").val(), false);

            window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?cid=' + $("#" + me.pre + "cid").val(), '_blank');
        });
    },

    clickReload_state: function () {
        var me = this;
        $("#" + me.pre + "reload_state").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");
            //close all dialog
            $(".ui-dialog-content").dialog("close");

            // initialize icn3dui
            me.init();
            me.icn3d.init();

            var file = $("#" + me.pre + "state")[0].files[0];

            if (!file) {
                alert("Please select a file before clicking 'Load'");
            }
            else {
                if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                    alert('The File APIs are not fully supported in this browser.');
                }

                var reader = new FileReader();
                reader.onload = function (e) {
                    var dataStr = e.target.result; // or = reader.result;

                    me.setLogCmd('load state file ' + $("#" + me.pre + "state").val(), false);

                    me.icn3d.commands = [];
                    me.icn3d.optsHistory = [];

                    me.loadScript(dataStr, true);
                };

                reader.readAsText(file);
            }

        });
    },

    clickReload_selectionfile: function () {
        var me = this;
        $("#" + me.pre + "reload_selectionfile").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");

            var file = $("#" + me.pre + "selectionfile")[0].files[0];

            if (!file) {
                alert("Please select a file before clicking 'Load'");
            }
            else {
                if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                    alert('The File APIs are not fully supported in this browser.');
                }

                var reader = new FileReader();
                reader.onload = function (e) {
                    var dataStr = e.target.result; // or = reader.result;

                    //me.setLogCmd('load selection file ' + $("#" + me.pre + "selectionfile").val(), false);

                    me.loadSelection(dataStr);
                    me.setLogCmd('load selection file ' + $("#" + me.pre + "selectionfile").val(), false);
                };

                reader.readAsText(file);
            }

        });
    },

    clickReload_pdbfile: function () {
        var me = this;
        $("#" + me.pre + "reload_pdbfile").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");
            //close all dialog
            $(".ui-dialog-content").dialog("close");

            var file = $("#" + me.pre + "pdbfile")[0].files[0];

            if (!file) {
                alert("Please select a file before clicking 'Load'");
            }
            else {
                if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                    alert('The File APIs are not fully supported in this browser.');
                }

                var reader = new FileReader();
                reader.onload = function (e) {
                    var dataStr = e.target.result; // or = reader.result;

                    me.setLogCmd('load pdb file ' + $("#" + me.pre + "pdbfile").val(), false);

                    me.icn3d.molTitle = "";

                    me.loadPdbData(dataStr);
                };

                reader.readAsText(file);
            }

        });
    },

    clickReload_mol2file: function () {
        var me = this;
        $("#" + me.pre + "reload_mol2file").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");
            //close all dialog
            $(".ui-dialog-content").dialog("close");

            var file = $("#" + me.pre + "mol2file")[0].files[0];

            if (!file) {
                alert("Please select a file before clicking 'Load'");
            }
            else {
                if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                    alert('The File APIs are not fully supported in this browser.');
                }

                var reader = new FileReader();
                reader.onload = function (e) {
                    var dataStr = e.target.result; // or = reader.result;

                    me.setLogCmd('load mol2 file ' + $("#" + me.pre + "mol2file").val(), false);

                    me.icn3d.molTitle = "";

                    me.inputid = undefined;

                    me.loadMol2Data(dataStr);
                };

                reader.readAsText(file);
            }

        });
    },

    clickReload_sdffile: function () {
        var me = this;
        $("#" + me.pre + "reload_sdffile").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");
            //close all dialog
            $(".ui-dialog-content").dialog("close");

            var file = $("#" + me.pre + "sdffile")[0].files[0];

            if (!file) {
                alert("Please select a file before clicking 'Load'");
            }
            else {
                if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                    alert('The File APIs are not fully supported in this browser.');
                }

                var reader = new FileReader();
                reader.onload = function (e) {
                    var dataStr = e.target.result; // or = reader.result;

                    me.setLogCmd('load sdf file ' + $("#" + me.pre + "sdffile").val(), false);

                    me.icn3d.molTitle = "";
                    me.inputid = undefined;

                    me.loadSdfData(dataStr);
                };

                reader.readAsText(file);
            }

        });
    },

    clickReload_xyzfile: function () {
        var me = this;
        $("#" + me.pre + "reload_xyzfile").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");
            //close all dialog
            $(".ui-dialog-content").dialog("close");

            var file = $("#" + me.pre + "xyzfile")[0].files[0];

            if (!file) {
                alert("Please select a file before clicking 'Load'");
            }
            else {
                if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                    alert('The File APIs are not fully supported in this browser.');
                }

                var reader = new FileReader();
                reader.onload = function (e) {
                    var dataStr = e.target.result; // or = reader.result;

                    me.setLogCmd('load xyz file ' + $("#" + me.pre + "xyzfile").val(), false);

                    me.icn3d.molTitle = "";
                    me.inputid = undefined;

                    me.loadXyzData(dataStr);
                };

                reader.readAsText(file);
            }

        });
    },

    clickReload_urlfile: function () {
        var me = this;
        $("#" + me.pre + "reload_urlfile").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");
            //close all dialog
            $(".ui-dialog-content").dialog("close");

            var type = $("#" + me.pre + "filetype").val();
            var url = $("#" + me.pre + "urlfile").val();

            me.downloadUrl(url, type);
        });
    },

    clickReload_mmciffile: function () {
        var me = this;
        $("#" + me.pre + "reload_mmciffile").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");
            //close all dialog
            $(".ui-dialog-content").dialog("close");

            var file = $("#" + me.pre + "mmciffile")[0].files[0];

            if (!file) {
                alert("Please select a file before clicking 'Load'");
            }
            else {
                if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                    alert('The File APIs are not fully supported in this browser.');
                }

                var reader = new FileReader();
                reader.onload = function (e) {
                    var dataStr = e.target.result; // or = reader.result;

                    me.setLogCmd('load mmcif file ' + $("#" + me.pre + "mmciffile").val(), false);

                    me.icn3d.molTitle = "";

                    var url = "//www.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi";

                    me.icn3d.bCid = undefined;

                    $.ajax({
                        url: url,
                        type: 'POST',
                        data: { 'mmciffile': dataStr },
                        dataType: 'jsonp',
                        cache: true,
                        tryCount: 0,
                        retryLimit: 1,
                        beforeSend: function () {
                            if ($("#" + me.pre + "wait")) $("#" + me.pre + "wait").show();
                            if ($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").hide();
                            if ($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").hide();
                        },
                        complete: function () {
                            if ($("#" + me.pre + "wait")) $("#" + me.pre + "wait").hide();
                            if ($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").show();
                            if ($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").show();
                        },
                        success: function (data) {
                            me.loadMmcifData(data);
                        },
                        error: function (xhr, textStatus, errorThrown) {
                            this.tryCount++;
                            if (this.tryCount <= this.retryLimit) {
                                //try again
                                $.ajax(this);
                                return;
                            }
                            return;
                        }
                    });
                };

                reader.readAsText(file);
            }

        });
    },

    clickApplycustomcolor: function () {
        var me = this;
        $("#" + me.pre + "applycustomcolor").click(function (e) {
            e.preventDefault();
            dialog.dialog("close");

            me.setOption("color", $("#" + me.pre + "colorcustom").val());
            me.setLogCmd("color " + $("#" + me.pre + "colorcustom").val(), true);
        });
    },

    clickApplypick_aroundsphere: function () {
        var me = this;
        $("#" + me.pre + "applypick_aroundsphere").click(function (e) {
            e.preventDefault();

            dialog.dialog("close");
            var radius = parseFloat($("#" + me.pre + "radius_aroundsphere").val());

            var select = "select zone cutoff " + radius;
            //me.setLogCmd(select, true);

            me.pickCustomSphere(radius);

            me.updateHlAll();

            me.setLogCmd(select, true);
        });
    },

    clickApplyhbonds: function () {
        var me = this;
        $("#" + me.pre + "applyhbonds").click(function (e) {
            e.preventDefault();
            dialog.dialog("close");

            var threshold = parseFloat($("#" + me.pre + "hbondthreshold").val());

            var select = "hbonds " + threshold;
            //me.setLogCmd(select, true);

            me.showHbonds(threshold);
            me.setLogCmd(select, true);
        });
    },

    clickApplypick_labels: function () {
        var me = this;
        $("#" + me.pre + "applypick_labels").click(function (e) {
            e.preventDefault();
            dialog.dialog("close");

            var text = $("#" + me.pre + "labeltext").val();
            var size = $("#" + me.pre + "labelsize").val();
            var color = $("#" + me.pre + "labelcolor").val();
            var background = $("#" + me.pre + "labelbkgd").val();
            if (size === '0' || size === '' || size === 'undefined') size = 0;
            if (color === '0' || color === '' || color === 'undefined') color = 0;
            if (background === '0' || background === '' || background === 'undefined') background = 0;

            if (me.icn3d.pAtom === undefined || me.icn3d.pAtom2 === undefined) {
                alert("Please pick another atom");
            }
            else {
                var x = (me.icn3d.pAtom.coord.x + me.icn3d.pAtom2.coord.x) / 2;
                var y = (me.icn3d.pAtom.coord.y + me.icn3d.pAtom2.coord.y) / 2;
                var z = (me.icn3d.pAtom.coord.z + me.icn3d.pAtom2.coord.z) / 2;

                //me.setLogCmd('add label ' + text + ' | x ' + x  + ' y ' + y + ' z ' + z + ' | size ' + size + ' | color ' + color + ' | background ' + background + ' | type custom', true);

                me.addLabel(text, x, y, z, size, color, background, 'custom');

                me.icn3d.pickpair = false;

                var sizeStr = '', colorStr = '', backgroundStr = '';
                if (size != 0) sizeStr = ' | size ' + size;
                if (color != 0) colorStr = ' | color ' + color;
                if (background != 0) backgroundStr = ' | background ' + background;

                me.setLogCmd('add label ' + text + ' | x ' + x.toPrecision(4) + ' y ' + y.toPrecision(4) + ' z ' + z.toPrecision(4) + sizeStr + colorStr + backgroundStr + ' | type custom', true);
                me.icn3d.draw();
            }
        });
    },

    clickApplyselection_labels: function () {
        var me = this;
        $("#" + me.pre + "applyselection_labels").click(function (e) {
            e.preventDefault();
            dialog.dialog("close");

            var text = $("#" + me.pre + "labeltext2").val();
            var size = $("#" + me.pre + "labelsize2").val();
            var color = $("#" + me.pre + "labelcolor2").val();
            var background = $("#" + me.pre + "labelbkgd2").val();
            if (size === '0' || size === '' || size === 'undefined') size = 0;
            if (color === '0' || color === '' || color === 'undefined') color = 0;
            if (background === '0' || background === '' || background === 'undefined') background = 0;

            var position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.hAtoms));
            var x = position.center.x;
            var y = position.center.y;
            var z = position.center.z;

            //me.setLogCmd('add label ' + text + ' | size ' + size + ' | color ' + color + ' | background ' + background + ' | type custom', true);

            me.addLabel(text, x, y, z, size, color, background, 'custom');

            var sizeStr = '', colorStr = '', backgroundStr = '';
            if (size != 0) sizeStr = ' | size ' + size;
            if (color != 0) colorStr = ' | color ' + color;
            if (background != 0) backgroundStr = ' | background ' + background;

            me.setLogCmd('add label ' + text + ' | x ' + x.toPrecision(4) + ' y ' + y.toPrecision(4) + ' z ' + z.toPrecision(4) + sizeStr + colorStr + backgroundStr + ' | type custom', true);

            me.icn3d.draw();
        });
    },

    clickApplypick_stabilizer: function () {
        var me = this;
        $("#" + me.pre + "applypick_stabilizer").click(function (e) {
            e.preventDefault();
            dialog.dialog("close");

            if (me.icn3d.pAtom === undefined || me.icn3d.pAtom2 === undefined) {
                alert("Please pick another atom");
            }
            else {
                me.icn3d.pickpair = false;

                me.setLogCmd('add one stabilizer | ' + me.icn3d.pAtom.serial + ' ' + me.icn3d.pAtom2.serial, true);

                if (me.icn3d.pairArray === undefined) me.icn3d.pairArray = [];
                me.icn3d.pairArray.push(me.icn3d.pAtom.serial);
                me.icn3d.pairArray.push(me.icn3d.pAtom2.serial);

                //me.updateStabilizer();
                me.setThichknessFor3Dprint();

                me.icn3d.draw();
            }
        });
    },

    // https://github.com/tovic/color-picker
    pickColor: function () {
        var me = this;
        var picker = new CP(document.querySelector("#" + me.pre + "colorcustom"));

        picker.on("change", function (color) {
            this.target.value = color;
        });
    },

    clickApplypick_stabilizer_rm: function () {
        var me = this;
        $("#" + me.pre + "applypick_stabilizer_rm").click(function (e) {
            e.preventDefault();
            dialog.dialog("close");

            if (me.icn3d.pAtom === undefined || me.icn3d.pAtom2 === undefined) {
                alert("Please pick another atom");
            }
            else {
                me.icn3d.pickpair = false;

                me.setLogCmd('remove one stabilizer | ' + me.icn3d.pAtom.serial + ' ' + me.icn3d.pAtom2.serial, true);

                var rmLineArray = [];
                rmLineArray.push(me.icn3d.pAtom.serial);
                rmLineArray.push(me.icn3d.pAtom2.serial);

                me.removeOneStabilizer(rmLineArray);

                //me.updateStabilizer();

                me.icn3d.draw();
            }
        });
    },

    clickApplypick_measuredistance: function () {
        var me = this;
        $("#" + me.pre + "applypick_measuredistance").click(function (e) {
            e.preventDefault();
            dialog.dialog("close");
            me.bMeasureDistance = false;

            if (me.icn3d.pAtom === undefined || me.icn3d.pAtom2 === undefined) {
                alert("Please pick another atom");
            }
            else {
                var size = 0, color, background = 0;
                var color = $("#" + me.pre + "linecolor").val();

                var x = (me.icn3d.pAtom.coord.x + me.icn3d.pAtom2.coord.x) / 2;
                var y = (me.icn3d.pAtom.coord.y + me.icn3d.pAtom2.coord.y) / 2;
                var z = (me.icn3d.pAtom.coord.z + me.icn3d.pAtom2.coord.z) / 2;

                me.addLineFromPicking('distance');

                var distance = parseInt(me.icn3d.pAtom.coord.distanceTo(me.icn3d.pAtom2.coord) * 10) / 10;

                var text = distance.toString() + " A";

                me.addLabel(text, x, y, z, size, color, background, 'distance');

                var sizeStr = '', colorStr = '', backgroundStr = '';
                if (size != 0) sizeStr = ' | size ' + size;
                if (color != 0) colorStr = ' | color ' + color;
                if (background != 0) backgroundStr = ' | background ' + background;

                me.setLogCmd('add label ' + text + ' | x ' + x.toPrecision(4) + ' y ' + y.toPrecision(4) + ' z ' + z.toPrecision(4) + sizeStr + colorStr + backgroundStr + ' | type distance', true);

                me.icn3d.draw();

                me.icn3d.pk = 2;
            }
        });
    },

    clickApply_thickness: function () {
        var me = this;
        $("#" + me.pre + "apply_thickness").click(function (e) {
            e.preventDefault();
            //dialog.dialog( "close" );

            me.bSetThickness = true;

            me.icn3d.lineRadius = parseFloat($("#" + me.pre + "linerad").val()); //0.1; // hbonds, distance lines
            me.icn3d.coilWidth = parseFloat($("#" + me.pre + "coilrad").val()); //0.4; // style cartoon-coil
            me.icn3d.cylinderRadius = parseFloat($("#" + me.pre + "stickrad").val()); //0.4; // style stick
            me.icn3d.traceRadius = parseFloat($("#" + me.pre + "stickrad").val()); //0.2; // style c alpha trace, nucleotide stick
            me.icn3d.dotSphereScale = parseFloat($("#" + me.pre + "ballscale").val()); //0.3; // style ball and stick, dot

            me.icn3d.ribbonthickness = parseFloat($("#" + me.pre + "ribbonthick").val()); //0.4; // style ribbon, nucleotide cartoon, stand thickness
            me.icn3d.helixSheetWidth = parseFloat($("#" + me.pre + "prtribbonwidth").val()); //1.3; // style ribbon, stand thickness
            me.icn3d.nucleicAcidWidth = parseFloat($("#" + me.pre + "nucleotideribbonwidth").val()); //0.8; // nucleotide cartoon

            me.setLogCmd('set thickness | linerad ' + me.icn3d.lineRadius + ' | coilrad ' + me.icn3d.coilWidth + ' | stickrad ' + me.icn3d.cylinderRadius + ' | tracerad ' + me.icn3d.traceRadius + ' | ribbonthick ' + me.icn3d.ribbonthickness + ' | proteinwidth ' + me.icn3d.helixSheetWidth + ' | nucleotidewidth ' + me.icn3d.nucleicAcidWidth + ' | ballscale ' + me.icn3d.dotSphereScale, true);

            me.icn3d.draw();
        });
    },

    clickReset: function () {
        var me = this;
        $("#" + me.pre + "reset").click(function (e) {
            //me.setLogCmd("reset", true);

            //reset me.icn3d.maxD
            me.icn3d.maxD = me.icn3d.oriMaxD;
            me.icn3d.center = me.icn3d.oriCenter.clone();

            me.icn3d.reinitAfterLoad();

            me.renderFinalStep(1);
            me.setMode('all');

            me.setLogCmd("reset", true);

            me.removeSeqChainBkgd();
            me.removeSeqResidueBkgd();

            me.removeHl2D();
            me.removeHlMenus();
        });
    },

    clickToggleHighlight: function () {
        var me = this;
        $("#" + me.pre + "toggleHighlight").add("#" + me.pre + "toggleHighlight2").click(function (e) {
            e.stopImmediatePropagation();
            me.toggleHighlight();
        });

        $(document).on("click", "#" + me.pre + "seq_clearselection", function (e) {
            e.stopImmediatePropagation();
            dialog.dialog("close");

            me.clearHighlight();
        });

        $(document).on("click", "#" + me.pre + "seq_clearselection2", function (e) {
            e.stopImmediatePropagation();

            e.preventDefault();

            me.clearHighlight();
            me.setLogCmd("clear selection", true);
        });

        $(document).on("click", "#" + me.pre + "alignseq_clearselection", function (e) {
            e.stopImmediatePropagation();
            me.clearHighlight();
            me.setLogCmd("clear selection", true);
        });
    },

    pressCommandtext: function () {
        var me = this;
        $("#" + me.pre + "logtext").keypress(function (e) {
            me.bAddLogs = false; // turn off log

            var code = (e.keyCode ? e.keyCode : e.which);

            if (code == 13) { //Enter keycode
                e.preventDefault();

                var dataStr = $(this).val();

                me.icn3d.bRender = true;

                var commandArray = dataStr.split('\n');
                var lastCommand = commandArray[commandArray.length - 1].substr(2).trim(); // skip "> "
                me.icn3d.logs.push(lastCommand);
                $("#" + me.pre + "logtext").val("> " + me.icn3d.logs.join("\n> ") + "\n> ").scrollTop($("#" + me.pre + "logtext")[0].scrollHeight);

                if (lastCommand !== '') {
                    var transformation = {};
                    transformation.factor = me.icn3d._zoomFactor;
                    transformation.mouseChange = me.icn3d.mouseChange;
                    transformation.quaternion = me.icn3d.quaternion;

                    me.icn3d.commands.push(lastCommand + '|||' + me.getTransformationStr(transformation));
                    me.icn3d.optsHistory.push(me.icn3d.cloneHash(me.icn3d.opts));
                    me.icn3d.optsHistory[me.icn3d.optsHistory.length - 1].hlatomcount = Object.keys(me.icn3d.hAtoms).length;

                    if (me.isSessionStorageSupported()) me.saveCommandsToSession();

                    me.STATENUMBER = me.icn3d.commands.length;

                    if (lastCommand.indexOf('load') !== -1) {
                        me.applyCommandLoad(lastCommand);
                    }
                    else if (lastCommand.indexOf('view annotations') == 0
                        //|| lastCommand.indexOf('set annotation cdd') == 0
                        //|| lastCommand.indexOf('set annotation site') == 0
                    ) {
                        me.applyCommandAnnotationsAndCddSite(lastCommand);
                    }
                    else if (lastCommand.indexOf('set annotation clinvar') == 0
                        || lastCommand.indexOf('set annotation snp') == 0) {
                        me.applyCommandSnpClinvar(lastCommand);
                    }
                    else if (lastCommand.indexOf('set annotation 3ddomain') == 0) {
                        me.applyCommand3ddomain(lastCommand);
                    }
                    else if (lastCommand.indexOf('set annotation all') == 0) {
                        //$.when(me.applyCommandAnnotationsAndCddSite(lastCommand))
                        //    .then(me.applyCommandSnpClinvar(lastCommand))
                        $.when(me.applyCommandSnpClinvar(lastCommand))
                            .then(me.applyCommandSnpClinvar(lastCommand));

                        me.setAnnoTabAll();
                    }
                    else {
                        me.applyCommand(lastCommand + '|||' + me.getTransformationStr(transformation));
                    }

                    me.saveSelectionIfSelected();
                    me.icn3d.draw();
                }
            }

            me.bAddLogs = true;
        });
    },

    clickSeqSaveSelection: function () {
        var me = this;
        $(document).on("click", "#" + me.pre + "seq_saveselection", function (e) {
            e.stopImmediatePropagation();
            dialog.dialog("close");

            me.bSelectResidue = false;

            var name = $("#" + me.pre + "seq_command_name").val().replace(/\s+/g, '_');
            //var description = $("#" + me.pre + "seq_command_desc").val();

            me.saveSelection(name, name);
        });

        $(document).on("click", "#" + me.pre + "seq_saveselection2", function (e) {
            e.stopImmediatePropagation();

            me.bSelectResidue = false;

            var name = $("#" + me.pre + "seq_command_name2").val().replace(/\s+/g, '_');
            //var description = $("#" + me.pre + "seq_command_desc2").val();

            me.saveSelection(name, name);
        });
    },

    clickAlignSeqSaveSelection: function () {
        var me = this;
        $(document).on("click", "#" + me.pre + "alignseq_saveselection", function (e) {
            e.stopImmediatePropagation();
            me.bSelectAlignResidue = false;

            var name = $("#" + me.pre + "alignseq_command_name").val().replace(/\s+/g, '_');
            //var description = $("#" + me.pre + "alignseq_command_desc").val();

            me.saveSelection(name, name);
        });
    },

    clickOutputSelection: function () {
        var me = this;
        $(document).on("click", "." + me.pre + "outputselection", function (e) {
            e.stopImmediatePropagation();
            me.bSelectResidue = false;
            me.bSelectAlignResidue = false;
            me.setLogCmd('output selection', true);
            me.outputSelection();
        });
    },

    bindMouseup: function () {
        var me = this;
        $("accordion").bind('mouseup touchend', function (e) {
            if (me.icn3d.controls) {
                me.icn3d.controls.noRotate = false;
                me.icn3d.controls.noZoom = false;
                me.icn3d.controls.noPan = false;
            }
        });
    },

    bindMousedown: function () {
        var me = this;
        $("accordion").bind('mousedown touchstart', function (e) {
            if (me.icn3d.controls) {
                me.icn3d.controls.noRotate = true;
                me.icn3d.controls.noZoom = true;
                me.icn3d.controls.noPan = true;
            }
        });
    },

    expandShrink: function () {
        var me = this;
        //$("[id$=_cddseq_expand]").on('click', '.ui-icon-plus', function(e) {
        $(document).on("click", ".icn3d-expand", function (e) {
            e.stopImmediatePropagation();

            var oriId = $(this).attr('id');
            var pos = oriId.lastIndexOf('_');
            var id = oriId.substr(0, pos);

            $("#" + id).show();
            $("#" + id + "_expand").hide();
            $("#" + id + "_shrink").show();
        });

        //$("[id$=_cddseq_shrink]").on('click', '.ui-icon-minus', function(e) {
        $(document).on("click", ".icn3d-shrink", function (e) {
            e.stopImmediatePropagation();

            var oriId = $(this).attr('id');
            var pos = oriId.lastIndexOf('_');
            var id = oriId.substr(0, pos);

            $("#" + id).hide();
            $("#" + id + "_expand").show();
            $("#" + id + "_shrink").hide();
        });
    },

    scrollAnno: function () {
        var me = this;
        window.onscroll = function (e) {
            if (me.view == 'detailed view' && $(window).scrollTop() == 0 && $(window).scrollTop() == 0 && $("#" + me.pre + "dl_selectannotations").scrollTop() == 0) {
                // show fixed titles
                me.showFixedTitle();
            }
            else {
                // remove fixed titles
                me.hideFixedTitle();
            }
        };

        $("#" + me.pre + "dl_selectannotations").scroll(function () {
            if (me.view == 'detailed view' && $(window).scrollTop() == 0 && $(window).scrollTop() == 0 && $("#" + me.pre + "dl_selectannotations").scrollTop() == 0) {
                // show fixed titles
                me.showFixedTitle();
            }
            else {
                // remove fixed titles
                me.hideFixedTitle();
            }
        });
    },

    // ===== events end
    allEventFunctions: function () {
        var me = this;
        me.clickModeswitch();
        me.clickViewswitch();

        if (!me.isMobile()) {
            me.selectSequenceNonMobile();
        }
        else {
            me.selectSequenceMobile();
            me.selectChainMobile();
        }

        me.clickBack();
        me.clickForward();
        me.clickToggle();

        me.clickHlColorYellow();
        me.clickHlColorGreen();
        me.clickHlColorRed();
        me.clickHlStyleOutline();
        me.clickHlStyleObject();
        me.clickHlStyleNone();

        me.clickAlternate();
        me.clkMn1_mmtfid();
        me.clkMn1_pdbid();
        me.clkMn1_align();
        me.clkMn1_pdbfile();
        me.clkMn1_mol2file();
        me.clkMn1_sdffile();
        me.clkMn1_xyzfile();
        me.clkMn1_urlfile();
        me.clkMn1_mmciffile();
        me.clkMn1_mmcifid();
        me.clkMn1_mmdbid();
        me.clkMn1_gi();
        me.clkMn1_cid();
        me.clkMn1_state();
        me.clkMn1_selection();
        me.clkMn1_exportState();
        me.clkMn1_exportStl();
        me.clkMn1_exportVrml();
        me.clkMn1_exportStlStab();
        me.clkMn1_exportVrmlStab();
        me.clkMn6_exportInteraction();
        me.clkMn1_exportCanvas();
        me.clkMn1_exportCounts();
        me.clkMn1_exportSelections();
        me.clkMn1_sharelink();
        me.clkMn1_link_structure();
        me.clkMn1_link_bind();
        me.clkMn1_link_vast();
        me.clkMn1_link_pubmed();
        me.clkMn1_link_protein();
        //        me.clkMn1_link_gene();
        //        me.clkMn1_link_chemicals();
        me.clkMn2_selectannotations();
        //        me.clkMn2_selectresidues();
        me.clkMn2_selectcomplement();
        me.clkMn2_selectall();
        me.clkMn2_alignment();
        me.clkMn2_command();
        me.clkMn2_definedsets();
        me.clkMn2_pkYes();
        me.clkMn2_pkNo();
        me.clkMn2_pkResidue();
        me.clkMn2_pkStrand();
        me.clkMn2_pkChain();
        me.clkMn2_aroundsphere();
        me.clkMn2_select_chain();
        me.clkMn3_proteinsRibbon();
        me.clkMn3_proteinsStrand();
        me.clkMn3_proteinsCylinder();
        me.clkMn3_proteinsSchematic();
        me.clkMn3_proteinsCalpha();
        me.clkMn3_proteinsBfactor();
        me.clkMn3_proteinsLines();
        me.clkMn3_proteinsStick();
        me.clkMn3_proteinsBallstick();
        me.clkMn3_proteinsSphere();
        me.clkMn3_proteinsNo();
        me.clkMn3_sidecLines();
        me.clkMn3_sidecStick();
        me.clkMn3_sidecBallstick();
        me.clkMn3_sidecSphere();
        me.clkMn3_sidecNo();
        me.clkMn3_nuclCartoon();
        me.clkMn3_nuclSchematic();
        me.clkMn3_nuclPhos();
        me.clkMn3_nuclLines();
        me.clkMn3_nuclStick();
        me.clkMn3_nuclBallstick();
        me.clkMn3_nuclSphere();
        me.clkMn3_nuclNo();
        me.clkMn3_ligLines();
        me.clkMn3_ligStick();
        me.clkMn3_ligBallstick();
        me.clkMn3_ligSchematic();
        me.clkMn3_ligSphere();
        me.clkMn3_ligNo();
        me.clkMn3_ionsSphere();
        me.clkMn3_ionsDot();
        me.clkMn3_ionsNo();
        me.clkMn3_waterSphere();
        me.clkMn3_waterDot();
        me.clkMn3_waterNo();
        me.clkMn4_clrSpectrum();
        me.clkMn4_clrChain();
        me.clkMn4_clrSS();
        me.clkMn4_clrResidue();
        me.clkMn4_clrCharge();
        me.clkMn4_clrHydrophobic();
        me.clkMn4_clrAtom();
        me.clkMn4_clrConserved();
        me.clkMn4_clrRed();
        me.clkMn4_clrGreen();
        me.clkMn4_clrBlue();
        me.clkMn4_clrMagenta();
        me.clkMn4_clrYellow();
        me.clkMn4_clrCyan();
        me.clkMn4_clrWhite();
        me.clkMn4_clrGrey();
        me.clkMn4_clrCustom();
        me.clkMn5_neighborsYes();
        me.clkMn5_neighborsNo();
        me.clkMn5_surfaceVDW();
        //me.clkMn5_surfaceSES();
        me.clkMn5_surfaceSAS();
        me.clkMn5_surfaceMolecular();
        me.clkMn5_surfaceVDWContext();
        me.clkMn5_surfaceSASContext();
        me.clkMn5_surfaceMolecularContext();
        me.clkMn5_surfaceNo();
        me.clkMn5_opacity10();
        me.clkMn5_opacity09();
        me.clkMn5_opacity08();
        me.clkMn5_opacity07();
        me.clkMn5_opacity06();
        me.clkMn5_opacity05();
        me.clkMn5_wireframeYes();
        me.clkMn5_wireframeNo();
        me.clkMn6_assemblyYes();
        me.clkMn6_assemblyNo();
        me.clkMn6_addlabelResidues();
        me.clkMn6_addlabelChains();
        me.clkMn6_addlabelYes();
        me.clkMn6_addlabelSelection();
        me.clkMn2_saveselection();
        me.clkMn6_addlabelNo();
        me.clkMn6_distanceYes();
        me.clkmn1_stabilizerOne();
        me.clkmn1_stabilizerRmOne();
        me.clkmn1_thicknessSet();
        me.clkmn1_thicknessReset();
        me.clkMn6_distanceNo();
        me.clkMn2_selectedcenter();
        me.clkMn6_center();
        me.clkMn6_resetOrientation();
        me.clkMn6_chemicalbindingshow();
        me.clkMn6_chemicalbindinghide();
        me.clkMn6_rotateleft();
        me.clkMn6_rotateright();
        me.clkMn6_rotateup();
        me.clkMn6_rotatedown();
        me.clkMn6_cameraPers();
        me.clkMn6_cameraOrth();
        me.clkMn6_bkgdBlack();
        me.clkMn6_bkgdGrey();
        me.clkMn6_bkgdWhite();
        me.clkMn6_bkgdTransparent();
        me.clkMn6_showfogYes();
        me.clkMn6_showfogNo();
        me.clkMn6_showslabYes();
        me.clkMn6_showslabNo();
        me.clkMn6_showaxisYes();
        me.clkMn6_showaxisNo();
        me.clkMn6_hbondsYes();
        me.clkMn6_hbondsNo();
        me.clkmn1_stabilizerYes();
        me.clkmn1_stabilizerNo();
        me.clkMn6_ssbondsYes();
        me.clkMn6_ssbondsNo();
        me.clkMn6_clbondsYes();
        me.clkMn6_clbondsNo();
        me.clickCustomAtoms();
        me.clickShow_selected();
        me.clickShow_annotations();
        me.clickShowallchains();
        //        me.clickShow_sequences();
        me.clickShow_alignsequences();
        me.clickShow_2ddgm();
        //        me.clickShow_selected_atom();
        me.clickCommand_apply();
        me.clickSearchSeq();
        me.clickReload_pdb();
        me.clickReload_align_refined();
        me.clickReload_align_ori();
        me.clickReload_mmtf();
        me.clickReload_pdbfile();
        me.clickReload_mol2file();
        me.clickReload_sdffile();
        me.clickReload_xyzfile();
        me.clickReload_urlfile();
        me.clickReload_mmciffile();
        me.clickReload_mmcif();
        me.clickReload_mmdb();
        me.clickReload_gi();
        me.clickReload_cid();
        me.clickReload_state();
        me.clickReload_selectionfile();
        me.clickApplycustomcolor();
        me.clickApplypick_aroundsphere();
        me.clickApplyhbonds();
        //        me.clickApplystabilizer();
        me.clickApplypick_labels();
        me.clickApplyselection_labels();
        me.clickApplypick_measuredistance();
        me.clickApplypick_stabilizer();
        me.clickApplypick_stabilizer_rm();
        me.pickColor();
        me.clickApply_thickness();
        me.clickReset();
        me.clickToggleHighlight();
        me.pressCommandtext();
        //        me.clickFilter_ckbx_all();
        //        me.clickFilter();
        //        me.clickHighlight_3d_dgm();
        me.clickSeqSaveSelection();
        me.clickAlignSeqSaveSelection();
        me.clickOutputSelection();
        me.click2Ddgm();
        me.bindMouseup();
        me.bindMousedown();
        me.windowResize();
        me.setTabs();
        me.addTrack();
        me.clickAddTrackButton();

        me.expandShrink();
        me.scrollAnno();
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

/*! The following are shared by full_ui.js and simple_ui.js */

if (typeof jQuery === 'undefined') { throw new Error('iCn3DUI requires jQuery') }
if (typeof iCn3D === 'undefined') { throw new Error('iCn3DUI requires iCn3D') }

/*
iCn3DUI.prototype.clickHighlight_3d_dgm = function() { var me = this;
    $("#" + me.pre + "highlight_3d_dgm").click(function (e) {
       //e.preventDefault();
       me.icn3d.removeHlObjects();

       var ckbxes = document.getElementsByName(me.pre + "filter_ckbx");

       var mols = "";

       var molid2ssTmp = {}, molid2colorTmp = {};

       me.icn3d.hAtoms = {};
       for(var i = 0, il = ckbxes.length; i < il; ++i) { // skip the first "all" checkbox
         if(ckbxes[i].checked && ckbxes[i].value != 'chemicals') {
           var value = ckbxes[i].value;
           var chain = ckbxes[i].getAttribute('chain');

           if(me.icn3d.molid2ss.hasOwnProperty(value)) { // condensed view
               molid2ssTmp[value] = me.icn3d.molid2ss[value];
               molid2colorTmp[value] = me.icn3d.molid2color[value];
           }
           else { // all atom view
               me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[chain]);
           }
         }
       }

       me.icn3d.drawHelixBrick(molid2ssTmp, molid2colorTmp, me.icn3d.bHighlight); // condensed view
       me.icn3d.addHlObjects(undefined, false); // all atom view

       me.icn3d.render();
    });
};
*/

iCn3DUI.prototype.rotStruc = function (direction, bInitial) {
    var me = this;
    if (me.icn3d.bStopRotate) return false;
    if (me.icn3d.rotateCount > me.icn3d.rotateCountMax) {
        // back to the original orientation
        me.icn3d.resetOrientation();

        return false;
    }
    ++me.icn3d.rotateCount;

    if (bInitial !== undefined && bInitial) {
        if (direction === 'left') {
            me.ROT_DIR = 'left';
        }
        else if (direction === 'right') {
            me.ROT_DIR = 'right';
        }
        else if (direction === 'up') {
            me.ROT_DIR = 'up';
        }
        else if (direction === 'down') {
            me.ROT_DIR = 'down';
        }
        else {
            return false;
        }
    }

    if (direction === 'left' && me.ROT_DIR === 'left') {
        me.icn3d.rotateLeft(1);
    }
    else if (direction === 'right' && me.ROT_DIR === 'right') {
        me.icn3d.rotateRight(1);
    }
    else if (direction === 'up' && me.ROT_DIR === 'up') {
        me.icn3d.rotateUp(1);
    }
    else if (direction === 'down' && me.ROT_DIR === 'down') {
        me.icn3d.rotateDown(1);
    }
    else {
        return false;
    }

    setTimeout(function () { me.rotStruc(direction); }, 100);
};

iCn3DUI.prototype.showTitle = function () {
    var me = this;
    if (me.icn3d.molTitle !== undefined && me.icn3d.molTitle !== '') {
        var title = me.icn3d.molTitle;

        if (me.inputid === undefined) {
            if (me.icn3d.molTitle.length > 40) title = me.icn3d.molTitle.substr(0, 40) + "...";

            $("#" + me.pre + "title").html(title);
        }
        else if (me.cfg.cid !== undefined) {
            var url = me.getLinkToStructureSummary();

            $("#" + me.pre + "title").html("PubChem CID <a href='" + url + "' target='_blank' style='color:" + me.GREYD + "'>" + me.inputid.toUpperCase() + "</a>: " + title);
        }
        else if (me.cfg.align !== undefined) {
            $("#" + me.pre + "title").html(title);
        }
        else {
            var url = me.getLinkToStructureSummary();

            if (me.icn3d.molTitle.length > 40) title = me.icn3d.molTitle.substr(0, 40) + "...";

            //var asymmetricStr = (me.bAssemblyUseAsu) ? " (Asymmetric Unit)" : "";
            var asymmetricStr = "";

            $("#" + me.pre + "title").html("PDB ID <a href='" + url + "' target='_blank' style='color:" + me.GREYD + "'>" + me.inputid.toUpperCase() + "</a>" + asymmetricStr + ": " + title);
        }
    }
    else {
        $("#" + me.pre + "title").html("");
    }
};

iCn3DUI.prototype.getLinkToStructureSummary = function (bLog) {
    var me = this;

    var url = "https://www.ncbi.nlm.nih.gov/structure/?term=";

    if (me.cfg.cid !== undefined) {
        url = "https://www.ncbi.nlm.nih.gov/pccompound/?term=";
    }
    else {
        if (me.inputid.indexOf(",") !== -1) {
            url = "https://www.ncbi.nlm.nih.gov/structure/?term=";
        }
        else {
            //url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdbsrv.cgi?uid=";
            url = "https://www.ncbi.nlm.nih.gov/Structure/pdb/";
        }
    }

    if (me.inputid === undefined) {
        url = "https://www.ncbi.nlm.nih.gov/pccompound/?term=" + me.molTitle;
    }
    else {
        var idArray = me.inputid.split('_');

        if (idArray.length === 1) {
            url += me.inputid;
            if (bLog !== undefined && bLog) me.setLogCmd("link to Structure Summary " + me.inputid + ": " + url, false);
        }
        else if (idArray.length === 2) {
            url += idArray[0] + " OR " + idArray[1];
            if (bLog !== undefined && bLog) me.setLogCmd("link to structures " + idArray[0] + " and " + idArray[1] + ": " + url, false);
        }
    }

    return url;
},

    iCn3DUI.prototype.isIE = function () {
        var me = this;
        //http://stackoverflow.com/questions/19999388/check-if-user-is-using-ie-with-jquery
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf("MSIE ");

        if (msie > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./))      // If Internet Explorer
            return true;
        else                 // If another browser, return 0
            return false;
    };

iCn3DUI.prototype.getBlobFromBufferAndText = function (arrayBuffer, text) {
    var me = this;
    //var start = "data:image/png;base64,";

    //var strArray0 = new Uint8Array(start.length);
    //for(var i = 0; i < start.length; ++i) {
    //   strArray0[i] = me.passInt8([start.charCodeAt(i)])[0];
    //}

    var strArray = new Uint8Array(arrayBuffer);

    var strArray2 = new Uint8Array(text.length);
    for (var i = 0; i < text.length; ++i) {
        strArray2[i] = me.passInt8([text.charCodeAt(i)])[0];
    }

    var blobArray = []; // hold blobs

    //blobArray.push(new Blob([strArray0],{ type: "application/octet-stream"}));
    blobArray.push(new Blob([strArray], { type: "application/octet-stream" }));
    blobArray.push(new Blob([strArray2], { type: "application/octet-stream" }));

    //var blob = new Blob(blobArray,{ type: "application/octet-stream"});
    var blob = new Blob(blobArray, { type: "image/png" });

    return blob;
};

iCn3DUI.prototype.getTransformationStr = function (transformation) {
    var me = this;
    var transformation2 = { "factor": 1.0, "mouseChange": { "x": 0, "y": 0 }, "quaternion": { "_x": 0, "_y": 0, "_z": 0, "_w": 1 } };
    transformation2.factor = parseFloat(transformation.factor).toPrecision(5);
    transformation2.mouseChange.x = parseFloat(transformation.mouseChange.x).toPrecision(5);
    transformation2.mouseChange.y = parseFloat(transformation.mouseChange.y).toPrecision(5);
    transformation2.quaternion._x = parseFloat(transformation.quaternion._x).toPrecision(5);
    transformation2.quaternion._y = parseFloat(transformation.quaternion._y).toPrecision(5);
    transformation2.quaternion._z = parseFloat(transformation.quaternion._z).toPrecision(5);
    transformation2.quaternion._w = parseFloat(transformation.quaternion._w).toPrecision(5);

    if (transformation2.factor == '1.0000') transformation2.factor = 1;
    if (transformation2.mouseChange.x == '0.0000') transformation2.mouseChange.x = 0;
    if (transformation2.mouseChange.y == '0.0000') transformation2.mouseChange.y = 0;

    if (transformation2.quaternion._x == '0.0000') transformation2.quaternion._x = 0;
    if (transformation2.quaternion._y == '0.0000') transformation2.quaternion._y = 0;
    if (transformation2.quaternion._z == '0.0000') transformation2.quaternion._z = 0;
    if (transformation2.quaternion._w == '1.0000') transformation2.quaternion._w = 1;

    return JSON.stringify(transformation2);
};

iCn3DUI.prototype.createLinkForBlob = function (blob, filename) {
    var me = this;
    var link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    link.setAttribute('download', filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

iCn3DUI.prototype.saveFile = function (filename, type, text) {
    var me = this;
    //Save file
    var blob;

    if (type === 'command') {
        var dataStr = '';
        for (var i = 0, il = me.icn3d.commands.length; i < il; ++i) {
            var command = me.icn3d.commands[i].trim();
            if (i == il - 1) {
                var command_tf = command.split('|||');

                var transformation = {};
                transformation.factor = me.icn3d._zoomFactor;
                transformation.mouseChange = me.icn3d.mouseChange;
                transformation.quaternion = me.icn3d.quaternion;

                command = command_tf[0] + '|||' + me.getTransformationStr(transformation);
            }

            dataStr += command + '\n';
        }
        var data = decodeURIComponent(dataStr);

        blob = new Blob([data], { type: "text;charset=utf-8;" });
    }
    else if (type === 'png') {
        me.icn3d.render();

        var bAddURL = true;
        if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
            bAddURL = false;
        }

        if (me.isIE()) {
            blob = me.icn3d.renderer.domElement.msToBlob();

            if (bAddURL) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    var arrayBuffer = e.target.result; // or = reader.result;

                    var url = me.shareLinkUrl();

                    var text = "\nShare Link: " + url;
                    blob = me.getBlobFromBufferAndText(arrayBuffer, text);

                    //if(window.navigator.msSaveBlob) navigator.msSaveBlob(blob, filename);
                    saveAs(blob, filename);

                    return;
                };

                reader.readAsArrayBuffer(blob);
            }
        }
        else {
            me.icn3d.renderer.domElement.toBlob(function (data) {
                if (bAddURL) {
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        var arrayBuffer = e.target.result; // or = reader.result;

                        var url = me.shareLinkUrl();

                        var text = "\nShare Link: " + url;
                        blob = me.getBlobFromBufferAndText(arrayBuffer, text);

                        //me.createLinkForBlob(blob, filename);
                        saveAs(blob, filename);

                        return;
                    };

                    reader.readAsArrayBuffer(data);
                }
                else {
                    blob = data;

                    //me.createLinkForBlob(blob, filename);
                    saveAs(blob, filename);

                    return;
                }
            });
        }
    }
    else if (type === 'html') {
        var dataStr = text;
        var data = decodeURIComponent(dataStr);

        blob = new Blob([data], { type: "text/html;charset=utf-8;" });
    }
    else if (type === 'text') {
        //var dataStr = text;
        //var data = decodeURIComponent(dataStr);

        //blob = new Blob([data],{ type: "text;charset=utf-8;"});

        var data = text; // here text is an array of text

        blob = new Blob(data, { type: "text;charset=utf-8;" });
    }
    else if (type === 'binary') {
        var data = text; // here text is an array of blobs

        //blob = new Blob([data],{ type: "application/octet-stream"});
        blob = new Blob(data, { type: "application/octet-stream" });
    }

    /*
        //https://github.com/mholt/PapaParse/issues/175
        //IE11 & Edge
        if(me.isIE() && window.navigator.msSaveBlob){
            navigator.msSaveBlob(blob, filename);
        } else {
            //In FF link must be added to DOM to be clicked
            var link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    */

    //https://github.com/eligrey/FileSaver.js/
    saveAs(blob, filename);
};


iCn3DUI.prototype.isMobile = function () {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
};

iCn3DUI.prototype.isMac = function () {
    return /Mac/i.test(navigator.userAgent);
};

iCn3DUI.prototype.isSessionStorageSupported = function () {
    var testKey = 'test';
    try {
        sessionStorage.setItem(testKey, '1');
        sessionStorage.removeItem(testKey);
        return true;
    } catch (error) {
        return false;
    }
};

iCn3DUI.prototype.resizeCanvas = function (width, height, bForceResize, bDraw) {
    var me = this;
    if ((bForceResize !== undefined && bForceResize) || (me.cfg.resize !== undefined && me.cfg.resize)) {
        //var heightTmp = parseInt(height) - me.EXTRAHEIGHT;
        var heightTmp = height;
        $("#" + me.pre + "canvas").width(width).height(heightTmp);

        $("#" + me.pre + "viewer").width(width).height(height);

        me.icn3d.setWidthHeight(width, heightTmp);

        if (bDraw === undefined || bDraw) {
            me.icn3d.draw();
        }
    }
};

iCn3DUI.prototype.handleContextLost = function () {
    var me = this;
    //https://www.khronos.org/webgl/wiki/HandlingContextLost
    // 1 add a lost context handler and tell it to prevent the default behavior

    var canvas = $("#" + me.pre + "canvas")[0];
    canvas.addEventListener("webglcontextlost", function (event) {
        event.preventDefault();
    }, false);

    // 2 re-setup all your WebGL state and re-create all your WebGL resources when the context is restored.
    canvas.addEventListener("webglcontextrestored", function (event) {
        // IE11 error: WebGL content is taking too long to render on your GPU. Temporarily switching to software rendering.
        console.log("WebGL context was lost. Reset WebGLRenderer and launch iCn3D again.");

        me.icn3d.renderer = new THREE.WebGLRenderer({
            canvas: me.icn3d.container.get(0),
            antialias: true,
            preserveDrawingBuffer: true,
            alpha: true
        });

        me.icn3d.draw();

    }, false);
};

iCn3DUI.prototype.windowResize = function () {
    var me = this;
    if (me.cfg.resize !== undefined && me.cfg.resize && !me.isMobile()) {
        $(window).resize(function () {
            me.WIDTH = $(window).width();
            me.HEIGHT = $(window).height();

            var width = me.WIDTH - me.LESSWIDTH_RESIZE;
            var height = me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT;

            if (me.icn3d !== undefined) me.resizeCanvas(width, height);
        });
    }
};

iCn3DUI.prototype.setViewerWidthHeight = function () {
    var me = this;
    me.WIDTH = $(window).width();
    me.HEIGHT = $(window).height();

    var viewer_width = $("#" + me.pre + "viewer").width();
    var viewer_height = $("#" + me.pre + "viewer").height();

    if (viewer_width && me.WIDTH > viewer_width) me.WIDTH = viewer_width;
    if (viewer_height && me.HEIGHT > viewer_height) me.HEIGHT = viewer_height;

    if (me.isMac() && me.isMobile()) {
        if (me.WIDTH < me.MENU_WIDTH) me.WIDTH = me.MENU_WIDTH;

        me.HEIGHT = $(window).height() / $(window).width() * me.MENU_WIDTH;
    }

    if (me.cfg.width.toString().indexOf('%') === -1) {
        me.WIDTH = parseInt(me.cfg.width) + me.LESSWIDTH;
    }

    if (me.cfg.height.toString().indexOf('%') === -1) {
        me.HEIGHT = parseInt(me.cfg.height) + me.EXTRAHEIGHT + me.LESSHEIGHT;
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.showLoading = function () {
    var me = this;
    if ($("#" + me.pre + "wait")) $("#" + me.pre + "wait").show();
    if ($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").hide();
    if ($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").hide();
};

iCn3DUI.prototype.hideLoading = function () {
    var me = this;
    if (me.bCommandLoad === undefined || !me.bCommandLoad) {
        if ($("#" + me.pre + "wait")) $("#" + me.pre + "wait").hide();
        if ($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").show();
        if ($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").show();
    }
};

iCn3DUI.prototype.downloadMmcif = function (mmcifid) {
    var me = this;
    var url, dataType;

    url = "https://files.rcsb.org/view/" + mmcifid + ".cif";

    dataType = "text";

    me.icn3d.bCid = undefined;

    $.ajax({
        url: url,
        dataType: dataType,
        cache: true,
        tryCount: 0,
        retryLimit: 1,
        beforeSend: function () {
            me.showLoading();
        },
        complete: function () {
            me.hideLoading();
        },
        success: function (data) {
            url = "https://test.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi";

            $.ajax({
                url: url,
                type: 'POST',
                data: { 'mmciffile': data },
                dataType: 'jsonp',
                cache: true,
                tryCount: 0,
                retryLimit: 1,
                beforeSend: function () {
                    me.showLoading();
                },
                complete: function () {
                    me.hideLoading();
                },
                success: function (data) {
                    me.loadMmcifData(data);
                },
                error: function (xhr, textStatus, errorThrown) {
                    this.tryCount++;
                    if (this.tryCount <= this.retryLimit) {
                        //try again
                        $.ajax(this);
                        return;
                    }
                    return;
                }
            });
        },
        error: function (xhr, textStatus, errorThrown) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }
            return;
        }
    });
};

iCn3DUI.prototype.downloadMmcifSymmetry = function (mmcifid) {
    var me = this;
    // chain functions together
    me.deferredSymmetry = $.Deferred(function () {
        me.downloadMmcifSymmetryBase(mmcifid);
    }); // end of me.deferred = $.Deferred(function() {

    return me.deferredSymmetry.promise();
};

iCn3DUI.prototype.downloadMmcifSymmetryBase = function (mmcifid) {
    var me = this;
    var url, dataType;

    if (me.isMac()) { // safari has a problem in getting data from https://files.rcsb.org/header/
        url = "https://files.rcsb.org/view/" + mmcifid + ".cif";
    }
    else {
        url = "https://files.rcsb.org/header/" + mmcifid + ".cif";
    }

    dataType = "text";

    me.icn3d.bCid = undefined;

    $.ajax({
        url: url,
        dataType: dataType,
        cache: true,
        tryCount: 0,
        retryLimit: 1,
        success: function (data) {
            url = "https://www.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi";

            $.ajax({
                url: url,
                type: 'POST',
                data: { 'mmcifheader': data },
                dataType: 'jsonp',
                cache: true,
                tryCount: 0,
                retryLimit: 1,
                success: function (data) {
                    me.loadMmcifSymmetry(data);

                    if (me.deferredSymmetry !== undefined) me.deferredSymmetry.resolve();
                },
                error: function (xhr, textStatus, errorThrown) {
                    this.tryCount++;
                    if (this.tryCount <= this.retryLimit) {
                        //try again
                        $.ajax(this);
                        return;
                    }

                    if (me.deferredSymmetry !== undefined) me.deferredSymmetry.resolve();
                    return;
                }
            });
        },
        error: function (xhr, textStatus, errorThrown) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }

            return;
        }
    });
};

iCn3DUI.prototype.loadMmcifData = function (data) {
    var me = this;
    if (data.atoms !== undefined) {
        me.icn3d.init();

        me.loadAtomDataIn(data, data.mmcif, 'mmcifid');

        if (me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
            $("#" + me.pre + "alternateWrapper").hide();
        }

        // load assembly info
        var assembly = (data.assembly !== undefined) ? data.assembly : [];
        for (var i = 0, il = assembly.length; i < il; ++i) {
            if (me.icn3d.biomtMatrices[i] == undefined) me.icn3d.biomtMatrices[i] = new THREE.Matrix4().identity();

            for (var j = 0, jl = assembly[i].length; j < jl; ++j) {
                me.icn3d.biomtMatrices[i].elements[j] = assembly[i][j];
            }
        }

        if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1) {
            $("#" + me.pre + "assemblyWrapper").show();

            me.icn3d.asuCnt = me.icn3d.biomtMatrices.length;
        }
        else {
            $("#" + me.pre + "assemblyWrapper").hide();
        }

        me.icn3d.setAtomStyleByOptions(me.opts);
        me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

        me.renderStructure();

        if (me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

        //if(me.cfg.showseq !== undefined && me.cfg.showseq) me.openDialog(me.pre + 'dl_selectresidues', 'Select residues in sequences');

        if (me.deferred !== undefined) me.deferred.resolve(); if (me.deferred2 !== undefined) me.deferred2.resolve();
    }
    else {
        alert('invalid atoms data.');
        return false;
    }
};

iCn3DUI.prototype.loadMmcifSymmetry = function (data) {
    var me = this;
    // load assembly info
    var assembly = data.assembly;
    var pmatrix = data.pmatrix;

    for (var i = 0, il = assembly.length; i < il; ++i) {
        var mat4 = new THREE.Matrix4();
        mat4.fromArray(assembly[i]);

        me.icn3d.biomtMatrices[i] = mat4;
    }

    me.icn3d.asuCnt = me.icn3d.biomtMatrices.length;
};

iCn3DUI.prototype.downloadMmdb = function (mmdbid, bGi) {
    var me = this;
    //var maxatomcnt = (me.cfg.maxatomcnt === undefined) ? 50000 : me.cfg.maxatomcnt;
    var maxatomcnt = 100000; // asymmetric unit (buidx=0) will be returned if above this threshold

    var url;
    /*
       if(bGi !== undefined && bGi) {
           url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?program=w3d&seq=1&b&complexity=3&gi=" + mmdbid + "&ath=" + maxatomcnt;
       }
       else {
           url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?program=w3d&seq=1&b&complexity=3&uid=" + mmdbid + "&ath=" + maxatomcnt;
       }
    */

    if (bGi !== undefined && bGi) {
        url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&b&gi=" + mmdbid;
    }
    else {
        url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&b&uid=" + mmdbid;
    }

    me.icn3d.bCid = undefined;

    if (me.cfg.inpara !== undefined) {
        url += me.cfg.inpara;
    }

    if (me.chainids2resids === undefined) me.chainids2resids = {}; // me.chainids2resids[chainid1][chainid2] = [resid, resid]

    $.ajax({
        url: url,
        dataType: 'jsonp',
        cache: true,
        tryCount: 0,
        retryLimit: 1,
        beforeSend: function () {
            me.showLoading();
        },
        complete: function () {
            me.hideLoading();
        },
        success: function (data) {
            if (data.atoms === undefined && data.molid2rescount === undefined) {
                alert('invalid MMDB data.');
                return false;
            }

            me.icn3d.init();

            // used in download2Ddgm()
            me.interactionData = { "moleculeInfor": data.moleculeInfor, "intrac": data.intrac, "intracResidues": data.intracResidues };

            me.mmdb_data = data;

            var id = (data.pdbId !== undefined) ? data.pdbId : data.mmdbId;
            me.inputid = id;

            // get molid2color = {}, chain2molid = {}, molid2chain = {};
            var labelsize = 40;

            //var molid2rescount = data.molid2rescount;
            var molid2rescount = data.moleculeInfor;
            var molid2color = {}, chain2molid = {}, molid2chain = {};
            me.icn3d.chainsColor = {};

            var html = "<table width='100%'><tr><td></td><th>#</th><th align='center'>Chain</th><th align='center'>Residue Count</th></tr>";

            var index = 1;
            var chainNameHash = {};
            for (var i in molid2rescount) {
                var color = '#' + ('000000' + molid2rescount[i].color.toString(16)).slice(- 6);
                var chainName = molid2rescount[i].chain.trim();
                if (chainNameHash[chainName] === undefined) {
                    chainNameHash[chainName] = 1;
                }
                else {
                    ++chainNameHash[chainName];
                }

                var chainNameFinal = (chainNameHash[chainName] === 1) ? chainName : chainName + chainNameHash[chainName].toString();
                var chain = id + '_' + chainNameFinal;
                html += "<tr style='color:" + color + "'><td><input type='checkbox' name='" + me.pre + "filter_ckbx' value='" + i + "' chain='" + chain + "'/></td><td align='center'>" + index + "</td><td align='center'>" + chainNameFinal + "</td><td align='center'>" + molid2rescount[i].resCount + "</td></tr>";

                molid2color[i] = color;
                chain2molid[chain] = i;
                molid2chain[i] = chain;

                me.icn3d.chainsColor[chain] = new THREE.Color(color);
                ++index;
            }

            if (me.icn3d.chemicals !== undefined && Object.keys(me.icn3d.chemicals).length > 0) {
                html += "<tr><td><input type='checkbox' name='" + me.pre + "filter_ckbx' value='chemicals'/></td><td align='center'>" + index + "</td><td align='center'>Chemicals</td><td align='center'>" + Object.keys(me.icn3d.chemicals).length + " atoms</td></tr>";
            }

            html += "</table>";

            me.icn3d.molid2color = molid2color;
            me.icn3d.chain2molid = chain2molid;
            me.icn3d.molid2chain = molid2chain;

            //if ((me.cfg.inpara !== undefined && me.cfg.inpara.indexOf('mols=') != -1) || (data.atomcount <= maxatomcnt && data.atoms !== undefined) ) {
            // small structure with all atoms
            // show surface options
            $("#" + me.pre + "accordion5").show();

            me.loadAtomDataIn(data, id, 'mmdbid');

            // "asuAtomCount" is defined when: 1) atom count is over the threshold 2) buidx=1 3) asu atom count is smaller than biological unit atom count
            me.bAssemblyUseAsu = (data.asuAtomCount !== undefined) ? true : false;

            if (me.bAssemblyUseAsu) { // set up symmetric matrices
                $("#" + me.pre + "assemblyWrapper").show();
                me.icn3d.bAssembly = true;

                //me.downloadMmcifSymmetry(id);

                $.when(me.downloadMmcifSymmetry(id)).then(function () {
                    me.downloadMmdbPart2();
                });
            }
            else {
                $("#" + me.pre + "assemblyWrapper").hide();
                me.icn3d.bAssembly = false;

                me.downloadMmdbPart2();
            }
        },
        error: function (xhr, textStatus, errorThrown) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }

            if (bGi) {
                alert("This gi " + mmdbid + " has no corresponding 3D structure...");
            }
            else {
                alert("This mmdbid " + mmdbid + " with the parameters " + me.cfg.inpara + " has no corresponding 3D structure...");
            }

            return;
        } // success
    }); // ajax
};

iCn3DUI.prototype.downloadMmdbPart2 = function () {
    var me = this;
    me.icn3d.setAtomStyleByOptions(me.opts);
    // use the original color from cgi output
    me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms, true);

    me.renderStructure();
    if (me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

    me.html2ddgm = '';
    if (me.cfg.show2d !== undefined && me.cfg.show2d) {
        me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');
        me.download2Ddgm(me.inputid.toUpperCase());
        //me.download2Ddgm(Object.keys(me.icn3d.structures)[0].toUpperCase());
    }

    if (me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        if ($("#" + me.pre + "alternateWrapper") !== null) $("#" + me.pre + "alternateWrapper").hide();
    }

    if (me.deferred !== undefined) me.deferred.resolve(); if (me.deferred2 !== undefined) me.deferred2.resolve();
};

iCn3DUI.prototype.downloadGi = function (gi) {
    var me = this;
    me.icn3d.bCid = undefined;
    var bGi = true;
    me.downloadMmdb(gi, bGi);

};

iCn3DUI.prototype.getMissingResidues = function (seqArray, type, chainid) {
    var me = this;
    var prevResi = -9999;
    var missingResBegin = 0;
    var bCount = true;
    for (var i = 0, il = seqArray.length; i < il; ++i) {
        var seqName, resiPos;
        // mmdbid: ["0","R","ARG"],["502","V","VAL"]; mmcifid: [1, "ARG"]; align: [1, "0","R","ARG"]
        if (type === 'mmdbid') {
            seqName = seqArray[i][1];
            resiPos = 0;
        }
        else if (type === 'mmcifid') {
            seqName = seqArray[i][1];
            seqName = me.icn3d.residueName2Abbr(seqName);
            resiPos = 0;
        }
        else if (type === 'align') {
            seqName = seqArray[i][2];
            resiPos = 1;
        }

        // fixe some missing residue names such as residue 6 in 5C1M_A
        if (seqName === '') {
            seqName = 'x';
        }

        var resObject = {};
        resObject.resi = i + 1;
        var resi = parseInt(seqArray[i][resiPos]);
        var nextResi = (i == il - 1) ? 9999 : parseInt(seqArray[i + 1][resiPos]);

        if (resi !== 0 ||
            (resi === 0 && (prevResi === -1 || nextResi == 1))
        ) {
            resObject.name = seqName.toLowerCase();

            if (bCount && missingResBegin > 0) {
                if (me.countNextresiArray[chainid] === undefined) me.countNextresiArray[chainid] = [];

                var count_nextresi = [missingResBegin, parseInt(seqArray[i][0])];

                me.countNextresiArray[chainid].push(count_nextresi);

                missingResBegin = 0;
            }

            bCount = false;
        }
        //else if(resi === 0 && prevResi !== -1) { // sometimes resi could be -4, -3, -2, -1, 0 e.g., PDBID 4YPS
        else { // sometimes resi could be -4, -3, -2, -1, 0 e.g., PDBID 4YPS
            resObject.name = seqName.toLowerCase();
            ++missingResBegin;

            //if(me.chainMissingResidueArray[chainid] === undefined) me.chainMissingResidueArray[chainid] = [];
            //me.chainMissingResidueArray[chainid].push(resObject);

            bCount = true;
        }

        if (me.icn3d.chainsSeq[chainid] === undefined) me.icn3d.chainsSeq[chainid] = [];

        var numberStr = '';
        if (resObject.resi % 10 === 0) numberStr = resObject.resi.toString();

        me.icn3d.chainsSeq[chainid].push(resObject);

        prevResi = resi;
    }
};

iCn3DUI.prototype.loadAtomDataIn = function (data, id, type, seqalign) {
    var me = this;
    //me.icn3d.init();

    var pmin = new THREE.Vector3(9999, 9999, 9999);
    var pmax = new THREE.Vector3(-9999, -9999, -9999);
    var psum = new THREE.Vector3();

    var atoms = data.atoms;

    var serial = 0;
    var prevResi = 0;

    var serial2structure = {}; // for "align" only
    var mmdbid2pdbid = {}; // for "align" only

    me.pmid = data.pubmedId;

    var chainid2seq = {}, chainid2kind = {}, chainid2color = {};
    me.chainid2title = {};
    me.chainid2sid = {};

    if (type === 'align') {
        //serial2structure
        me.pmid = "";
        var refinedStr = (me.cfg.inpara.indexOf('atype=1') !== -1) ? 'Invariant Core ' : '';
        me.icn3d.molTitle = refinedStr + 'Structure Alignment of ';

        for (var i = 0, il = data.alignedStructures[0].length; i < il; ++i) {
            var structure = data.alignedStructures[0][i];

            if (i === 1) {
                me.icn3d.secondId = structure.pdbId; // set the second pdbid to add indent in the structure and chain mns
            }

            var pdbidTmp = structure.pdbId;
            var mmdbidTmp = structure.mmdbId;

            for (var j = structure.serialInterval[0], jl = structure.serialInterval[1]; j <= jl; ++j) {
                serial2structure[j] = pdbidTmp.toString();
                mmdbid2pdbid[mmdbidTmp] = pdbidTmp;
            }

            for (var j = 0, jl = structure.molecules.length; j < jl; ++j) {
                var chain = structure.molecules[j].chain;
                var kind = structure.molecules[j].kind;
                var title = structure.molecules[j].name;
                var seq = structure.molecules[j].sequence;
                var sid = structure.molecules[j].sid;

                var chainid = pdbidTmp + '_' + chain;

                chainid2seq[chainid] = seq;
                chainid2kind[chainid] = kind;

                me.chainid2title[chainid] = title;
                if (sid !== undefined) me.chainid2sid[chainid] = sid;
            }

            me.icn3d.molTitle += "<a href=\"https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdbsrv.cgi?uid=" + structure.pdbId.toUpperCase() + "\" target=\"_blank\" style=\"color: " + me.GREYD + ";\">" + structure.pdbId.toUpperCase() + "</a>";

            if (structure.descr !== undefined) me.pmid += structure.descr.pubmedid;
            if (i === 0) {
                me.icn3d.molTitle += " and ";
                if (structure.descr !== undefined) me.pmid += "_";
            }
        }

        me.icn3d.molTitle += ' from VAST+';

    }
    else { // mmdbid or mmcifid
        if (data.descr !== undefined) me.icn3d.molTitle += data.descr.name;

        if (type === 'mmdbid') {
            var pdbidTmp = data.pdbId;
            var chainHash = {};
            for (var molid in data.moleculeInfor) {
                var chain = data.moleculeInfor[molid].chain.trim();
                var chainid = pdbidTmp + '_' + chain;
                if (chainHash.hasOwnProperty(chain)) {
                    ++chainHash[chain];
                    chainid += chainHash[chain];
                }
                else {
                    chainHash[chain] = 1;
                }

                var kind = data.moleculeInfor[molid].kind;
                var color = data.moleculeInfor[molid].color;
                var sid = data.moleculeInfor[molid].sid;

                chainid2kind[chainid] = kind;
                chainid2color[chainid] = color;

                if (sid !== undefined) me.chainid2sid[chainid] = sid;
            }
        }
    }

    me.countNextresiArray = {};
    //me.chainMissingResidueArray = {};
    if (type === 'mmdbid' || type === 'mmcifid') {
        for (var chain in data.sequences) {
            var seqArray = data.sequences[chain];
            var chainid = id + '_' + chain;
            if (type === 'mmcifid') chainid = '1_' + chain;

            me.getMissingResidues(seqArray, type, chainid);
        }
    }
    else if (type === 'align') {
        for (var chainid in chainid2seq) {
            var seqArray = chainid2seq[chainid];

            me.getMissingResidues(seqArray, type, chainid);
        }
    }

    var atomid2serial = {};
    var prevStructureNum = '', prevChainNum = '', prevResidueNum = '';
    var structureNum = '', chainNum = '', residueNum = '';
    var currContinueSeq = '';
    var oldResi, prevOldResi = -999;
    var prevResi = 0; // continuous from 1 for each chain
    var missingResIndex = 0;
    var bChainSeqSet = true;

    // In align, chemicals do not have assigned chains. Assembly will have the same residue id so that two different residues will be combined in one residue. To avoid this, build an array to check for molid
    var resiArray = [];
    var molid, prevMolid = '', prevmmdbId = '';

    // set mmdbMolidResid2mmdbChainResi
    me.mmdbMolidResid2mmdbChainResi = {};

    var bPhosphorusOnly = me.icn3d.isCalphaPhosOnly(atoms, "O3'", "O3*");

    for (var i in atoms) {
        ++serial;

        atomid2serial[i] = serial;

        var atm = atoms[i];
        atm.serial = serial;

        var mmdbId;

        if (type === 'mmdbid' || type === 'mmcifid') {
            mmdbId = id; // here mmdbId is pdbid or mmcif id
        }
        else if (type === 'align') {
            mmdbId = serial2structure[serial]; // here mmdbId is pdbid
        }

        var resiCorrection = 0;
        if (type === 'mmdbid' || type === 'align') {
            atm.resi_ori = parseInt(atm.resi); // original PDB residue number, has to be integer
            atm.resi = atm.ids.r; // corrected for residue insertion code

            resiCorrection = atm.resi - atm.resi_ori;
        }
        else {
            atm.resi = parseInt(atm.resi);
        }

        if (mmdbId !== prevmmdbId) resiArray = [];
        if (atm.chain === undefined && (type === 'mmdbid' || type === 'align')) {
            if (type === 'mmdbid') {
                molid = atm.ids.m;

                if (me.icn3d.molid2chain[molid] !== undefined) {
                    var pos = me.icn3d.molid2chain[molid].indexOf('_');
                    atm.chain = me.icn3d.molid2chain[molid].substr(pos + 1);
                }
                else {
                    if (molid !== prevMolid) {
                        resiArray.push(atm.resi);
                    }

                    var miscName;
                    if ($.inArray(atm.resi, resiArray) === resiArray.length - 1) {
                        miscName = 'Misc';
                    }
                    else {
                        miscName = 'Misc2';
                    }

                    //all should be defined, no "Misc" should appear
                    atm.chain = miscName;
                }
            }
            else if (type === 'align') {
                molid = atm.ids.m;

                if (me.icn3d.pdbid_molid2chain[mmdbId + '_' + molid] !== undefined) {
                    atm.chain = me.icn3d.pdbid_molid2chain[mmdbId + '_' + molid];
                }
                else {
                    if (molid !== prevMolid) {
                        resiArray.push(atm.resi);
                    }

                    var miscName;
                    if ($.inArray(atm.resi, resiArray) === resiArray.length - 1) {
                        miscName = 'Misc';
                    }
                    else {
                        miscName = 'Misc2';
                    }

                    // chemicals do not have assigned chains.
                    atm.chain = miscName;
                }
            }
        }
        else {
            atm.chain = (atm.chain === '') ? 'Misc' : atm.chain;
        }

        atm.chain = atm.chain.trim();

        // mmcif has pre-assigned structure in mmcifparser.cgi output
        if (type === 'mmdbid' || type === 'align') {
            atm.structure = mmdbId;
        }

        structureNum = atm.structure;
        chainNum = structureNum + '_' + atm.chain;

        if (chainNum !== prevChainNum) {
            missingResIndex = 0;
            prevResi = 0;
        }

        if (type === 'mmdbid') {
            atm.coord = new THREE.Vector3(atm.coord[0], atm.coord[1], atm.coord[2]);
        }
        else {
            atm.coord = new THREE.Vector3(atm.coord.x, atm.coord.y, atm.coord.z);
        }

        var oneLetterRes = me.icn3d.residueName2Abbr(atm.resn.substr(0, 3));

        // modify resi since MMDB used the same resi as in PDB where resi is not continuous
        // No need to modify mmcif resi
        //if(type === 'mmdbid' || type === 'align') {
        if (type === 'mmdbid') {
            // bfactor
            if (type === 'mmdbid') atm.b = (atm.b !== undefined) ? atm.b : 1;

            oldResi = atm.resi;

            //          if(atm.resi !== prevOldResi && atm.resi !== prevOldResi + 1) {
            if (me.countNextresiArray[chainNum] !== undefined
                && me.countNextresiArray[chainNum][missingResIndex] !== undefined
                && atm.resi === me.countNextresiArray[chainNum][missingResIndex][1] + resiCorrection) {
                // add missed residues
                var count = me.countNextresiArray[chainNum][missingResIndex][0];
                prevResi += count;

                ++missingResIndex;
            }
            //          }

            if (molid !== prevMolid) {
                atm.resi = atm.resi; // don't change the assigned resi
            }
            else if (atm.resi !== prevOldResi) {
                atm.resi = prevResi + 1;
            }

            else {
                atm.resi = prevResi;
            }

            prevOldResi = oldResi;
        }

        if (type === 'mmdbid' || type === 'align') {
            // set me.mmdbMolidResid2mmdbChainResi
            me.mmdbMolidResid2mmdbChainResi[mmdbId + '_' + atm.ids.m + '_' + atm.ids.r] = mmdbId + '_' + atm.chain + '_' + atm.resi;
        }

        pmin.min(atm.coord);
        pmax.max(atm.coord);
        psum.add(atm.coord);

        var bProtein = (me.cfg.mmcifid === undefined) ? chainid2kind[chainNum] === 'protein' : atm.mt === 'p';
        var bNucleotide = (me.cfg.mmcifid === undefined) ? chainid2kind[chainNum] === 'nucleotide' : atm.mt === 'n';
        var bSolvent = (me.cfg.mmcifid === undefined) ? chainid2kind[chainNum] === 'solvent' : atm.mt === 's';
        // in vastplus.cgi, ions arenotlisted in alignedStructures...molecules, thus chainid2kind[chainNum] === undefined is used.
        // ions will be separated from chemicals later.
        // here "ligand" is used in the cgi output
        var bChemicalIons = (me.cfg.mmcifid === undefined) ? (chainid2kind[chainNum] === 'ligand' || chainid2kind[chainNum] === undefined) : atm.mt === 'l';

        if (bProtein || bNucleotide) {
            if (bProtein) {
                me.icn3d.proteins[serial] = 1;

                if (atm.name === 'CA') me.icn3d.calphas[serial] = 1;
                if (atm.name !== 'N' && atm.name !== 'CA' && atm.name !== 'C' && atm.name !== 'O') me.icn3d.sidec[serial] = 1;
            }
            else if (bNucleotide) {
                me.icn3d.nucleotides[serial] = 1;

                //if (atm.name == 'P') me.icn3d.nucleotidesO3[serial] = 1;
                if (atm.name == "O3'" || atm.name == "O3*" || (bPhosphorusOnly && atm.name == 'P')) {
                    me.icn3d.nucleotidesO3[serial] = 1;
                }
            }

            atm.het = false;
        }
        else if (bSolvent) { // solvent
            me.icn3d.water[serial] = 1;

            atm.het = true;
        }
        else if (bChemicalIons) { // chemicals and ions
            //if (atm.bonds.length === 0) me.icn3d.ions[serial] = 1;
            if (atm.elem === atm.resn) {
                me.icn3d.ions[serial] = 1;
            }
            else {
                me.icn3d.chemicals[serial] = 1;
            }

            atm.het = true;
        }

        if (type === 'mmdbid') {
            atm.color = (!atm.het) ? new THREE.Color(chainid2color[chainNum]) : me.icn3d.atomColors[atm.elem] || me.icn3d.defaultAtomColor;
        }
        else {
            if (atm.color !== undefined) atm.color = new THREE.Color(atm.color);
        }

        if (atm.resn.charAt(0) !== ' ' && atm.resn.charAt(1) === ' ') {
            atm.resn = atm.resn.charAt(0);
        }

        // double check
        if (atm.resn == 'HOH') me.icn3d.water[serial] = 1

        me.icn3d.atoms[serial] = atm;
        me.icn3d.dAtoms[serial] = 1;
        me.icn3d.hAtoms[serial] = 1;

        // chain level
        var chainid = atm.structure + '_' + atm.chain;
        if (me.icn3d.chains[chainid] === undefined) me.icn3d.chains[chainid] = {};
        me.icn3d.chains[chainid][serial] = 1;

        // residue level
        var residueid = atm.structure + '_' + atm.chain + '_' + atm.resi;
        if (me.icn3d.residues[residueid] === undefined) me.icn3d.residues[residueid] = {};
        me.icn3d.residues[residueid][serial] = 1;

        residueNum = chainNum + '_' + atm.resi;

        // different residue
        if (residueNum !== prevResidueNum) {
            // different chain
            if (chainNum !== prevChainNum) {
                bChainSeqSet = true;

                if (serial !== 1) {
                    if (me.icn3d.structures[prevStructureNum] === undefined) me.icn3d.structures[prevStructureNum] = [];
                    me.icn3d.structures[prevStructureNum].push(prevChainNum);
                }
            }
        }

        me.icn3d.residueId2Name[residueid] = oneLetterRes;

        var secondaries = '-';
        if (atm.ss === 'helix') {
            secondaries = 'H';
        }
        else if (atm.ss === 'sheet') {
            secondaries = 'E';
        }
        else if (atm.het || bNucleotide) {
            secondaries = 'o';
        }
        else if (!atm.het && me.icn3d.residueColors.hasOwnProperty(atm.resn.toUpperCase())) {
            secondaries = 'c';
        }
        else if (atm.ss === 'coil') {
            secondaries = 'c';
        }

        me.icn3d.secondaries[atm.structure + '_' + atm.chain + '_' + atm.resi] = secondaries;

        if (atm.resi != prevResi || molid != prevMolid) { // mmdbid 1tup has different molid, same resi
            if (me.icn3d.chainsSeq[chainid] === undefined) {
                me.icn3d.chainsSeq[chainid] = [];
                bChainSeqSet = false;
            }

            // me.icn3d.chainsSeq[chainid][atm.resi - 1] should have been defined for major chains
            if (bChainSeqSet && me.icn3d.chainsSeq[chainid][atm.resi - 1] !== undefined) {
                me.icn3d.chainsSeq[chainid][atm.resi - 1].name = oneLetterRes;
            }
            else if (!bChainSeqSet) {
                var resObject = {};
                resObject.resi = atm.resi;
                resObject.name = oneLetterRes;
                var numberStr = '';
                if (atm.resi % 10 === 0) numberStr = atm.resi.toString();

                me.icn3d.chainsSeq[chainid].push(resObject);
            }
        }

        prevResi = atm.resi;

        prevStructureNum = structureNum;
        prevChainNum = chainNum;
        prevResidueNum = residueNum;

        prevMolid = molid;
        prevmmdbId = mmdbId;
    }

    //        me.icn3d.adjustSeq(me.chainMissingResidueArray);

    // remove the reference
    data.atoms = {};

    // add the last residue set
    if (me.icn3d.structures[structureNum] === undefined) me.icn3d.structures[structureNum] = [];
    me.icn3d.structures[structureNum].push(chainNum);

    // update bonds info
    if (type !== 'mmcifid') {
        for (var i in me.icn3d.atoms) {
            var bondLength = (me.icn3d.atoms[i].bonds === undefined) ? 0 : me.icn3d.atoms[i].bonds.length;

            for (var j = 0; j < bondLength; ++j) {
                me.icn3d.atoms[i].bonds[j] = atomid2serial[me.icn3d.atoms[i].bonds[j]];
            }
        }
    }

    me.icn3d.cnt = serial;

    me.icn3d.pmin = pmin;
    me.icn3d.pmax = pmax;
    me.icn3d.maxD = pmax.distanceTo(pmin);
    me.icn3d.center = psum.multiplyScalar(1.0 / me.icn3d.cnt);

    if (me.icn3d.maxD < 5) me.icn3d.maxD = 5;
    me.icn3d.oriMaxD = me.icn3d.maxD;
    me.icn3d.oriCenter = me.icn3d.center.clone();

    // set up disulfide bonds
    if (type === 'mmdbid') {
        var disulfideArray = data.disulfides;

        if (disulfideArray !== undefined) {
            for (var i = 0, il = disulfideArray.length; i < il; ++i) {
                var serial1 = disulfideArray[i][0].ca;
                var serial2 = disulfideArray[i][1].ca;

                var atom1 = me.icn3d.atoms[serial1];
                var atom2 = me.icn3d.atoms[serial2];

                var resid1 = atom1.structure + '_' + atom1.chain + '_' + atom1.resi;
                var resid2 = atom2.structure + '_' + atom2.chain + '_' + atom2.resi;

                if (me.icn3d.ssbondpnts[atom1.structure] === undefined) me.icn3d.ssbondpnts[atom1.structure] = [];

                me.icn3d.ssbondpnts[atom1.structure].push(resid1);
                me.icn3d.ssbondpnts[atom1.structure].push(resid2);
            }
        }
    }
    else if (type === 'mmcifid') {
        var disulfideArray = data.disulfides;

        if (disulfideArray !== undefined) {
            if (me.icn3d.ssbondpnts[id] === undefined) me.icn3d.ssbondpnts[id] = [];

            for (var i = 0, il = disulfideArray.length; i < il; ++i) {
                var resid1 = disulfideArray[i][0];
                var resid2 = disulfideArray[i][1];

                me.icn3d.ssbondpnts[id].push(resid1);
                me.icn3d.ssbondpnts[id].push(resid2);
            }

            // copy disulfide bonds
            var structureArray = Object.keys(me.icn3d.structures);
            for (var s = 0, sl = structureArray.length; s < sl; ++s) {
                var structure = structureArray[s];

                if (structure == id) continue;

                if (me.icn3d.ssbondpnts[structure] === undefined) me.icn3d.ssbondpnts[structure] = [];

                for (var j = 0, jl = me.icn3d.ssbondpnts[id].length; j < jl; ++j) {
                    var ori_resid = me.icn3d.ssbondpnts[id][j];
                    var pos = ori_resid.indexOf('_');
                    var resid = structure + ori_resid.substr(pos);

                    me.icn3d.ssbondpnts[structure].push(resid);
                }
            }
        }
    }

    // set up sequence alignment
    // display the structure right away. load the mns and sequences later
    //        setTimeout(function(){
    if (type === 'align' && seqalign !== undefined) {
        me.setSeqAlign(seqalign, data.alignedStructures);
    } // if(align

    me.showTitle();

    data = {};
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// from the 2016 NCBI hackathon in Orlando: https://github.com/NCBI-Hackathons/iCN3D-MMTF
// Contributors: Jiyao Wang, Alexander Rose, Peter Rose
// requires the library mmtf.js
iCn3DUI.prototype.downloadMmtf = function (mmtfid) {
    var me = this;
    MMTF.fetch(
        mmtfid,
        // onLoad callback
        function (mmtfData) {

            me.icn3d.init();

            var pmin = new THREE.Vector3(9999, 9999, 9999);
            var pmax = new THREE.Vector3(-9999, -9999, -9999);
            var psum = new THREE.Vector3();

            var id = mmtfData.structureId;

            me.icn3d.molTitle = mmtfData.title;

            // bioAsembly
            if (mmtfData.bioAssemblyList !== undefined && mmtfData.bioAssemblyList[0] !== undefined && mmtfData.bioAssemblyList[0].transformList.length > 1) {
                me.icn3d.biomtMatrices = [];
                for (var i = 0, il = mmtfData.bioAssemblyList[0].transformList.length; i < il; ++i) {
                    //var biomt = new THREE.Matrix4().identity();

                    //for(var j = 0, jl = mmtfData.bioAssemblyList[0].transformList[i].matrix.length; j < jl; ++j) {
                    //biomt.elements[j] = mmtfData.bioAssemblyList[0].transformList[i].matrix[j];
                    //}

                    var biomt = new THREE.Matrix4().fromArray(mmtfData.bioAssemblyList[0].transformList[i].matrix).transpose();

                    me.icn3d.biomtMatrices.push(biomt);
                }
            }

            if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1) {
                $("#" + me.pre + "assemblyWrapper").show();

                me.icn3d.asuCnt = me.icn3d.biomtMatrices.length;
            }
            else {
                $("#" + me.pre + "assemblyWrapper").hide();
            }

            var oriindex2serial = {};

            // save SG atoms in CYS residues
            var SGAtomSerialArray = [];

            var prevSS = 'coil';
            var prevChain = '';
            var prevResi = 0;

            var serial = 0;

            var structure, chain, resn, resi, ss, ssbegin, ssend;
            var het, bProtein, bNucleotide;
            var elem, atomName, coord, b, alt;

            var bModifyResi = false;

            var callbackDict = {
                onModel: function (modelData) {
                    structure = (modelData.modelIndex === 0) ? id : id + (modelData.modelIndex + 1).toString();
                },
                onChain: function (chainData) {
                    bModifyResi = false;

                    chain = chainData.chainName; // or chainData.chainId
                    var chainid = structure + '_' + chain;

                    if (me.icn3d.structures[structure] === undefined) me.icn3d.structures[structure] = [];
                    me.icn3d.structures[structure].push(chainid);

                    /*
                                        if(me.icn3d.chainsAnTitle[chainid] === undefined ) me.icn3d.chainsAnTitle[chainid] = [];
                                        if(me.icn3d.chainsAnTitle[chainid][0] === undefined ) me.icn3d.chainsAnTitle[chainid][0] = [];
                                        if(me.icn3d.chainsAnTitle[chainid][1] === undefined ) me.icn3d.chainsAnTitle[chainid][1] = [];
                                        me.icn3d.chainsAnTitle[chainid][0].push('');
                                        me.icn3d.chainsAnTitle[chainid][1].push('SS');
                    */
                },
                onGroup: function (groupData) {
                    resn = groupData.groupName;
                    resi = groupData.groupId;

                    if (resi == prevResi || bModifyResi) {
                        bModifyResi = true;
                        resi = prevResi + 1; // for residue insertion code
                    }

                    var resid = structure + '_' + chain + '_' + resi;

                    if (groupData.secStruct === 0 || groupData.secStruct === 2 || groupData.secStruct === 4) {
                        ss = 'helix';
                    }
                    else if (groupData.secStruct === 3) {
                        ss = 'sheet';
                    }
                    else if (groupData.secStruct === -1) {
                        ss = 'other';
                    }
                    else {
                        ss = 'coil';
                    }

                    // no residue can be both ssbegin and ssend in DSSP calculated secondary structures
                    var bSetPrevSsend = false;

                    if (chain !== prevChain) {
                        // new chain
                        if (ss !== 'coil' && ss !== 'other') {
                            ssbegin = true;
                            ssend = false;
                        }
                        else {
                            ssbegin = false;
                            ssend = false;
                        }

                        // set up the end of previous chain
                        if (prevSS !== 'coil' && prevSS !== 'other') {
                            var prevResid = structure + '_' + prevChain + '_' + prevResi.toString();

                            for (var i in me.icn3d.residues[prevResid]) {
                                me.icn3d.atoms[i].ssbegin = false;
                                me.icn3d.atoms[i].ssend = true;
                            }
                        }
                    }
                    else if (ss !== prevSS) {
                        if (prevSS === 'coil' || prevSS === 'other') {
                            ssbegin = true;
                            ssend = false;
                        }
                        else if (ss === 'coil' || ss === 'other') {
                            bSetPrevSsend = true;
                            ssbegin = false;
                            ssend = false;
                        }
                        else if ((prevSS === 'sheet' && ss === 'helix') || (prevSS === 'helix' && ss === 'sheet')) {
                            bSetPrevSsend = true;
                            ssbegin = true;
                            ssend = false;
                        }
                    }
                    else {
                        ssbegin = false;
                        ssend = false;
                    }

                    if (bSetPrevSsend) {
                        var prevResid = structure + '_' + chain + '_' + (resi - 1).toString();
                        for (var i in me.icn3d.residues[prevResid]) {
                            me.icn3d.atoms[i].ssbegin = false;
                            me.icn3d.atoms[i].ssend = true;
                        }
                    }

                    prevSS = ss;
                    prevChain = chain;
                    prevResi = resi;

                    het = false;
                    bProtein = false;
                    bNucleotide = false;
                    if (groupData.chemCompType.toLowerCase() === 'non-polymer' || groupData.chemCompType.toLowerCase() === 'other' || groupData.chemCompType.toLowerCase().indexOf('saccharide') !== -1) {
                        het = true;
                    }
                    else if (groupData.chemCompType.toLowerCase().indexOf('peptide') !== -1) {
                        bProtein = true;
                    }
                    else if (groupData.chemCompType.toLowerCase().indexOf('dna') !== -1 || groupData.chemCompType.toLowerCase().indexOf('rna') !== -1) {
                        bNucleotide = true;
                    }
                    else {
                        bProtein = true;
                    }

                    // add sequence information
                    var chainid = structure + '_' + chain;

                    var resObject = {};
                    resObject.resi = resi;
                    resObject.name = me.icn3d.residueName2Abbr(resn);

                    me.icn3d.residueId2Name[resid] = resObject.name;

                    if (me.icn3d.chainsSeq[chainid] === undefined) me.icn3d.chainsSeq[chainid] = [];
                    /*
                                          if(me.icn3d.chainsAn[chainid] === undefined ) me.icn3d.chainsAn[chainid] = [];
                                          if(me.icn3d.chainsAn[chainid][0] === undefined ) me.icn3d.chainsAn[chainid][0] = [];
                                          if(me.icn3d.chainsAn[chainid][1] === undefined ) me.icn3d.chainsAn[chainid][1] = [];
                    */
                    var numberStr = '';
                    if (resObject.resi % 10 === 0) numberStr = resObject.resi.toString();

                    var secondaries = '-';
                    if (ss === 'helix') {
                        secondaries = 'H';
                    }
                    else if (ss === 'sheet') {
                        secondaries = 'E';
                    }
                    else if (ss === 'coil') {
                        secondaries = 'c';
                    }
                    else if (ss === 'other') {
                        secondaries = 'o';
                    }

                    if (me.icn3d.chainsSeq[chainid] === undefined) me.icn3d.chainsSeq[chainid] = [];
                    me.icn3d.chainsSeq[chainid].push(resObject);

                    /*
                                          if(me.icn3d.chainsAn[chainid] === undefined) me.icn3d.chainsAn[chainid] = [];
                                          if(me.icn3d.chainsAn[chainid][0] === undefined) me.icn3d.chainsAn[chainid][0] = [];
                                          if(me.icn3d.chainsAn[chainid][1] === undefined) me.icn3d.chainsAn[chainid][1] = [];
                                          me.icn3d.chainsAn[chainid][0].push(numberStr);
                                          me.icn3d.chainsAn[chainid][1].push(secondaries);
                    */
                    me.icn3d.secondaries[resid] = secondaries;

                },
                onAtom: function (atomData) {
                    elem = atomData.element;
                    atomName = atomData.atomName;
                    coord = new THREE.Vector3(atomData.xCoord, atomData.yCoord, atomData.zCoord);
                    b = atomData.bFactor;

                    alt = atomData.altLoc;
                    if (atomData.altLoc === '\u0000') { // a temp value, should be ''
                        alt = '';
                    }

                    // skip the atoms where alt is not '' or 'A'
                    if (alt === '' || alt === 'A') {
                        ++serial;

                        if (atomName === 'SG') SGAtomSerialArray.push(serial);

                        oriindex2serial[atomData.atomIndex] = serial;

                        var atomDetails = {
                            het: het, // optional, used to determine chemicals, water, ions, etc
                            serial: serial,         // required, unique atom id
                            name: atomName,             // required, atom name
                            alt: alt,               // optional, some alternative coordinates
                            resn: resn,             // optional, used to determine protein or nucleotide
                            structure: structure,   // optional, used to identify structure
                            chain: chain,           // optional, used to identify chain
                            resi: resi,             // optional, used to identify residue ID
                            //insc: line.substr(26, 1),
                            coord: coord,           // required, used to draw 3D shape
                            b: b,         // optional, used to draw B-factor tube
                            elem: elem,             // optional, used to determine hydrogen bond
                            bonds: [],              // required, used to connect atoms
                            bondOrder: [],
                            ss: ss,             // optional, used to show secondary structures
                            ssbegin: ssbegin,         // optional, used to show the beginning of secondary structures
                            ssend: ssend            // optional, used to show the end of secondary structures
                        };

                        me.icn3d.atoms[serial] = atomDetails;

                        pmin.min(coord);
                        pmax.max(coord);
                        psum.add(coord);

                        var chainid = structure + '_' + chain;
                        var resid = chainid + '_' + resi;

                        if (me.icn3d.chains[chainid] === undefined) me.icn3d.chains[chainid] = {};
                        me.icn3d.chains[chainid][serial] = 1;

                        if (me.icn3d.residues[resid] === undefined) me.icn3d.residues[resid] = {};
                        me.icn3d.residues[resid][serial] = 1;

                        if (bProtein) {
                            me.icn3d.proteins[serial] = 1;

                            if (atomName === 'CA') me.icn3d.calphas[serial] = 1;
                            if (atomName !== 'N' && atomName !== 'CA' && atomName !== 'C' && atomName !== 'O') me.icn3d.sidec[serial] = 1;
                        }
                        else if (bNucleotide) {
                            me.icn3d.nucleotides[serial] = 1;

                            //if (atomName == 'P') me.icn3d.nucleotidesO3[serial] = 1;
                            if (atomName == "O3'" || atomName == "O3*") me.icn3d.nucleotidesO3[serial] = 1;
                        }
                        else {
                            if (elem.toLowerCase() === resn.toLowerCase()) {
                                me.icn3d.ions[serial] = 1;
                            }
                            else if (resn === 'HOH' || resn === 'WAT' || resn === 'SQL' || resn === 'H2O' || resn === 'W' || resn === 'DOD' || resn === 'D3O') {
                                me.icn3d.water[serial] = 1;
                            }
                            else {
                                me.icn3d.chemicals[serial] = 1;
                            }
                        }

                        me.icn3d.dAtoms[serial] = 1;
                        me.icn3d.hAtoms[serial] = 1;
                    }
                },
                onBond: function (bondData) {
                    var from = oriindex2serial[bondData.atomIndex1];
                    var to = oriindex2serial[bondData.atomIndex2];

                    if (oriindex2serial.hasOwnProperty(bondData.atomIndex1) && oriindex2serial.hasOwnProperty(bondData.atomIndex2)) { // some alt atoms were skipped
                        me.icn3d.atoms[from].bonds.push(to);
                        me.icn3d.atoms[to].bonds.push(from);

                        if (het) {
                            var order = bondData.bondOrder;

                            me.icn3d.atoms[from].bondOrder.push(order);
                            me.icn3d.atoms[to].bondOrder.push(order);

                            if (order === 2) {
                                me.icn3d.doublebonds[from + '_' + to] = 1;
                                me.icn3d.doublebonds[to + '_' + from] = 1;
                            }
                            else if (order === 3) {
                                me.icn3d.triplebonds[from + '_' + to] = 1;
                                me.icn3d.triplebonds[to + '_' + from] = 1;
                            }
                        }
                    }
                }
            };

            // traverse
            MMTF.traverse(mmtfData, callbackDict);

            // set up disulfide bonds
            var sgLength = SGAtomSerialArray.length;
            for (var i = 0, il = sgLength; i < il; ++i) {
                for (var j = i + 1, jl = sgLength; j < il; ++j) {

                    var serial1 = SGAtomSerialArray[i];
                    var serial2 = SGAtomSerialArray[j];

                    var atom1 = me.icn3d.atoms[serial1];
                    var atom2 = me.icn3d.atoms[serial2];

                    if ($.inArray(serial2, atom1.bonds) !== -1) {
                        var resid1 = atom1.structure + '_' + atom1.chain + '_' + atom1.resi;
                        var resid2 = atom2.structure + '_' + atom2.chain + '_' + atom2.resi;

                        if (me.icn3d.ssbondpnts[atom1.structure] === undefined) me.icn3d.ssbondpnts[atom1.structure] = [];

                        me.icn3d.ssbondpnts[atom1.structure].push(resid1);
                        me.icn3d.ssbondpnts[atom1.structure].push(resid2);
                    }
                }
            }

            me.icn3d.cnt = serial;

            me.icn3d.pmin = pmin;
            me.icn3d.pmax = pmax;
            me.icn3d.maxD = pmax.distanceTo(pmin);
            me.icn3d.center = psum.multiplyScalar(1.0 / me.icn3d.cnt);

            if (me.icn3d.maxD < 5) me.icn3d.maxD = 5;
            me.icn3d.oriMaxD = me.icn3d.maxD;
            me.icn3d.oriCenter = me.icn3d.center.clone();

            if (me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
                $("#" + me.pre + "alternateWrapper").hide();
            }

            me.icn3d.setAtomStyleByOptions(me.opts);
            me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

            me.renderStructure();

            me.showTitle();

            if (me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

            //if(me.cfg.showseq !== undefined && me.cfg.showseq) me.openDialog(me.pre + 'dl_selectresidues', 'Select residues in sequences');

            if (me.deferred !== undefined) me.deferred.resolve(); if (me.deferred2 !== undefined) me.deferred2.resolve();

        },
        // onError callback
        function (error) {
            console.error(error)
        }
    );
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.downloadPdb = function (pdbid) {
    var me = this;
    var url, dataType;

    url = "https://files.rcsb.org/view/" + pdbid + ".pdb";

    dataType = "text";

    me.icn3d.bCid = undefined;

    $.ajax({
        url: url,
        dataType: dataType,
        cache: true,
        tryCount: 0,
        retryLimit: 1,
        beforeSend: function () {
            me.showLoading();
        },
        complete: function () {
            me.hideLoading();
        },
        success: function (data) {
            me.loadPdbData(data);
        },
        error: function (xhr, textStatus, errorThrown) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }
            return;
        }
    });
};

iCn3DUI.prototype.downloadUrl = function (url, type) {
    var me = this;
    var dataType = "text";

    me.icn3d.bCid = undefined;

    //var url = '//www.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi?dataurl=' + encodeURIComponent(url);

    $.ajax({
        url: url,
        dataType: dataType,
        cache: true,
        tryCount: 0,
        retryLimit: 1,
        beforeSend: function () {
            if ($("#" + me.pre + "wait")) $("#" + me.pre + "wait").show();
            if ($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").hide();
            if ($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").hide();
        },
        complete: function () {
            if ($("#" + me.pre + "wait")) $("#" + me.pre + "wait").hide();
            if ($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").show();
            if ($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").show();
        },
        success: function (data) {
            if (type === 'pdb') {
                me.loadPdbData(data);
            }
            else if (type === 'mol2') {
                me.loadMol2Data(data);
            }
            else if (type === 'sdf') {
                me.loadSdfData(data);
            }
            else if (type === 'xyz') {
                me.loadXyzData(data);
            }
        },
        error: function (xhr, textStatus, errorThrown) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }
            return;
        }
    });
};

iCn3DUI.prototype.loadPdbData = function (data) {
    var me = this;

    me.icn3d.loadPDB(data); // defined in the core library

    if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1) {
        $("#" + me.pre + "assemblyWrapper").show();

        me.icn3d.asuCnt = me.icn3d.biomtMatrices.length;
    }
    else {
        $("#" + me.pre + "assemblyWrapper").hide();
    }

    var bCalphaOnly = me.icn3d.isCalphaPhosOnly(me.icn3d.hash2Atoms(me.icn3d.proteins), 'CA');

    var calphaonly = (bCalphaOnly) ? '1' : '0';

    // calculate secondary structures if not available
    // DSSP only works for structures with all atoms. The Calpha only strucutres didn't work
    if (!me.icn3d.bSecondaryStructure && !bCalphaOnly) {
        var url = "//www.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi";

        $.ajax({
            url: url,
            type: 'POST',
            data: { 'dssp': 't', 'calphaonly': calphaonly, 'pdbfile': data },
            dataType: 'jsonp',
            cache: true,
            tryCount: 0,
            retryLimit: 1,
            success: function (ssdata) {
                var ssHash = ssdata;

                if (JSON.stringify(ssdata).indexOf('Oops there was a problem') === -1) {
                    for (var chainNum in me.icn3d.chainsSeq) {
                        var pos = chainNum.indexOf('_');
                        var chain = chainNum.substr(pos + 1);

                        var residueObjectArray = me.icn3d.chainsSeq[chainNum];
                        var prevSS = 'coil';

                        for (var i = 0, il = residueObjectArray.length; i < il; ++i) {
                            var resi = residueObjectArray[i].resi;
                            var chain_resi = chain + '_' + resi;

                            var ssOneLetter = '-';
                            if (ssHash.hasOwnProperty(chain_resi)) {
                                ssOneLetter = ssHash[chain_resi];
                            }

                            var ss;
                            if (ssOneLetter === 'H') {
                                ss = 'helix';
                            }
                            else if (ssOneLetter === 'E') {
                                ss = 'sheet';
                            }
                            else {
                                ss = 'coil';
                            }

                            // update ss in sequence window
                            me.icn3d.chainsAn[chainNum][1][i] = ssOneLetter;

                            // assign atom ss, ssbegin, and ssend
                            var resid = chainNum + '_' + resi;

                            // no residue can be both ssbegin and ssend in DSSP calculated secondary structures
                            var bSetPrevResidue = 0; // 0: no need to reset, 1: reset previous residue to "ssbegin = true", 2: reset previous residue to "ssend = true"

                            if (ss !== prevSS) {
                                if (prevSS === 'coil') {
                                    ssbegin = true;
                                    ssend = false;
                                }
                                else if (ss === 'coil') {
                                    bSetPrevResidue = 2;
                                    ssbegin = false;
                                    ssend = false;
                                }
                                else if ((prevSS === 'sheet' && ss === 'helix') || (prevSS === 'helix' && ss === 'sheet')) {
                                    bSetPrevResidue = 1;
                                    ssbegin = true;
                                    ssend = false;
                                }
                            }
                            else {
                                ssbegin = false;
                                ssend = false;
                            }

                            if (bSetPrevResidue == 1) { //1: reset previous residue to "ssbegin = true"
                                var prevResid = chainNum + '_' + (resi - 1).toString();
                                for (var j in me.icn3d.residues[prevResid]) {
                                    me.icn3d.atoms[j].ssbegin = true;
                                    me.icn3d.atoms[j].ssend = false;
                                }
                            }
                            else if (bSetPrevResidue == 2) { //2: reset previous residue to "ssend = true"
                                var prevResid = chainNum + '_' + (resi - 1).toString();
                                for (var j in me.icn3d.residues[prevResid]) {
                                    me.icn3d.atoms[j].ssbegin = false;
                                    me.icn3d.atoms[j].ssend = true;
                                }
                            }

                            // set the current residue
                            for (var j in me.icn3d.residues[resid]) {
                                me.icn3d.atoms[j].ss = ss;
                                me.icn3d.atoms[j].ssbegin = ssbegin;
                                me.icn3d.atoms[j].ssend = ssend;
                            }

                            prevSS = ss;
                        } // for each residue
                    } // for each chain
                } // if no error

                me.loadPdbDataRender();
            },
            error: function (xhr, textStatus, errorThrown) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }

                me.loadPdbDataRender();
                return;
            }
        });
    }
    else {
        me.loadPdbDataRender();
    }
};

iCn3DUI.prototype.loadPdbDataRender = function () {
    var me = this;

    me.pmid = me.icn3d.pmid;

    if (me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        $("#" + me.pre + "alternateWrapper").hide();
    }

    me.icn3d.setAtomStyleByOptions(me.opts);
    me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

    me.renderStructure();

    me.showTitle();

    if (me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

    if (me.deferred !== undefined) me.deferred.resolve(); if (me.deferred2 !== undefined) me.deferred2.resolve();
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.downloadCid = function (cid) {
    var me = this;
    var uri = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + cid + "/record/SDF/?record_type=3d&response_type=display";

    me.opts['pk'] = 'atom';
    me.opts['chemicals'] = 'ball and stick';

    me.icn3d.opts['pk'] = 'atom';
    me.icn3d.opts['chemicals'] = 'ball and stick';

    me.icn3d.bCid = true;

    $.ajax({
        url: uri,
        dataType: 'text',
        cache: true,
        tryCount: 0,
        retryLimit: 1,
        beforeSend: function () {
            me.showLoading();
        },
        complete: function () {
            me.hideLoading();
        },
        success: function (data) {
            var bResult = me.loadSdfAtomData(data, cid);

            if (me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
                $("#" + me.pre + "alternateWrapper").hide();
            }

            if (!bResult) {
                alert('The SDF of CID ' + cid + ' has the wrong format...');
            }
            else {

                me.icn3d.setAtomStyleByOptions(me.opts);
                me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

                me.renderStructure();

                if (me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

                if (me.deferred !== undefined) me.deferred.resolve(); if (me.deferred2 !== undefined) me.deferred2.resolve();
            }
        },
        error: function (xhr, textStatus, errorThrown) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }
            return;
        }
    })
        .fail(function () {
            alert("This CID may not have 3D structure...");
        });
};

iCn3DUI.prototype.loadSdfData = function (data) {
    var me = this;

    var bResult = me.loadSdfAtomData(data);

    if (me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        $("#" + me.pre + "alternateWrapper").hide();
    }

    if (!bResult) {
        alert('The SDF file has the wrong format...');
    }
    else {
        me.icn3d.setAtomStyleByOptions(me.opts);
        me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

        me.renderStructure();

        if (me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

        if (me.deferred !== undefined) me.deferred.resolve(); if (me.deferred2 !== undefined) me.deferred2.resolve();
    }
};

iCn3DUI.prototype.loadSdfAtomData = function (data, cid) {
    var me = this;
    var lines = data.split(/\r?\n|\r/);
    if (lines.length < 4) return false;

    me.icn3d.init();

    var structure = cid ? cid : 1;
    var chain = 'A';
    var resi = 1;
    var resn = 'LIG';

    var moleculeNum = structure;
    var chainNum = structure + '_' + chain;
    var residueNum = chainNum + '_' + resi;

    var atomCount = parseInt(lines[3].substr(0, 3));
    if (isNaN(atomCount) || atomCount <= 0) return false;

    var bondCount = parseInt(lines[3].substr(3, 3));
    var offset = 4;
    if (lines.length < offset + atomCount + bondCount) return false;

    var start = 0;
    var end = atomCount;
    var i, line;

    var atomid2serial = {};
    var skipAtomids = {}; // skip hydrgen atom

    var AtomHash = {};
    var serial = 1;
    for (i = start; i < end; i++) {
        line = lines[offset];
        offset++;

        var name = line.substr(31, 3).replace(/ /g, "");

        if (name !== 'H') {
            var x = parseFloat(line.substr(0, 10));
            var y = parseFloat(line.substr(10, 10));
            var z = parseFloat(line.substr(20, 10));
            var coord = new THREE.Vector3(x, y, z);

            var atomDetails = {
                het: true,              // optional, used to determine chemicals, water, ions, etc
                serial: serial,         // required, unique atom id
                name: name,             // required, atom name
                resn: resn,             // optional, used to determine protein or nucleotide
                structure: structure,   // optional, used to identify structure
                chain: chain,           // optional, used to identify chain
                resi: resi,             // optional, used to identify residue ID
                coord: coord,           // required, used to draw 3D shape
                b: 0,                   // optional, used to draw B-factor tube
                elem: name,             // optional, used to determine hydrogen bond
                bonds: [],              // required, used to connect atoms
                ss: 'coil',             // optional, used to show secondary structures
                ssbegin: false,         // optional, used to show the beginning of secondary structures
                ssend: false,           // optional, used to show the end of secondary structures

                bondOrder: []           // optional, specific for chemicals
            };

            me.icn3d.atoms[serial] = atomDetails;
            AtomHash[serial] = 1;

            atomid2serial[i] = serial;

            ++serial;
        }
        else {
            skipAtomids[i] = 1;
        }
    }

    me.icn3d.dAtoms = AtomHash;
    me.icn3d.hAtoms = AtomHash;
    me.icn3d.structures[moleculeNum] = [chainNum]; //AtomHash;
    me.icn3d.chains[chainNum] = AtomHash;
    me.icn3d.residues[residueNum] = AtomHash;

    me.icn3d.residueId2Name[residueNum] = resn;

    if (me.icn3d.chainsSeq[chainNum] === undefined) me.icn3d.chainsSeq[chainNum] = [];
    /*
        if(me.icn3d.chainsAn[chainNum] === undefined ) me.icn3d.chainsAn[chainNum] = [];
        if(me.icn3d.chainsAn[chainNum][0] === undefined ) me.icn3d.chainsAn[chainNum][0] = [];
        if(me.icn3d.chainsAnTitle[chainNum] === undefined ) me.icn3d.chainsAnTitle[chainNum] = [];
        if(me.icn3d.chainsAnTitle[chainNum][0] === undefined ) me.icn3d.chainsAnTitle[chainNum][0] = [];
    */
    var resObject = {};
    resObject.resi = resi;
    resObject.name = resn;

    me.icn3d.chainsSeq[chainNum].push(resObject);
    //        me.icn3d.chainsAn[chainNum][0].push(resi);
    //        me.icn3d.chainsAnTitle[chainNum][0].push('');

    for (i = 0; i < bondCount; i++) {
        line = lines[offset];
        offset++;
        var fromAtomid = parseInt(line.substr(0, 3)) - 1 + start;
        var toAtomid = parseInt(line.substr(3, 3)) - 1 + start;
        //var order = parseInt(line.substr(6, 3));
        var order = line.substr(6, 3).trim();

        if (!skipAtomids.hasOwnProperty(fromAtomid) && !skipAtomids.hasOwnProperty(toAtomid)) {
            var from = atomid2serial[fromAtomid];
            var to = atomid2serial[toAtomid];

            me.icn3d.atoms[from].bonds.push(to);
            me.icn3d.atoms[from].bondOrder.push(order);
            me.icn3d.atoms[to].bonds.push(from);
            me.icn3d.atoms[to].bondOrder.push(order);
            if (order == '2') {
                me.icn3d.doublebonds[from + '_' + to] = 1;
                me.icn3d.doublebonds[to + '_' + from] = 1;
            }
            else if (order == '3') {
                me.icn3d.triplebonds[from + '_' + to] = 1;
                me.icn3d.triplebonds[to + '_' + from] = 1;
            }
        }
    }

    me.setMaxD();

    me.showTitle();

    return true;
};

iCn3DUI.prototype.setMaxD = function () {
    var me = this;
    var pmin = new THREE.Vector3(9999, 9999, 9999);
    var pmax = new THREE.Vector3(-9999, -9999, -9999);
    var psum = new THREE.Vector3();
    var cnt = 0;
    // assign atoms
    for (var i in me.icn3d.atoms) {
        var atom = me.icn3d.atoms[i];
        var coord = atom.coord;
        psum.add(coord);
        pmin.min(coord);
        pmax.max(coord);
        ++cnt;

        if (atom.het) {
            if ($.inArray(atom.elem, me.icn3d.ionsArray) !== -1) {
                me.icn3d.ions[atom.serial] = 1;
            }
            else {
                me.icn3d.chemicals[atom.serial] = 1;
            }
        }
    } // end of for


    me.icn3d.pmin = pmin;
    me.icn3d.pmax = pmax;

    me.icn3d.cnt = cnt;

    me.icn3d.maxD = me.icn3d.pmax.distanceTo(me.icn3d.pmin);
    me.icn3d.center = psum.multiplyScalar(1.0 / me.icn3d.cnt);

    if (me.icn3d.maxD < 5) me.icn3d.maxD = 5;
    me.icn3d.oriMaxD = me.icn3d.maxD;
    me.icn3d.oriCenter = me.icn3d.center.clone();
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// generate a binary STL file for 3D printing
// https://en.wikipedia.org/wiki/STL_(file_format)#Binary_STL
/*
UINT8[80] � Header
UINT32 � Number of triangles

foreach triangle
REAL32[3] � Normal vector
REAL32[3] � Vertex 1
REAL32[3] � Vertex 2
REAL32[3] � Vertex 3
UINT16 � Attribute byte count
end
*/
iCn3DUI.prototype.saveStlFile = function (mat) {
    var me = this;
    if (Object.keys(me.icn3d.dAtoms).length > 70000) {
        alert('Please display a subset of the structure to export 3D files. Then merge the files for 3D printing...');
        return [''];
    }

    me.prepareFor3Dprint();

    var cntFaces = 0;
    for (var i = 0, il = me.icn3d.mdl.children.length; i < il; ++i) {
        var mesh = me.icn3d.mdl.children[i];
        if (mesh.type === 'Sprite') continue;

        var geometry = mesh.geometry;

        var faces = geometry.faces;
        if (faces !== undefined) {
            for (var j = 0, jl = faces.length; j < jl; ++j) {
                ++cntFaces;
            }
        }
    }

    for (var i = 0, il = me.icn3d.mdl_ghost.children.length; i < il; ++i) {
        var mesh = me.icn3d.mdl_ghost.children[i];
        if (mesh.type === 'Sprite') continue;

        var geometry = mesh.geometry;

        var faces = geometry.faces;
        if (faces !== undefined) {
            for (var j = 0, jl = faces.length; j < jl; ++j) {
                ++cntFaces;
            }
        }
    }

    var blobArray = []; // hold blobs

    var stlArray = new Uint8Array(84);

    // UINT8[80] � Header
    var title = 'STL file for the structure(s) ';
    var structureArray = Object.keys(me.icn3d.structures);
    for (var i = 0, il = structureArray.length; i < il; ++i) {
        title += structureArray[i];
        if (i < il - 1) title += ', ';
    }

    if (title.length > 80) title = title.substr(0, 80);

    for (var i = 0; i < 80; ++i) {
        if (i < title.length) {
            stlArray[i] = me.passInt8([title.charCodeAt(i)])[0];
        }
        else {
            stlArray[i] = me.passInt8([' '.charCodeAt(0)])[0];
        }
    }

    // UINT32 � Number of triangles
    if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
        && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length <= me.icn3d.maxAtoms3DMultiFile) {
        stlArray = me.updateArray(stlArray, me.passInt32([cntFaces * me.icn3d.biomtMatrices.length]), 80);
    }
    else {
        stlArray = me.updateArray(stlArray, me.passInt32([cntFaces]), 80);
    }

    blobArray.push(new Blob([stlArray], { type: "application/octet-stream" }));

    blobArray = me.processStlMeshGroup(me.icn3d.mdl, blobArray, mat);

    blobArray = me.processStlMeshGroup(me.icn3d.mdl_ghost, blobArray, mat);

    // assemblies
    if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
        && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length <= me.icn3d.maxAtoms3DMultiFile) {
        var identity = new THREE.Matrix4();
        identity.identity();

        for (var i = 0; i < me.icn3d.biomtMatrices.length; i++) {  // skip itself
            var mat1 = me.icn3d.biomtMatrices[i];
            if (mat1 === undefined) continue;

            // skip itself
            if (mat1.equals(identity)) continue;

            blobArray = me.processStlMeshGroup(me.icn3d.mdl, blobArray, mat1);

            blobArray = me.processStlMeshGroup(me.icn3d.mdl_ghost, blobArray, mat1);
        }
    }

    //me.resetAfter3Dprint();

    return blobArray;
};

iCn3DUI.prototype.updateArray = function (array, inArray, indexBase) {
    var me = this;
    for (var i = 0, il = inArray.length; i < il; ++i) {
        array[indexBase + i] = inArray[i];
    };
    return array;
};

iCn3DUI.prototype.passFloat32 = function (array, output) {
    var me = this;
    var n = array.length;
    if (!output) output = new Uint8Array(4 * n);
    var dv = me.getDataView(output);
    for (var i = 0; i < n; ++i) {
        dv.setFloat32(4 * i, array[i], true); // litteEndian = true
    };
    return me.getUint8View(output);
};

iCn3DUI.prototype.passInt8 = function (array, output) {
    var me = this;
    var n = array.length;
    if (!output) output = new Uint8Array(1 * n);
    var dv = me.getDataView(output);
    for (var i = 0; i < n; ++i) {
        dv.setInt8(1 * i, array[i], true); // litteEndian = true
    };
    return me.getUint8View(output);
};

iCn3DUI.prototype.passInt16 = function (array, output) {
    var me = this;
    var n = array.length;
    if (!output) output = new Uint8Array(2 * n);
    var dv = me.getDataView(output);
    for (var i = 0; i < n; ++i) {
        dv.setInt16(2 * i, array[i], true); // litteEndian = true
    };
    return me.getUint8View(output);
};

iCn3DUI.prototype.passInt32 = function (array, output) {
    var me = this;
    var n = array.length;
    if (!output) output = new Uint8Array(4 * n);
    var dv = me.getDataView(output);
    for (var i = 0; i < n; ++i) {
        dv.setInt32(4 * i, array[i], true); // litteEndian = true
    };
    return me.getUint8View(output);
};

// ------------

iCn3DUI.prototype.getUint8View = function (typedArray) {
    var me = this;
    return me.getView(Uint8Array, typedArray);
};

iCn3DUI.prototype.getDataView = function (typedArray) {
    var me = this;
    return me.getView(DataView, typedArray);
};

iCn3DUI.prototype.getView = function (ctor, typedArray, elemSize) {
    var me = this;
    return typedArray ? new ctor(
        typedArray.buffer,
        typedArray.byteOffset,
        typedArray.byteLength / (elemSize || 1)
    ) : undefined;
};

iCn3DUI.prototype.processStlMeshGroup = function (mdl, blobArray, mat) {
    var me = this;
    for (var i = 0, il = mdl.children.length; i < il; ++i) {
        var mesh = mdl.children[i];
        if (mesh.type === 'Sprite') continue;

        var geometry = mesh.geometry;

        var vertices = geometry.vertices;
        var faces = geometry.faces;

        if (faces === undefined) continue;

        var position = mesh.position;
        var scale = mesh.scale;

        var matrix = mesh.matrix;

        var stlArray = new Uint8Array(faces.length * 50);

        var index = 0;

        for (var j = 0, jl = faces.length; j < jl; ++j) {
            var a = faces[j].a;
            var b = faces[j].b;
            var c = faces[j].c;
            var normal = faces[j].normal;

            var v1, v2, v3;

            if (geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry') {
                v1 = vertices[a].clone().multiply(scale).add(position);
                v2 = vertices[b].clone().multiply(scale).add(position);
                v3 = vertices[c].clone().multiply(scale).add(position);
            }
            else if (geometry.type == 'CylinderGeometry') {
                v1 = vertices[a].clone().applyMatrix4(matrix);
                v2 = vertices[b].clone().applyMatrix4(matrix);
                v3 = vertices[c].clone().applyMatrix4(matrix);
            }
            else {
                v1 = vertices[a].clone();
                v2 = vertices[b].clone();
                v3 = vertices[c].clone();
            }

            //REAL32[3] � Normal vector
            //REAL32[3] � Vertex 1
            //REAL32[3] � Vertex 2
            //REAL32[3] � Vertex 3
            //UINT16 � Attribute byte count

            if (normal !== undefined) {
                if (mat !== undefined) normal.applyMatrix4(mat);

                stlArray = me.updateArray(stlArray, me.passFloat32([normal.x, normal.y, normal.z]), index);
                index += 12;
            }
            else {
                stlArray = me.updateArray(stlArray, me.passFloat32([0.0, 0.0, 0.0]), index);
                index += 12;
            }

            if (mat !== undefined) {
                v1.applyMatrix4(mat);
                v2.applyMatrix4(mat);
                v3.applyMatrix4(mat);
            }

            stlArray = me.updateArray(stlArray, me.passFloat32([v1.x, v1.y, v1.z]), index);
            index += 12;
            stlArray = me.updateArray(stlArray, me.passFloat32([v2.x, v2.y, v2.z]), index);
            index += 12;
            stlArray = me.updateArray(stlArray, me.passFloat32([v3.x, v3.y, v3.z]), index);
            index += 12;

            v1 = v2 = v3 = undefined;

            stlArray = me.updateArray(stlArray, me.passInt16([0]), index);
            index += 2;
        }

        blobArray.push(new Blob([stlArray], { type: "application/octet-stream" }));
        stlArray = null;
    }

    return blobArray;
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

//http://gun.teipir.gr/VRML-amgem/spec/part1/examples.html
iCn3DUI.prototype.saveVrmlFile = function (mat) {
    var me = this;
    if (Object.keys(me.icn3d.dAtoms).length > 50000) {
        alert('Please display a subset of the structure to export 3D files. Then merge the files for 3D printing...');
        return [''];
    }

    me.prepareFor3Dprint();

    var vrmlStrArray = [];
    vrmlStrArray.push('#VRML V2.0 utf8\n');

    //    vrmlStrArray += 'Transform {\n';
    //    vrmlStrArray += '        translation ' + (-1 * me.icn3d.center.x.toPrecision(4)).toString() + ' ' + (-1 * me.icn3d.center.y.toPrecision(4)).toString() + ' ' + (-1 * me.icn3d.center.z.toPrecision(4)).toString() + '\n';
    //    vrmlStrArray += '        children [\n';

    var vertexCnt = 0;
    var result = me.processVrmlMeshGroup(me.icn3d.mdl, vrmlStrArray, vertexCnt, mat);
    vrmlStrArray = result.vrmlStrArray;
    vertexCnt = result.vertexCnt;

    result = me.processVrmlMeshGroup(me.icn3d.mdl_ghost, vrmlStrArray, vertexCnt, mat);
    vrmlStrArray = result.vrmlStrArray;
    vertexCnt = result.vertexCnt;

    // assemblies
    if (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
        && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length <= me.icn3d.maxAtoms3DMultiFile) {
        var identity = new THREE.Matrix4();
        identity.identity();

        for (var i = 0; i < me.icn3d.biomtMatrices.length; i++) {  // skip itself
            var mat1 = me.icn3d.biomtMatrices[i];
            if (mat1 === undefined) continue;

            // skip itself
            if (mat1.equals(identity)) continue;

            result = me.processVrmlMeshGroup(me.icn3d.mdl, vrmlStrArray, vertexCnt, mat1);
            vrmlStrArray = result.vrmlStrArray;
            vertexCnt = result.vertexCnt;

            result = me.processVrmlMeshGroup(me.icn3d.mdl_ghost, vrmlStrArray, vertexCnt, mat1);
            vrmlStrArray = result.vrmlStrArray;
            vertexCnt = result.vertexCnt;
        }
    }

    // remove the last ',\n';
    //    var vrmlStrArray = vrmlStrArray.substr(0, vrmlStrArray.lastIndexOf(',')) + '\n';

    //    vrmlStrArray += '        ]\n';
    //    vrmlStrArray += '}\n';

    //me.resetAfter3Dprint();

    //return vrmlStrArray.join('');
    return vrmlStrArray;
};

// The file lost face color after being repaired by https://service.netfabb.com/. It only works with vertex color
// convert face color to vertex color
iCn3DUI.prototype.processVrmlMeshGroup = function (mdl, vrmlStrArray, vertexCnt, mat) {
    var me = this;
    for (var i = 0, il = mdl.children.length; i < il; ++i) {
        var mesh = mdl.children[i];
        if (mesh.type === 'Sprite') continue;

        var geometry = mesh.geometry;

        var materialType = mesh.material.type;
        var bSurfaceVertex = (geometry.type == 'Surface') ? true : false;

        var vertices = geometry.vertices;

        if (vertices === undefined) continue;
        vertexCnt += vertices.length;

        var faces = geometry.faces;

        var position = mesh.position;
        var scale = mesh.scale;

        var matrix = mesh.matrix;

        var meshColor = new THREE.Color(1, 1, 1);
        if (geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
            if (mesh.material !== undefined) meshColor = mesh.material.color;
        }

        vrmlStrArray.push('Shape {\n');
        vrmlStrArray.push('geometry IndexedFaceSet {\n');

        vrmlStrArray.push('coord Coordinate { point [ ');

        var vertexColorStrArray = [];
        for (var j = 0, jl = vertices.length; j < jl; ++j) {
            var vertex;
            if (geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry') {
                vertex = vertices[j].clone().multiply(scale).add(position);
            }
            else if (geometry.type == 'CylinderGeometry') {
                vertex = vertices[j].clone().applyMatrix4(matrix);
            }
            else {
                vertex = vertices[j].clone()
            }

            if (mat !== undefined) vertex.applyMatrix4(mat);

            vrmlStrArray.push(vertex.x.toPrecision(5) + ' ' + vertex.y.toPrecision(5) + ' ' + vertex.z.toPrecision(5));
            vertex = undefined;

            if (j < jl - 1) vrmlStrArray.push(', ');

            vertexColorStrArray.push(new THREE.Color(1, 1, 1));
        }
        vrmlStrArray.push(' ] }\n');

        var coordIndexStr = '', colorStr = '', colorIndexStr = '';
        if (bSurfaceVertex) {
            for (var j = 0, jl = faces.length; j < jl; ++j) {
                var a = faces[j].a;
                var b = faces[j].b;
                var c = faces[j].c;

                coordIndexStr += a + ' ' + b + ' ' + c;
                // http://www.lighthouse3d.com/vrml/tutorial/index.shtml?indfs
                // use -1 to separate polygons
                if (j < jl - 1) coordIndexStr += ', -1, ';

                // update vertexColorStrArray
                vertexColorStrArray[a] = faces[j].vertexColors[0];
                vertexColorStrArray[b] = faces[j].vertexColors[1];
                vertexColorStrArray[c] = faces[j].vertexColors[2];
            }

            for (var j = 0, jl = vertexColorStrArray.length; j < jl; ++j) {
                var color = vertexColorStrArray[j];
                colorStr += color.r.toPrecision(3) + ' ' + color.g.toPrecision(3) + ' ' + color.b.toPrecision(3);
                if (j < jl - 1) colorStr += ', ';
            }

            vrmlStrArray.push('coordIndex [ ' + coordIndexStr + ' ]\n');
            vrmlStrArray.push('color Color { color [ ' + colorStr + ' ] } colorPerVertex TRUE\n');
        }
        else {
            for (var j = 0, jl = faces.length; j < jl; ++j) {
                var a = faces[j].a;
                var b = faces[j].b;
                var c = faces[j].c;
                var color;
                if (geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
                    color = meshColor;
                }
                else {
                    color = faces[j].color;
                }

                coordIndexStr += a + ' ' + b + ' ' + c;
                // http://www.lighthouse3d.com/vrml/tutorial/index.shtml?indfs
                // use -1 to separate polygons
                if (j < jl - 1) coordIndexStr += ', -1, ';

                // update vertexColorStrArray
                vertexColorStrArray[a] = color;
                vertexColorStrArray[b] = color;
                vertexColorStrArray[c] = color;
            }

            for (var j = 0, jl = vertexColorStrArray.length; j < jl; ++j) {
                var color = vertexColorStrArray[j];
                colorStr += color.r.toPrecision(3) + ' ' + color.g.toPrecision(3) + ' ' + color.b.toPrecision(3);
                if (j < jl - 1) colorStr += ', ';
            }

            vrmlStrArray.push('coordIndex [ ' + coordIndexStr + ' ]\n');
            vrmlStrArray.push('color Color { color [ ' + colorStr + ' ] } colorPerVertex TRUE\n');
        }

        vrmlStrArray.push('  }\n');
        vrmlStrArray.push('}\n');
    }

    return { 'vrmlStrArray': vrmlStrArray, 'vertexCnt': vertexCnt };
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.setThichknessFor3Dprint = function () {
    var me = this;
    me.icn3d.lineRadius = 1; //0.1; // hbonds, distance lines
    me.icn3d.coilWidth = 1.2; //0.3; // style cartoon-coil
    me.icn3d.cylinderRadius = 0.8; //0.4; // style stick
    me.icn3d.traceRadius = 1; //0.4; // style c alpha trace, nucleotide stick
    me.icn3d.dotSphereScale = 0.6; //0.3; // style ball and stick, dot

    me.icn3d.sphereRadius = 1.5; // style sphere
    //me.icn3d.cylinderHelixRadius = 1.6; // style sylinder and plate

    me.icn3d.ribbonthickness = 1.0; //0.2; // style ribbon, nucleotide cartoon, stand thickness
    me.icn3d.helixSheetWidth = 2.0; //1.3; // style ribbon, stand thickness
    me.icn3d.nucleicAcidWidth = 1.4; //0.8; // nucleotide cartoon
};

iCn3DUI.prototype.prepareFor3Dprint = function () {
    var me = this;
    // turn off hilight
    me.icn3d.bShowHighlight = false;
    me.icn3d.removeHlObjects();

    me.bDashedLines = false;

    if (!me.bSetThickness && me.cfg.cid === undefined) {
        me.setThichknessFor3Dprint();
    }

    // change hbond and distance lines from dashed to solid for 3d printing
    if (me.icn3d.lines['hbond'] !== undefined) {
        for (var i = 0, il = me.icn3d.lines['hbond'].length; i < il; ++i) {
            var line = me.icn3d.lines['hbond'][i];
            line.dashed = false;

            me.bDashedLines = true;
        }
    }

    /*
        // hbonds within selection
        if(me.icn3d.lines['stabilizer'] !== undefined) {
            for(var i = 0, il = me.icn3d.lines['stabilizer'].length; i < il; ++i) {
                var line = me.icn3d.lines['stabilizer'][i];
                line.dashed = false;
    
                me.bDashedLines = true;
            }
        }
    */

    if (me.icn3d.lines['distance'] !== undefined) {
        for (var i = 0, il = me.icn3d.lines['distance'].length; i < il; ++i) {
            var line = me.icn3d.lines['distance'][i];
            line.dashed = false;

            me.bDashedLines = true;
        }
    }

    me.icn3d.draw();
};

iCn3DUI.prototype.resetAfter3Dprint = function () {
    var me = this;
    // change hbond and distance lines from dashed to solid for 3d printing
    //if(me.bDashedLines) {
    if (me.icn3d.lines['hbond'] !== undefined) {
        for (var i = 0, il = me.icn3d.lines['hbond'].length; i < il; ++i) {
            var line = me.icn3d.lines['hbond'][i];
            line.dashed = true;
        }
    }

    if (me.icn3d.lines['distance'] !== undefined) {
        for (var i = 0, il = me.icn3d.lines['distance'].length; i < il; ++i) {
            var line = me.icn3d.lines['distance'][i];
            line.dashed = true;
        }
    }

    me.icn3d.lineRadius = 0.1; // hbonds, distance lines
    me.icn3d.coilWidth = 0.3; // style cartoon-coil
    me.icn3d.cylinderRadius = 0.4; // style stick
    me.icn3d.traceRadius = 0.4; //0.2; // style c alpha trace, nucleotide stick
    me.icn3d.dotSphereScale = 0.3; // style ball and stick, dot
    me.icn3d.sphereRadius = 1.5; // style sphere
    me.icn3d.cylinderHelixRadius = 1.6; // style sylinder and plate

    me.icn3d.ribbonthickness = 0.2; // style ribbon, nucleotide cartoon, stand thickness
    me.icn3d.helixSheetWidth = 1.3; // style ribbon, nucleotide cartoon, stand thickness
    me.icn3d.nucleicAcidWidth = 0.8; // nucleotide cartoon

    //me.icn3d.draw();
    //}
};

iCn3DUI.prototype.removeOneStabilizer = function (rmLineArray) {
    var me = this;
    var index;
    for (var i = 0, il = me.icn3d.pairArray.length; i < il; i += 2) {
        var atom1 = me.getResidueRepAtom(me.icn3d.pairArray[i]);
        var atom2 = me.getResidueRepAtom(me.icn3d.pairArray[i + 1]);

        if (rmLineArray != undefined) {
            for (var j = 0, jl = rmLineArray.length; j < jl; j += 2) {
                var atomb1 = me.getResidueRepAtom(rmLineArray[j]);
                var atomb2 = me.getResidueRepAtom(rmLineArray[j + 1]);
                if ((atom1.serial == atomb1.serial && atom2.serial == atomb2.serial)
                    || (atom1.serial == atomb2.serial && atom2.serial == atomb1.serial)
                ) {
                    index = i;
                    break;
                }
            }
        }

        if (index !== undefined) break;
    }

    if (index !== undefined) {
        me.icn3d.pairArray.splice(index, 2); // removetwoelements at index i
    }
};

iCn3DUI.prototype.outputSelection = function () {
    var me = this;
    var residues = {};
    for (var i in me.icn3d.hAtoms) {
        var residueId = me.icn3d.atoms[i].structure + '_' + me.icn3d.atoms[i].chain + '_' + me.icn3d.atoms[i].resi;
        residues[residueId] = 1;
    }

    var residueArray = Object.keys(residues).sort(function (a, b) {
        if (a !== '' && !isNaN(a)) {
            return parseInt(a) - parseInt(b);
        }
        else {
            var lastPosA = a.lastIndexOf('_');
            var lastPosB = b.lastIndexOf('_');
            if (a.substr(0, lastPosA) < b.substr(0, lastPosA)) return -1;
            else if (a.substr(0, lastPosA) > b.substr(0, lastPosA)) return 1;
            else if (a.substr(0, lastPosA) == b.substr(0, lastPosA)) {
                if (parseInt(a.substr(lastPosA + 1)) < parseInt(b.substr(lastPosB + 1))) return -1;
                else if (parseInt(a.substr(lastPosA + 1)) > parseInt(b.substr(lastPosB + 1))) return 1;
                else if (parseInt(a.substr(lastPosA + 1)) == parseInt(b.substr(lastPosB + 1))) return 0;
            }
        }
    });

    var output = "<table><tr><th>Structure</th><th>Chain</th><th>Residue Number</th></tr>";
    for (var i = 0, il = residueArray.length; i < il; ++i) {
        //if(typeof(residueArray[i]) === 'function') continue;

        var firstPos = residueArray[i].indexOf('_');
        var lastPos = residueArray[i].lastIndexOf('_');
        var structure = residueArray[i].substr(0, firstPos);
        var chain = residueArray[i].substr(firstPos + 1, lastPos - firstPos - 1);
        var resi = residueArray[i].substr(lastPos + 1);

        output += "<tr><td>" + structure + "</td><td>" + chain + "</td><td>" + resi + "</td></tr>";
    }

    me.saveFile(me.inputid + '_residues.txt', 'html', output);

};

// within the display atoms, show the bonds between C alpha or nucleotide N3
// 1. add hbonds in protein and nucleotide
// 2. add stabilizer between chemicals/ions and proteins
iCn3DUI.prototype.addStabilizer = function () {
    var me = this;
    var threshold = 3.5; //between 3.2 and 4.0

    var minHbondLen = 3.2;

    //me.icn3d.opts["stabilizer"] = "yes";
    me.icn3d.opts["water"] = "dot";

    if (Object.keys(me.icn3d.dAtoms).length > 0) {

        // 1. add hbonds in nucleotide
        var atomHbond = {};
        var chain_resi_atom;

        var maxlengthSq = threshold * threshold;
        var minlengthSq = minHbondLen * minHbondLen;

        for (var i in me.icn3d.dAtoms) {
            var atom = me.icn3d.atoms[i];

            // protein: N, O
            // DNA: C: O2, N3, N4; G: N1, N2, O6; A: N1, N6; T: N1, N6
            if (me.icn3d.nucleotides.hasOwnProperty(atom.serial) && (atom.name === "N1" || atom.name === "N2"
                || atom.name === "N3" || atom.name === "N4" || atom.name === "N6" || atom.name === "O2" || atom.name === "O6")
            ) { // calculate hydrogen bond in residue backbone
                chain_resi_atom = atom.structure + "_" + atom.chain + "_" + atom.resi + "_" + atom.name;

                atomHbond[chain_resi_atom] = atom;
            }
        } // end of for (var i in molecule) {

        var atomArray = Object.keys(atomHbond);
        var len = atomArray.length;

        if (me.icn3d.pairArray === undefined) me.icn3d.pairArray = [];
        for (var i = 0; i < len; ++i) {
            for (var j = i + 1; j < len; ++j) {
                var atomid1 = atomArray[i];
                var atomid2 = atomArray[j];

                var xdiff = Math.abs(atomHbond[atomid1].coord.x - atomHbond[atomid2].coord.x);
                if (xdiff > threshold) continue;

                var ydiff = Math.abs(atomHbond[atomid1].coord.y - atomHbond[atomid2].coord.y);
                if (ydiff > threshold) continue;

                var zdiff = Math.abs(atomHbond[atomid1].coord.z - atomHbond[atomid2].coord.z);
                if (zdiff > threshold) continue;

                var dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
                if (dist > maxlengthSq || dist < minlengthSq) continue;

                // output hydrogen bonds
                me.icn3d.pairArray.push(atomHbond[atomid1].serial);
                me.icn3d.pairArray.push(atomHbond[atomid2].serial);
            } // end of for (var j
        } // end of for (var i

        // 2. add stabilizer for chemicals/ions and proteins
        var maxDistance = 6; // connect within 6 angstrom, use 6 since some proteins such as 1FFK_A has large distance between residues

        //displayed residues
        var displayResidueHash = {};
        for (var i in me.icn3d.dAtoms) {
            var atom = me.icn3d.atoms[i];

            var residueid = atom.structure + "_" + atom.chain + "_" + atom.resi;
            displayResidueHash[residueid] = 1;
        }

        // connect chemicals, ions, and every third protein residues to neighbors (within 4 angstrom)
        var residueHash = {};
        //chemicals
        for (var i in me.icn3d.chemicals) {
            var atom = me.icn3d.atoms[i];

            var residueid = atom.structure + "_" + atom.chain + "_" + atom.resi;
            if (displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
        }
        //ions
        for (var i in me.icn3d.ions) {
            var atom = me.icn3d.atoms[i];

            var residueid = atom.structure + "_" + atom.chain + "_" + atom.resi;
            if (displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
        }

        //every third protein residues
        var chainArray = Object.keys(me.icn3d.chains);
        for (var i = 0, il = chainArray.length; i < il; ++i) {
            var chainid = chainArray[i];
            var coilCnt = 0;
            var residueid;
            var prevResi = 0;
            for (var j = 0, jl = me.icn3d.chainsSeq[chainid].length; j < jl; ++j) {
                residueid = chainid + '_' + me.icn3d.chainsSeq[chainid][j].resi;
                if (me.icn3d.secondaries[residueid] == 'c' || me.icn3d.secondaries[residueid] == 'E' || me.icn3d.secondaries[residueid] == 'H') {
                    // add every third residue
                    if (coilCnt % 3 == 0 || me.icn3d.chainsSeq[chainid][j].resi != prevResi + 1) {
                        if (displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
                    }

                    ++coilCnt;

                    prevResi = me.icn3d.chainsSeq[chainid][j].resi;
                }
            }

            // last residue
            if (me.icn3d.secondaries[residueid] == 'c' || me.icn3d.secondaries[residueid] == 'E' || me.icn3d.secondaries[residueid] == 'H') {
                if (displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
            }
        }

        var residueArray = Object.keys(residueHash);

        if (me.icn3d.pairArray === undefined) me.icn3d.pairArray = [];
        // displayed atoms except water
        var dAtomsNotWater = me.icn3d.exclHash(me.icn3d.dAtoms, me.icn3d.water);

        for (var i = 0, il = residueArray.length; i < il; ++i) {
            var residueid = residueArray[i];
            var ss = me.icn3d.secondaries[residueid];

            //var sphere = me.icn3d.getNeighboringAtoms(me.icn3d.dAtoms, me.icn3d.hash2Atoms(me.icn3d.residues[residueid]), maxDistance);
            var sphere = me.icn3d.getNeighboringAtoms(dAtomsNotWater, me.icn3d.hash2Atoms(me.icn3d.residues[residueid]), maxDistance);

            // original atoms
            var sphereArray = Object.keys(sphere).sort();
            var atomArray = Object.keys(me.icn3d.residues[residueid]).sort();

            var bProtein = false;
            if (me.icn3d.proteins.hasOwnProperty(atomArray[0])) { // protein
                atomArray = [atomArray[0]]; // one atom from the residue

                bProtein = true;

                // remove the previous, current and the next residues, chemicals, and ions from "sphere"
                var resi = parseInt(residueid.substr(residueid.lastIndexOf('_') + 1));

                var simSphere = {};
                for (var serial in sphere) {
                    if (me.icn3d.chemicals.hasOwnProperty(serial) || me.icn3d.ions.hasOwnProperty(serial)) continue;

                    var atom = me.icn3d.atoms[serial];
                    if ((ss == 'c' && (atom.resi > resi + 1 || atom.resi < resi - 1))
                        || (ss == 'E' && (atom.resi > resi + 2 || atom.resi < resi - 2))
                        || (ss == 'H' && (atom.resi > resi + 4 || atom.resi < resi - 4))
                    ) {
                        simSphere[serial] = 1;
                    }
                }

                sphereArray = Object.keys(simSphere).sort();
            }

            // one line per each protein residue
            if (sphereArray.length > 0 && atomArray.length > 0) {
                if (bProtein) {
                    var inter2 = parseInt((sphereArray.length + 0.5) / 2.0);
                    me.icn3d.pairArray.push(atomArray[0]);
                    me.icn3d.pairArray.push(sphereArray[inter2]);
                }
                else { // chemicals or ions
                    var n = 10;
                    var step = parseInt(sphereArray.length / (n + 1));

                    for (var j = 0, jl = atomArray.length; j < jl; ++j) {
                        if (j % n == 0) { // make one line for every other 10 atoms
                            var sphereIndex = parseInt(j / n) * step;
                            var inter2 = (sphereIndex < sphereArray.length) ? sphereIndex : sphereArray.length - 1;
                            me.icn3d.pairArray.push(atomArray[j]);
                            me.icn3d.pairArray.push(sphereArray[inter2]);

                            if (atomArray.length < n + 1) {
                                me.icn3d.pairArray.push(atomArray[j]);
                                me.icn3d.pairArray.push(sphereArray[sphereArray.length - 1]);
                            }
                        }
                    }
                } // else
            } // if(sphereArray.length > 0) {
        } // for

        //me.updateStabilizer();

        //me.prepareFor3Dprint();
    }
};

iCn3DUI.prototype.hideStabilizer = function () {
    var me = this;
    //me.icn3d.opts["stabilizer"] = "no";
    me.icn3d.pairArray = [];

    me.icn3d.lines['stabilizer'] = [];
    me.icn3d.stabilizerpnts = [];

    for (var i in me.icn3d.water) {
        me.icn3d.atoms[i].style = me.icn3d.opts["water"];
    }

    //me.icn3d.draw();
};

iCn3DUI.prototype.getResidueRepPos = function (serial) {
    var me = this;
    var atomIn = me.icn3d.atoms[serial];
    var residueid = atomIn.structure + "_" + atomIn.chain + "_" + atomIn.resi;

    var pos;
    if (!me.icn3d.proteins.hasOwnProperty(serial) && !me.icn3d.nucleotides.hasOwnProperty(serial)) { // chemicals or ions
        pos = atomIn.coord;
    }
    else {
        for (var i in me.icn3d.residues[residueid]) {
            var atom = me.icn3d.atoms[i];
            if (atom.name === 'N3') { // nucleotide: N3
                pos = me.icn3d.atoms[i].coord;
                break;
            }
            else if (atom.name === 'CA' && atom.ss == 'coil') { // protein coil: CA
                pos = me.icn3d.atoms[i].coord;
                break;
            }
            else if (atom.name === 'CA' && (atom.ss == 'helix' || atom.ss == 'sheet')) { // protein secondary: CA
                pos = (me.icn3d.atoms[i].coord2 !== undefined) ? me.icn3d.atoms[i].coord2 : me.icn3d.atoms[i].coord;
                break;
            }
        }
    }

    if (pos === undefined) pos = atomIn.coord;

    return pos;
};

iCn3DUI.prototype.getResidueRepAtom = function (serial) {
    var me = this;
    var atomIn = me.icn3d.atoms[serial];
    var residueid = atomIn.structure + "_" + atomIn.chain + "_" + atomIn.resi;

    var foundAtom;
    if (!me.icn3d.proteins.hasOwnProperty(serial) && !me.icn3d.nucleotides.hasOwnProperty(serial)) { // chemicals or ions
        foundAtom = atomIn;
    }
    else {
        for (var i in me.icn3d.residues[residueid]) {
            var atom = me.icn3d.atoms[i];
            if (atom.name === 'CA' || atom.name === 'N3') { // protein: CA, nucleotide: N3
                foundAtom = me.icn3d.atoms[i];
                break;
            }
        }
    }

    if (foundAtom === undefined) foundAtom = atomIn;

    return foundAtom;
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.downloadAlignment = function (align) {
    var me = this;
    me.opts['proteins'] = 'c alpha trace';
    me.icn3d.opts['proteins'] = 'c alpha trace';

    if (me.bFullUi && me.isMac() && me.isMobile) {
        me.MENU_WIDTH = 950; // have enough space to show image in iphone

        me.setViewerWidthHeight();

        var width = me.WIDTH - me.LESSWIDTH;
        var height = me.HEIGHT - me.LESSHEIGHT;

        me.resizeCanvas(width, height, true, false);
    }

    var alignArray = align.split(',');
    //var ids_str = (alignArray.length === 2? 'uids=' : 'ids=') + align;
    var ids_str = 'ids=' + align;
    //var url = 'https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?cmd=c&w3d&' + ids_str;
    //var url2 = 'https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?cmd=c1&d&' + ids_str;

    var url = 'https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?v=2&cmd=c&w3d&' + ids_str;
    var url2 = 'https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?v=2&cmd=c1&d=1&' + ids_str;

    if (me.cfg.inpara !== undefined) {
        url += me.cfg.inpara;
        url2 += me.cfg.inpara;
    }

    me.icn3d.bCid = undefined;

    // define for 'align' only
    me.icn3d.pdbid_chain2title = {};

    if (me.chainids2resids === undefined) me.chainids2resids = {}; // me.chainids2resids[chainid1][chainid2] = [resid, resid]

    var request = $.ajax({
        url: url2,
        dataType: 'jsonp',
        cache: true
    });

    var seqalign = {};

    var chained = request.then(function (data) {
        seqalign = data.seqalign;
        if (seqalign === undefined) {
            alert("These two MMDB IDs " + alignArray + " do not have 3D alignment data.");
            return false;
        }

        // set me.icn3d.pdbid_molid2chain and me.icn3d.chainsColor
        me.icn3d.pdbid_molid2chain = {};
        me.icn3d.chainsColor = {};
        //me.mmdbidArray = [];
        //for(var i in data) {

        for (var i = 0, il = 2; i < il; ++i) {
            //if(i === 'seqalign') continue;
            var mmdbTmp = data['alignedStructures'][0][i];

            //var pdbid = (data[i].pdbid !== undefined) ? data[i].pdbid : i;
            var pdbid = (mmdbTmp.pdbId !== undefined) ? mmdbTmp.pdbId : mmdbTmp.mmdbId;
            //me.mmdbidArray.push(pdbid); // here two molecules are in alphabatic order, themaster molecule could not be the first one

            var chainNameHash = {}; // chain name may be the same in assembly
            for (var molid in mmdbTmp.molecules) {
                var chainName = mmdbTmp.molecules[molid].chain.trim();
                if (chainNameHash[chainName] === undefined) {
                    chainNameHash[chainName] = 1;
                }
                else {
                    ++chainNameHash[chainName];
                }

                var finalChain = (chainNameHash[chainName] === 1) ? chainName : chainName + chainNameHash[chainName].toString();

                me.icn3d.pdbid_molid2chain[pdbid + '_' + molid] = finalChain;

                if (mmdbTmp.molecules[molid].kind === 'p' || mmdbTmp.molecules[molid].kind === 'n') {
                    me.icn3d.chainsColor[pdbid + '_' + finalChain] = new THREE.Color(me.GREY8);
                }
            }
        }

        //var index = 0;
        //for(var mmdbid in data) {
        for (var i = 0, il = 2; i < il; ++i) {
            //if(index < 2) {
            var mmdbTmp = data['alignedStructures'][0][i];

            var pdbid = mmdbTmp.pdbId;

            var molecule = mmdbTmp.molecules;
            for (var molname in molecule) {
                var chain = molecule[molname].chain;
                me.icn3d.pdbid_chain2title[pdbid + '_' + chain] = molecule[molname].name;
            }
            //}

            //++index;
        }

        // get the color for each aligned chain pair
        me.alignmolid2color = [];
        me.alignmolid2color[0] = {};
        me.alignmolid2color[1] = {};
        var colorLength = me.icn3d.stdChainColors.length;

        for (var i = 0, il = seqalign.length; i < il; ++i) {
            var molid1 = seqalign[i][0].moleculeId;
            var molid2 = seqalign[i][1].moleculeId;

            me.alignmolid2color[0][molid1] = (i + 1).toString();
            me.alignmolid2color[1][molid2] = (i + 1).toString();
        }

        return $.ajax({
            url: url,
            dataType: 'jsonp',
            //jsonp: 'jpf',
            cache: true,
            beforeSend: function () {
                me.showLoading();
            },
            complete: function () {
                me.hideLoading();
            }
        });
    });

    chained.done(function (data) { // url
        if (data.atoms !== undefined) {
            me.icn3d.init();

            me.loadAtomDataIn(data, undefined, 'align', seqalign);

            if (me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
                $("#" + me.pre + "alternateWrapper").hide();
            }

            // show all
            var allAtoms = {};
            for (var i in me.icn3d.atoms) {
                allAtoms[i] = 1;
            }
            me.icn3d.dAtoms = allAtoms;
            me.icn3d.hAtoms = allAtoms;

            me.icn3d.setAtomStyleByOptions(me.opts);
            // change the default color to "Identity"
            me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

            //var mmdbidArray = me.inputid.split('_');
            me.mmdbidArray = [];
            for (var i = 0, il = data.alignedStructures[0].length; i < il; ++i) {
                me.mmdbidArray.push(data.alignedStructures[0][i].pdbId);
            }

            me.renderStructure();

            if (me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

            me.html2ddgm = '';

            //setTimeout(function(){
            //    me.set2DDiagramsForAlign(me.mmdbidArray[0].toUpperCase(), me.mmdbidArray[1].toUpperCase());
            //}, 0);

            // by default, open the seq alignment window
            //if(me.cfg.show2d !== undefined && me.cfg.show2d) me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');
            if (me.cfg.showalignseq !== undefined && me.cfg.showalignseq) {
                me.openDialog(me.pre + 'dl_alignment', 'Select residues in aligned sequences');
            }

            if (me.cfg.show2d !== undefined && me.cfg.show2d) {
                me.set2DDiagramsForAlign(me.mmdbidArray[0].toUpperCase(), me.mmdbidArray[1].toUpperCase());
            }

            //if(me.cfg.showseq !== undefined && me.cfg.showseq) me.openDialog(me.pre + 'dl_selectresidues', 'Select residues in sequences');

            if (me.deferred !== undefined) me.deferred.resolve(); if (me.deferred2 !== undefined) me.deferred2.resolve();
        }
        else {
            alert('invalid atoms data.');
            return false;
        }
    });
};

iCn3DUI.prototype.set2DDiagramsForAlign = function (mmdbid1, mmdbid2) {
    var me = this;
    me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');

    var url1 = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&uid=" + mmdbid1 + "&intrac=1";
    var url2 = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&uid=" + mmdbid2 + "&intrac=1";

    if (me.cfg.inpara !== undefined) {
        url1 += me.cfg.inpara;
        url2 += me.cfg.inpara;
    }

    var request1 = $.ajax({
        url: url1,
        dataType: 'jsonp',
        cache: true
    });

    var request2 = request1.then(function (data) {
        me.interactionData1 = data;

        me.html2ddgm = '';

        me.draw2Ddgm(data, mmdbid1, 0);
        if (me.cfg.show2d !== undefined && me.cfg.show2d) me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');

        return $.ajax({
            url: url2,
            dataType: 'jsonp',
            cache: true
        });
    });

    request2.done(function (data) {
        me.interactionData2 = data;

        me.draw2Ddgm(data, mmdbid2, 1);

        me.html2ddgm += "<br>" + me.set2DdgmNote(true);
        $("#" + me.pre + "dl_2ddgm").html(me.html2ddgm);

        me.b2DShown = true;
        //if(me.cfg.show2d !== undefined && me.cfg.show2d) me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');

        if (me.deferredViewinteraction !== undefined) me.deferredViewinteraction.resolve();
    });
};

iCn3DUI.prototype.download2Ddgm = function (mmdbid, structureIndex) {
    var me = this;
    /*
      me.deferred3 = $.Deferred(function() {
        var url="https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?uid="+mmdbid+"&format=json&intrac=3";
    
       if(me.cfg.inpara !== undefined) {
          url += me.cfg.inpara;
       }
    
        $.ajax({
            url: url,
            dataType: 'jsonp',
            tryCount : 0,
            retryLimit : 1,
            success: function( data ) {
                me.draw2Ddgm(data, mmdbid, structureIndex);
    
                if(me.cfg.show2d !== undefined && me.cfg.show2d) me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');
                if(me.deferred3 !== undefined) me.deferred3.resolve();
            },
            error : function(xhr, textStatus, errorThrown ) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }
                return;
            }
        });
      });
    
      return me.deferred3.promise();
    */

    me.set2DDiagrams(mmdbid);
};

iCn3DUI.prototype.set2DDiagrams = function (mmdbid) {
    var me = this;
    me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');

    if (me.b2DShown === undefined || !me.b2DShown) {
        me.html2ddgm = '';

        me.draw2Ddgm(me.interactionData, mmdbid);

        me.html2ddgm += "<br>" + me.set2DdgmNote();
        $("#" + me.pre + "dl_2ddgm").html(me.html2ddgm);
    }

    me.b2DShown = true;
};

iCn3DUI.prototype.setSeqAlign = function (seqalign, alignedStructures) {
    var me = this;
    //loadSeqAlignment
    var alignedAtoms = {};
    var mmdbid1 = alignedStructures[0][0].pdbId;
    var mmdbid2 = alignedStructures[0][1].pdbId;

    me.conservedName1 = mmdbid1 + '_cons';
    me.nonConservedName1 = mmdbid1 + '_ncons';
    me.notAlignedName1 = mmdbid1 + '_nalign';

    me.conservedName2 = mmdbid2 + '_cons';
    me.nonConservedName2 = mmdbid2 + '_ncons';
    me.notAlignedName2 = mmdbid2 + '_nalign';

    me.consHash1 = {};
    me.nconsHash1 = {};
    me.nalignHash1 = {};

    me.consHash2 = {};
    me.nconsHash2 = {};
    me.nalignHash2 = {};

    for (var i = 0, il = seqalign.length; i < il; ++i) {
        // first sequence
        var alignData = seqalign[i][0];
        var molid1 = alignData.moleculeId;

        var chain1 = me.icn3d.pdbid_molid2chain[mmdbid1 + '_' + molid1];
        var chainid1 = mmdbid1 + '_' + chain1;

        var id2aligninfo = {};
        var start = alignData.sequence.length, end = -1;
        var bStart = false;
        for (var j = 0, jl = alignData.sequence.length; j < jl; ++j) {
            // 0: internal resi id, 1: pdb resi id, 2: resn, 3: aligned or not
            //var resi = alignData.sequence[j][1];
            var resi = alignData.sequence[j][0];
            var resn = (alignData.sequence[j][2] === '~') ? '-' : alignData.sequence[j][2];
            //resn = resn.toUpperCase();

            var aligned = (alignData.sequence[j][3]) ? 1 : 0; // alignData.sequence[j][3]: 0, false, 1, true

            if (aligned == 1) {
                if (j < start && !bStart) {
                    start = j;
                    bStart = true; // set start just once
                }
                if (j > end) end = j;
            }

            id2aligninfo[j] = { "resi": resi, "resn": resn, "aligned": aligned };
        }

        // second sequence
        alignData = seqalign[i][1];
        var molid2 = alignData.moleculeId;

        var chain2 = me.icn3d.pdbid_molid2chain[mmdbid2 + '_' + molid2];
        var chainid2 = mmdbid2 + '_' + chain2;

        // annoation title for the master seq only
        if (me.icn3d.alnChainsAnTtl[chainid1] === undefined) me.icn3d.alnChainsAnTtl[chainid1] = [];
        if (me.icn3d.alnChainsAnTtl[chainid1][0] === undefined) me.icn3d.alnChainsAnTtl[chainid1][0] = [];
        if (me.icn3d.alnChainsAnTtl[chainid1][1] === undefined) me.icn3d.alnChainsAnTtl[chainid1][1] = [];
        if (me.icn3d.alnChainsAnTtl[chainid1][2] === undefined) me.icn3d.alnChainsAnTtl[chainid1][2] = [];
        if (me.icn3d.alnChainsAnTtl[chainid1][3] === undefined) me.icn3d.alnChainsAnTtl[chainid1][3] = [];
        if (me.icn3d.alnChainsAnTtl[chainid1][4] === undefined) me.icn3d.alnChainsAnTtl[chainid1][4] = [];
        if (me.icn3d.alnChainsAnTtl[chainid1][5] === undefined) me.icn3d.alnChainsAnTtl[chainid1][5] = [];
        if (me.icn3d.alnChainsAnTtl[chainid1][6] === undefined) me.icn3d.alnChainsAnTtl[chainid1][6] = [];

        // two annotations without titles
        me.icn3d.alnChainsAnTtl[chainid1][0].push(chainid2);
        me.icn3d.alnChainsAnTtl[chainid1][1].push(chainid1);
        me.icn3d.alnChainsAnTtl[chainid1][2].push("");
        me.icn3d.alnChainsAnTtl[chainid1][3].push("");

        // 2nd chain title
        me.icn3d.alnChainsAnTtl[chainid1][4].push(chainid2);
        // master chain title
        me.icn3d.alnChainsAnTtl[chainid1][5].push(chainid1);
        // empty line
        me.icn3d.alnChainsAnTtl[chainid1][6].push("");

        var alignIndex = 1;
        //for(var j = 0, jl = alignData.sseq.length; j < jl; ++j) {
        for (var j = start; j <= end; ++j) {
            // 0: internal resi id, 1: pdb resi id, 2: resn, 3: aligned or not
            //var resi = alignData.sequence[j][1];
            var resi = alignData.sequence[j][0];
            var resn = (alignData.sequence[j][2] === '~') ? '-' : alignData.sequence[j][2];
            //resn = resn.toUpperCase();

            var alignedTmp = (alignData.sequence[j][3]) ? 1 : 0; // alignData.sequence[j][3]: 0, false, 1, true

            var aligned = id2aligninfo[j].aligned + alignedTmp; // 0 or 2

            var color, classname;
            if (aligned === 2) { // aligned
                if (id2aligninfo[j].resn === resn) {
                    color = '#FF0000';
                    classname = 'icn3d-cons';

                    me.consHash1[chainid1 + '_' + id2aligninfo[j].resi] = 1;
                    me.consHash2[chainid2 + '_' + resi] = 1;
                }
                else {
                    color = '#0000FF';
                    classname = 'icn3d-ncons';

                    me.nconsHash1[chainid1 + '_' + id2aligninfo[j].resi] = 1;
                    me.nconsHash2[chainid2 + '_' + resi] = 1;
                }

                // expensive and thus remove
                //alignedAtoms = me.icn3d.unionHash(alignedAtoms, me.icn3d.residues[chainid1 + '_' + id2aligninfo[j].resi]);
                //alignedAtoms = me.icn3d.unionHash(alignedAtoms, me.icn3d.residues[chainid2 + '_' + resi]);
            }
            else {
                color = me.GREY8;
                classname = 'icn3d-nalign';

                me.nalignHash1[chainid1 + '_' + id2aligninfo[j].resi] = 1;
                me.nalignHash2[chainid2 + '_' + resi] = 1;
            }

            // chain1
            if (me.icn3d.alnChainsSeq[chainid1] === undefined) me.icn3d.alnChainsSeq[chainid1] = [];

            var resObject = {};
            resObject.mmdbid = mmdbid1;
            resObject.chain = chain1;
            resObject.resi = id2aligninfo[j].resi;
            // resi will be empty if there is no coordinates
            resObject.resn = (resObject.resi === '' || classname === 'icn3d-nalign') ? id2aligninfo[j].resn.toLowerCase() : id2aligninfo[j].resn;
            resObject.aligned = aligned;
            // resi will be empty if there is no coordinates
            resObject.color = (resObject.resi === '') ? me.GREYC : color;
            resObject.class = classname;

            me.icn3d.alnChainsSeq[chainid1].push(resObject);

            if (id2aligninfo[j].resi !== '') {
                if (me.icn3d.alnChains[chainid1] === undefined) me.icn3d.alnChains[chainid1] = {};
                $.extend(me.icn3d.alnChains[chainid1], me.icn3d.residues[chainid1 + '_' + id2aligninfo[j].resi]);
            }

            // chain2
            if (me.icn3d.alnChainsSeq[chainid2] === undefined) me.icn3d.alnChainsSeq[chainid2] = [];

            resObject = {};
            resObject.mmdbid = mmdbid2;
            resObject.chain = chain2;
            resObject.resi = resi;
            // resi will be empty if there is no coordinates
            resObject.resn = (resObject.resi === '' || classname === 'icn3d-nalign') ? resn.toLowerCase() : resn;
            resObject.aligned = aligned;
            // resi will be empty if there is no coordinates
            resObject.color = (resObject.resi === '') ? me.GREYC : color;
            resObject.class = classname;

            me.icn3d.alnChainsSeq[chainid2].push(resObject);

            if (resObject.resi !== '') {
                if (me.icn3d.alnChains[chainid2] === undefined) me.icn3d.alnChains[chainid2] = {};
                $.extend(me.icn3d.alnChains[chainid2], me.icn3d.residues[chainid2 + '_' + resi]);
            }

            // annotation is for the master seq only
            if (me.icn3d.alnChainsAnno[chainid1] === undefined) me.icn3d.alnChainsAnno[chainid1] = [];
            if (me.icn3d.alnChainsAnno[chainid1][0] === undefined) me.icn3d.alnChainsAnno[chainid1][0] = [];
            if (me.icn3d.alnChainsAnno[chainid1][1] === undefined) me.icn3d.alnChainsAnno[chainid1][1] = [];
            if (me.icn3d.alnChainsAnno[chainid1][2] === undefined) me.icn3d.alnChainsAnno[chainid1][2] = [];
            if (me.icn3d.alnChainsAnno[chainid1][3] === undefined) me.icn3d.alnChainsAnno[chainid1][3] = [];
            if (j === start) {
                // empty line
                // 2nd chain title
                if (me.icn3d.alnChainsAnno[chainid1][4] === undefined) me.icn3d.alnChainsAnno[chainid1][4] = [];
                // master chain title
                if (me.icn3d.alnChainsAnno[chainid1][5] === undefined) me.icn3d.alnChainsAnno[chainid1][5] = [];
                // empty line
                if (me.icn3d.alnChainsAnno[chainid1][6] === undefined) me.icn3d.alnChainsAnno[chainid1][6] = [];

                me.icn3d.alnChainsAnno[chainid1][4].push(me.icn3d.pdbid_chain2title[chainid2]);
                me.icn3d.alnChainsAnno[chainid1][5].push(me.icn3d.pdbid_chain2title[chainid1]);
                me.icn3d.alnChainsAnno[chainid1][6].push('');
            }

            var residueid1 = chainid1 + '_' + id2aligninfo[j].resi;
            var residueid2 = chainid2 + '_' + resi;
            var ss1 = me.icn3d.secondaries[residueid1];
            var ss2 = me.icn3d.secondaries[residueid2];
            if (ss2 !== undefined) {
                me.icn3d.alnChainsAnno[chainid1][0].push(ss2);
            }
            else {
                me.icn3d.alnChainsAnno[chainid1][0].push('-');
            }

            if (ss1 !== undefined) {
                me.icn3d.alnChainsAnno[chainid1][1].push(ss1);
            }
            else {
                me.icn3d.alnChainsAnno[chainid1][1].push('-');
            }

            var symbol = '.';
            if (alignIndex % 5 === 0) symbol = '*';
            if (alignIndex % 10 === 0) symbol = '|';
            me.icn3d.alnChainsAnno[chainid1][2].push(symbol); // symbol: | for 10th, * for 5th, . for rest

            var numberStr = '';
            if (alignIndex % 10 === 0) numberStr = alignIndex.toString();
            me.icn3d.alnChainsAnno[chainid1][3].push(numberStr); // symbol: 10, 20, etc, empty for rest

            ++alignIndex;
        } // end for(var j
    } // end for(var i

    seqalign = {};
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.loadMol2Data = function (data) {
    var me = this;

    var bResult = me.loadMol2AtomData(data);

    if (me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        $("#" + me.pre + "alternateWrapper").hide();
    }

    if (!bResult) {
        alert('The Mol2 file has the wrong format...');
    }
    else {
        me.icn3d.setAtomStyleByOptions(me.opts);
        me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

        me.renderStructure();

        if (me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

        if (me.deferred !== undefined) me.deferred.resolve(); if (me.deferred2 !== undefined) me.deferred2.resolve();
    }
};

iCn3DUI.prototype.loadMol2AtomData = function (data) {
    var me = this;
    var lines = data.split(/\r?\n|\r/);
    if (lines.length < 4) return false;

    me.icn3d.init();

    var structure = 1;
    var chain = 'A';
    var resn = 'LIG';
    var resi = 1;

    var AtomHash = {};
    var moleculeNum = 1, chainNum = '1_A', residueNum = '1_A_1';
    var atomCount, bondCount, atomIndex = 0, bondIndex = 0;
    var serial = 1;

    var bAtomSection = false, bBondSection = false;

    var atomid2serial = {};
    var skipAtomids = {};

    var prevBondType = '', contiArrBondCnt = 0;

    for (var i = 0, il = lines.length; i < il; ++i) {
        var line = lines[i].trim();
        if (line === '') continue;
        if (line.substr(0, 1) === '#') continue;

        if (line == '@<TRIPOS>MOLECULE') {
            me.icn3d.molTitle = lines[i + 1].trim();
            var atomCnt_bondCnt = lines[i + 2].trim().replace(/\s+/g, " ").split(" ");
            atomCount = atomCnt_bondCnt[0];
            bondCount = atomCnt_bondCnt[1];
            i = i + 4;
        }
        else if (line == '@<TRIPOS>ATOM') { // 1    C1    1.207    2.091    0.000    C.ar    1    BENZENE    0.000
            serial = 1;

            bAtomSection = true;

            ++i;
        }
        else if (line == '@<TRIPOS>BOND') { // 1    1    2    ar
            bBondSection = true;
            bAtomSection = false;

            ++i;
        }
        else if (line == '@<TRIPOS>SUBSTRUCTURE') { // 1    1    2    ar
            bBondSection = false;

            ++i;
        }

        line = lines[i].trim();
        if (line === '') continue;
        if (line.substr(0, 1) === '#') continue;

        if (bAtomSection && atomIndex < atomCount) {
            // 1    C1    1.207    2.091    0.000    C.ar    1    BENZENE    0.000
            var atomArray = line.replace(/\s+/g, " ").split(" ");

            var atomid = parseInt(atomArray[0]);
            atomid2serial[atomid] = serial;

            var name = atomArray[1];
            var x = parseFloat(atomArray[2]);
            var y = parseFloat(atomArray[3]);
            var z = parseFloat(atomArray[4]);
            var coord = new THREE.Vector3(x, y, z);

            var elemFull = atomArray[5];
            var pos = elemFull.indexOf('.');

            var elem;
            if (pos === -1) {
                elem = elemFull;
            }
            else {
                elem = elemFull.substr(0, pos);
            }

            // skip H, but keep H.spc, H.t3p, etc
            if (elem === 'H' && elem === elemFull) {
                skipAtomids[atomid] = 1;
            }
            else {
                var atomDetails = {
                    het: true,              // optional, used to determine chemicals, water, ions, etc
                    serial: serial,         // required, unique atom id
                    name: name,             // required, atom name
                    resn: resn,             // optional, used to determine protein or nucleotide
                    structure: structure,   // optional, used to identify structure
                    chain: chain,           // optional, used to identify chain
                    resi: resi,             // optional, used to identify residue ID
                    coord: coord,           // required, used to draw 3D shape
                    b: 0,                   // optional, used to draw B-factor tube
                    elem: elem,             // optional, used to determine hydrogen bond
                    bonds: [],              // required, used to connect atoms
                    ss: 'coil',             // optional, used to show secondary structures
                    ssbegin: false,         // optional, used to show the beginning of secondary structures
                    ssend: false,           // optional, used to show the end of secondary structures

                    bondOrder: []           // optional, specific for chemicals
                };

                me.icn3d.atoms[serial] = atomDetails;
                AtomHash[serial] = 1;

                ++serial;
            }

            ++atomIndex;
        }

        if (bBondSection && bondIndex < bondCount) {
            // 1    1    2    ar
            var bondArray = line.replace(/\s+/g, " ").split(" ");
            var fromAtomid = parseInt(bondArray[1]);
            var toAtomid = parseInt(bondArray[2]);
            var bondType = bondArray[3];
            var finalBondType = bondType;

            //� 1 = single � 2 = double � 3 = triple � am = amide � ar = aromatic � du = dummy � un = unknown (cannot be determined from the parameter tables) � nc = not connected
            if (bondType === 'am') {
                finalBondType = '1';
            }

            if (bondType === 'ar') {
                finalBondType = '1.5';
            }

            if (!skipAtomids.hasOwnProperty(fromAtomid) && !skipAtomids.hasOwnProperty(toAtomid) && (finalBondType === '1' || finalBondType === '2' || finalBondType === '3' || finalBondType === '1.5')) {
                var order = finalBondType;
                var from = atomid2serial[fromAtomid];
                var to = atomid2serial[toAtomid];

                // skip all bonds between H and C
                //if( !(me.icn3d.atoms[from].elem === 'H' && me.icn3d.atoms[to].elem === 'C') && !(me.icn3d.atoms[from].elem === 'C' && me.icn3d.atoms[to].elem === 'H') ) {
                me.icn3d.atoms[from].bonds.push(to);
                me.icn3d.atoms[from].bondOrder.push(order);
                me.icn3d.atoms[to].bonds.push(from);
                me.icn3d.atoms[to].bondOrder.push(order);

                if (order == '2') {
                    me.icn3d.doublebonds[from + '_' + to] = 1;
                    me.icn3d.doublebonds[to + '_' + from] = 1;
                }
                else if (order == '3') {
                    me.icn3d.triplebonds[from + '_' + to] = 1;
                    me.icn3d.triplebonds[to + '_' + from] = 1;
                }
                else if (order == '1.5') {
                    me.icn3d.aromaticbonds[from + '_' + to] = 1;
                    me.icn3d.aromaticbonds[to + '_' + from] = 1;
                }
                //}
            }

            ++bondIndex;
            prevBondType = bondType;
        }
    }

    me.icn3d.dAtoms = AtomHash;
    me.icn3d.hAtoms = AtomHash;
    me.icn3d.structures[moleculeNum] = [chainNum]; //AtomHash;
    me.icn3d.chains[chainNum] = AtomHash;
    me.icn3d.residues[residueNum] = AtomHash;

    me.icn3d.residueId2Name[residueNum] = resn;

    if (me.icn3d.chainsSeq[chainNum] === undefined) me.icn3d.chainsSeq[chainNum] = [];
    /*
        if(me.icn3d.chainsAn[chainNum] === undefined ) me.icn3d.chainsAn[chainNum] = [];
        if(me.icn3d.chainsAn[chainNum][0] === undefined ) me.icn3d.chainsAn[chainNum][0] = [];
        if(me.icn3d.chainsAnTitle[chainNum] === undefined ) me.icn3d.chainsAnTitle[chainNum] = [];
        if(me.icn3d.chainsAnTitle[chainNum][0] === undefined ) me.icn3d.chainsAnTitle[chainNum][0] = [];
    */
    var resObject = {};
    resObject.resi = resi;
    resObject.name = resn;

    me.icn3d.chainsSeq[chainNum].push(resObject);
    //        me.icn3d.chainsAn[chainNum][0].push(resi);
    //        me.icn3d.chainsAnTitle[chainNum][0].push('');

    me.setMaxD();

    me.showTitle();

    return true;
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.loadXyzData = function (data) {
    var me = this;

    var bResult = me.loadXyzAtomData(data);

    if (me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        $("#" + me.pre + "alternateWrapper").hide();
    }

    if (!bResult) {
        alert('The XYZ file has the wrong format...');
    }
    else {
        me.icn3d.setAtomStyleByOptions(me.opts);
        me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

        me.renderStructure();

        if (me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

        if (me.deferred !== undefined) me.deferred.resolve(); if (me.deferred2 !== undefined) me.deferred2.resolve();
    }
};

iCn3DUI.prototype.setXyzAtomSeq = function (AtomHash, moleculeNum, chainNum, residueNum) {
    var me = this;
    me.icn3d.dAtoms = me.icn3d.unionHash(me.icn3d.dAtoms, AtomHash);
    me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, AtomHash);

    me.icn3d.structures[moleculeNum] = [chainNum]; //AtomHash;
    me.icn3d.chains[chainNum] = AtomHash;
    me.icn3d.residues[residueNum] = AtomHash;

    me.icn3d.residueId2Name[residueNum] = 'LIG';

    if (me.icn3d.chainsSeq[chainNum] === undefined) me.icn3d.chainsSeq[chainNum] = [];
    /*
        if(me.icn3d.chainsAn[chainNum] === undefined ) me.icn3d.chainsAn[chainNum] = [];
        if(me.icn3d.chainsAn[chainNum][0] === undefined ) me.icn3d.chainsAn[chainNum][0] = [];
        if(me.icn3d.chainsAnTitle[chainNum] === undefined ) me.icn3d.chainsAnTitle[chainNum] = [];
        if(me.icn3d.chainsAnTitle[chainNum][0] === undefined ) me.icn3d.chainsAnTitle[chainNum][0] = [];
    */
    var resObject = {};
    resObject.resi = 1;
    resObject.name = 'LIG';

    me.icn3d.chainsSeq[chainNum].push(resObject);
    //        me.icn3d.chainsAn[chainNum][0].push(1);
    //        me.icn3d.chainsAnTitle[chainNum][0].push('');

    // determine bonds
    var serialArray = Object.keys(AtomHash);
    for (var j = 0, jl = serialArray.length; j < jl; ++j) {
        var atom0 = me.icn3d.atoms[serialArray[j]];

        for (var k = j + 1, kl = serialArray.length; k < kl; ++k) {
            var atom1 = me.icn3d.atoms[serialArray[k]];
            var maxR = 1.2 * (me.icn3d.covalentRadii[atom0.elem] + me.icn3d.covalentRadii[atom1.elem]);
            if (Math.abs(atom0.coord.x - atom1.coord.x) > maxR) continue;
            if (Math.abs(atom0.coord.y - atom1.coord.y) > maxR) continue;
            if (Math.abs(atom0.coord.z - atom1.coord.z) > maxR) continue;

            if (me.icn3d.hasCovalentBond(atom0, atom1)) {
                me.icn3d.atoms[serialArray[j]].bonds.push(serialArray[k]);
                me.icn3d.atoms[serialArray[k]].bonds.push(serialArray[j]);
            }
        }
    }
},

    iCn3DUI.prototype.loadXyzAtomData = function (data) {
        var me = this;
        var lines = data.split(/\r?\n|\r/);
        if (lines.length < 3) return false;

        me.icn3d.init();

        var chain = 'A';
        var resn = 'LIG';
        var resi = 1;

        var AtomHash = {};
        var moleculeNum = 0, chainNum, residueNum;
        var structure, atomCount, serial = 1, offset = 2;

        me.icn3d.molTitle = "";

        for (var i = 0, il = lines.length; i < il; ++i) {
            var line = lines[i].trim();
            if (line === '') continue;

            if (line !== '' && !isNaN(line)) { // start a new molecule
                if (i !== 0) {
                    me.setXyzAtomSeq(AtomHash, moleculeNum, chainNum, residueNum);
                }

                ++moleculeNum;
                AtomHash = {};

                structure = moleculeNum;
                chainNum = structure + '_' + chain;
                residueNum = chainNum + '_' + resi;

                //12
                //glucose from 2gbp
                //C  35.884  30.895  49.120

                atomCount = parseInt(line);
                if (moleculeNum > 1) {
                    me.icn3d.molTitle += "; ";
                }
                me.icn3d.molTitle += lines[i + 1].trim();

                i = i + offset;
            }

            line = lines[i].trim();
            if (line === '') continue;

            var name_x_y_z = line.replace(/,/, " ").replace(/\s+/g, " ").split(" ");

            var name = name_x_y_z[0];
            var x = parseFloat(name_x_y_z[1]);
            var y = parseFloat(name_x_y_z[2]);
            var z = parseFloat(name_x_y_z[3]);
            var coord = new THREE.Vector3(x, y, z);

            var atomDetails = {
                het: true,              // optional, used to determine chemicals, water, ions, etc
                serial: serial,         // required, unique atom id
                name: name,             // required, atom name
                resn: resn,             // optional, used to determine protein or nucleotide
                structure: structure,   // optional, used to identify structure
                chain: chain,           // optional, used to identify chain
                resi: resi,             // optional, used to identify residue ID
                coord: coord,           // required, used to draw 3D shape
                b: 0,                   // optional, used to draw B-factor tube
                elem: name,             // optional, used to determine hydrogen bond
                bonds: [],              // required, used to connect atoms
                ss: 'coil',             // optional, used to show secondary structures
                ssbegin: false,         // optional, used to show the beginning of secondary structures
                ssend: false,           // optional, used to show the end of secondary structures

                bondOrder: []           // optional, specific for chemicals
            };

            me.icn3d.atoms[serial] = atomDetails;
            AtomHash[serial] = 1;

            ++serial;
        }

        me.setXyzAtomSeq(AtomHash, moleculeNum, chainNum, residueNum);

        me.setMaxD();

        me.showTitle();

        return true;
    };

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.showAnnotations = function () {
    var me = this;
    me.openDialog(me.pre + 'dl_selectannotations', 'Sequences and Annotations');

    // add note about assembly
    if ((me.bAssemblyNote === undefined || !me.bAssemblyNote) && me.icn3d.asuCnt !== undefined) {
        var html = "     <br><div id='" + me.pre + "assembly_note' style='margin-left:5px;'><span class='icn3d-annoLargeTitle'>Assembly Tips:</span> Only the asymmetric unit is shown in the sequence window.<br>Click \"Assembly\" in the menu \"View\" to switch between asymmetric unit and biological assembly (<b>" + me.icn3d.asuCnt + "</b> asymmetric unit).</div>";

        $("#" + me.pre + "dl_annotations_tabs").append(html);

        me.bAssemblyNote = true;
    }

    if (me.bAnnoShown === undefined || !me.bAnnoShown) {
        //me.setLogCmd("view annotations", true);

        //if(me.giSeq !== undefined) { // clear the previous data
        //    $("#" + me.pre + "dl_annotations").html('');
        //}

        var chainArray = Object.keys(me.icn3d.chains);
        if (me.giSeq === undefined) me.giSeq = {};
        if (me.currClin === undefined) me.currClin = {};
        if (me.resi2disease_nonempty === undefined) me.resi2disease_nonempty = {};
        if (me.baseResi === undefined) me.baseResi = {};
        if (me.matchedPos === undefined) me.matchedPos = {};

        //me.customTracks = {};

        var dialogWidth = $("#" + me.pre + "dl_selectannotations").dialog("option", "width");
        me.seqAnnWidth = dialogWidth - 120 - 30 * 2 - 50; // title: 120px, start and end resi: 30px, extra space on the left and right: 50px

        me.maxAnnoLength = 1;
        for (var chainid in me.icn3d.chainsSeq) {
            if (me.icn3d.chainsSeq[chainid].length > me.maxAnnoLength) {
                me.maxAnnoLength = me.icn3d.chainsSeq[chainid].length;
            }
        }

        var nucleotide_chainid = {}, chemical_chainid = {}, chemical_set = {};
        me.protein_chainid = {};

        for (var i = 0, il = chainArray.length; i < il; ++i) {
            var pos = parseInt(chainArray[i].indexOf('_'));
            if (pos > 4) continue; // NMR structures with structure id such as 2K042,2K043, ...

            var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chainArray[i]]);
            // only single letter chain has accession such as 1P9M_A
            var chainLetter = chainArray[i].substr(chainArray[i].indexOf('_') + 1);

            var chainidBase;
            if (chainLetter.indexOf('_') !== -1) { // NCBI modified chainid, e.g., A_1
                chainLetter = chainLetter.substr(0, chainLetter.indexOf('_'));

                chainidBase = chainArray[i].substr(0, chainArray[i].indexOf('_')) + '_' + chainLetter;
            }
            else {
                chainidBase = chainArray[i];
            }

            //if(me.cfg.mmdbid !== undefined) { // protein and chemicals/ions are in different chains
            if (me.icn3d.proteins.hasOwnProperty(atom.serial)) {
                me.protein_chainid[chainArray[i]] = chainidBase;
            }
            else if (me.icn3d.nucleotides.hasOwnProperty(atom.serial)) {
                nucleotide_chainid[chainArray[i]] = chainidBase;
            }
            else {
                if (me.icn3d.chainsSeq[chainArray[i]].length > 1) {
                    chemical_chainid[chainArray[i]] = chainidBase;
                }
                else {
                    var name = me.icn3d.chainsSeq[chainArray[i]][0].name;
                    var resid = chainArray[i] + '_' + me.icn3d.chainsSeq[chainArray[i]][0].resi;

                    if (chemical_set[name] === undefined) chemical_set[name] = [];
                    chemical_set[name].push(resid);
                }
            }
            //}

            // protein and nucleotide chain may have chemicals/ions attached at the end
            if ((me.cfg.pdbid !== undefined || me.cfg.mmcifid !== undefined || me.cfg.mmtfid !== undefined)
                && (me.icn3d.proteins.hasOwnProperty(atom.serial) || me.icn3d.nucleotides.hasOwnProperty(atom.serial))) {
                for (var r = 0, rl = me.icn3d.chainsSeq[chainArray[i]].length; r < rl; ++r) {
                    var resObj = me.icn3d.chainsSeq[chainArray[i]][r];
                    if (resObj.name !== '' && resObj.name !== '-' && resObj.name == resObj.name.toUpperCase()) {
                        var resid = chainArray[i] + '_' + resObj.resi;
                        var atom = me.icn3d.getFirstAtomObj(me.icn3d.residues[resid]);

                        if (me.icn3d.proteins.hasOwnProperty(atom.serial) || me.icn3d.nucleotides.hasOwnProperty(atom.serial)) {
                            continue;
                        }
                        else {
                            var name = resObj.name.trim();

                            if (chemical_set[name] === undefined) chemical_set[name] = [];
                            chemical_set[name].push(resid);
                        }
                    } // if(resObj.name !== ''
                } // for(var r = 0
            } // if(me.cfg.mmdbid
        } // for(var i = 0

        var i = 0;
        for (var chain in me.protein_chainid) {
            me.getAnnotationData(chain, me.protein_chainid[chain], i);
            ++i;
        }

        i = 0;
        for (var chain in nucleotide_chainid) {
            me.getSequenceData(chain, nucleotide_chainid[chain], 'nucleotide', i);
            ++i;
        }

        me.interactChainChainbase = me.icn3d.unionHash(me.protein_chainid, nucleotide_chainid);

        i = 0;
        for (var chain in chemical_chainid) {
            me.getSequenceData(chain, chemical_chainid[chain], 'chemical', i);
            ++i;
        }

        me.interactChainChainbase = me.icn3d.unionHash(me.interactChainChainbase, chemical_chainid);

        for (var name in chemical_set) {
            me.getCombinedSequenceData(name, chemical_set[name], i);
            ++i;
        }

        me.enableHlSeq();

        setTimeout(function () {
            //me.setAnnoViewAndDisplay('overview');
            me.hideAllAnno();
            me.clickCdd();
        }, 0);
    }

    me.bAnnoShown = true;
};

iCn3DUI.prototype.enableHlSeq = function () {
    var me = this;
    if (!me.isMobile()) {
        me.selectSequenceNonMobile();
    }
    else {
        me.selectSequenceMobile();
        me.selectChainMobile();
    }

    // highlight seq after the ajax calls
    me.updateHlSeq();
};

// by default, showSeq and showCddSite are called at showAnnotations
// the following will be called only when the annotation is selected: showSnpClinvar, showDomain, showInteraction
// showSnpClinvar and showDomain will loop through me.protein_chainid
// showInteraction will loop through me.interactChainChainbase
iCn3DUI.prototype.updateSnpClinvar = function () {
    var me = this;
    if (me.bSnpClinvarShown === undefined || !me.bSnpClinvarShown) {
        for (var chainid in me.protein_chainid) {
            var chainidBase = me.protein_chainid[chainid];
            me.showSnpClinvar(chainid, chainidBase);
        }
    }

    me.bSnpClinvarShown = true;
};

iCn3DUI.prototype.updateDomain = function () {
    var me = this;
    if (me.bDomainShown === undefined || !me.bDomainShown) {
        for (var chainid in me.protein_chainid) {
            var chainidBase = me.protein_chainid[chainid];
            me.showDomain(chainid, chainidBase);
        }
    }

    me.bDomainShown = true;
};

iCn3DUI.prototype.updateInteraction = function () {
    var me = this;
    if (me.bInteractionShown === undefined || !me.bInteractionShown) {
        for (var chainid in me.interactChainChainbase) {
            var chainidBase = me.interactChainChainbase[chainid];
            me.showInteraction(chainid, chainidBase);
        }
    }

    me.bInteractionShown = true;
};

iCn3DUI.prototype.getAnDiv = function (chnid, anno) {
    var me = this;
    var message = 'Loading ' + anno + '...';
    if (anno == 'custom') {
        message = ''
    }
    else if (anno == 'domain') {
        message = 'Loading 3D ' + anno + '...';
    }

    return "<div id='" + me.pre + anno + "_" + chnid + "'><div id='" + me.pre + "tt_" + anno + "_" + chnid + "' class='icn3d-fixed-pos' style='display:none!important'></div><div id='" + me.pre + "dt_" + anno + "_" + chnid + "' style='display:none'>" + message + "</div><div id='" + me.pre + "ov_" + anno + "_" + chnid + "'>" + message + "</div></div>";
};

iCn3DUI.prototype.getAnnotationData = function (chnid, chnidBase, index) {
    var me = this;
    var buttonStyle = me.isMobile() ? 'none' : 'button';

    var fullProteinName = me.getProteinName(chnid);
    var proteinName = fullProteinName;
    //if(proteinName.length > 40) proteinName = proteinName.substr(0, 40) + "...";

    var categoryStr = (index == 0) ? "<span class='icn3d-annoLargeTitle'><b>Proteins</b>: </span><br><br>" : "";

    $("#" + me.pre + "dl_annotations").append("<div id='" + me.pre + "anno_" + chnid + "' class='icn3d-annotation'>" + categoryStr + "<span style='font-weight:bold;'>Annotations of " + chnid + "</span>: <a class='icn3d-blue' href='https://www.ncbi.nlm.nih.gov/protein?term=" + chnid + "' target='_blank' title='" + fullProteinName + "'>" + proteinName + "</a> <div class='addtrack' chainid='" + chnid + "' style='display:inline-block; font-size:11px; font-weight:bold; width:60px!important;'><button class='link' style='-webkit-appearance:" + buttonStyle + "; height:18px; width:60px;'><span style='white-space:nowrap; margin-left:-3px;' title='Add a custom track'>Add Track</span></button></div></div>");

    // dt: detailed view, hide by default; ov: overview, show by default
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'giseq'));
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'cdd'));
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'clinvar'));
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'snp'));
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'domain'));
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'site'));
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'interaction'));
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'custom'));

    $("#" + me.pre + "anno_" + chnid).append("<br><hr><br>");

    me.setToolTip();

    // show the sequence and 3D structure
    var url = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=protein&retmode=json&rettype=fasta&id=" + chnidBase;
    $.ajax({
        url: url,
        dataType: 'text',
        cache: true,
        tryCount: 0,
        retryLimit: 1,
        success: function (data) {
            var strArray = data.split('\n');
            strArray.shift();
            var allSeq = strArray.join('');

            me.giSeq[chnid] = allSeq.split('');

            // the first 10 residues from sequences with structure
            var startResStr = '';
            for (var i = 0; i < 10 && i < me.icn3d.chainsSeq[chnid].length; ++i) {
                startResStr += me.icn3d.chainsSeq[chnid][i].name.substr(0, 1);
            }

            var pos = allSeq.toLowerCase().indexOf(startResStr.toLowerCase());
            if (pos == -1) {
                console.log("The gi sequence didn't match the protein sequence. The start of 3D protein sequence: " + startResStr + ". The gi sequence: " + allSeq.substr(0, 10) + ".");

                me.setAlternativeSeq(chnid, chnidBase);
                //return false;
            }
            else {
                me.matchedPos[chnid] = pos;
                me.baseResi[chnid] = me.icn3d.chainsSeq[chnid][0].resi - me.matchedPos[chnid] - 1;

                me.getAnnotationDataSub(chnid, chnidBase);
            }

            me.enableHlSeq();
        },
        error: function (xhr, textStatus, errorThrown) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }

            console.log("No data were found for the protein " + chnid + "...");

            me.enableHlSeq();

            me.setAlternativeSeq(chnid, chnidBase);

            return;
        }
    });
};

iCn3DUI.prototype.setAlternativeSeq = function (chnid, chnidBase) {
    var me = this;
    //if(me.icn3d.chainsSeq[chnid] !== undefined) {
    var resArray = me.icn3d.chainsSeq[chnid];

    me.giSeq[chnid] = [];

    for (var i = 0, il = resArray.length; i < il; ++i) {
        var res = resArray[i].name;
        me.giSeq[chnid][i] = res;
    }

    me.matchedPos[chnid] = 0;
    me.baseResi[chnid] = me.icn3d.chainsSeq[chnid][0].resi - me.matchedPos[chnid] - 1;

    me.getAnnotationDataSub(chnid, chnidBase);
};

iCn3DUI.prototype.getAnnotationDataSub = function (chnid, chnidBase) {
    var me = this;
    me.showSeq(chnid, chnidBase);
    //        me.showSnpClinvar(chnid, chnidBase);
    me.showCddSite(chnid, chnidBase);
    //        me.showDomain(chnid, chnidBase);
    //        me.showInteraction(chnid, chnidBase);
    //        me.navClinVar(chnid, chnidBase);
};

iCn3DUI.prototype.getProteinName = function (chnid) {
    var me = this;
    var fullProteinName = '';
    if (me.cfg.mmdbid !== undefined && me.mmdb_data !== undefined) {
        var moleculeInfor = me.mmdb_data.moleculeInfor;
        var chain = chnid.substr(chnid.indexOf('_') + 1);
        for (var i in moleculeInfor) {
            if (moleculeInfor[i].chain == chain) {
                fullProteinName = moleculeInfor[i].name.replace(/\'/g, '&prime;');
                proteinName = fullProteinName;
                //if(proteinName.length > 40) proteinName = proteinName.substr(0, 40) + "...";
                break;
            }
        }
    }
    else if (me.cfg.align !== undefined && me.chainid2title !== undefined) {
        if (me.chainid2title[chnid] !== undefined) {
            fullProteinName = me.chainid2title[chnid];
        }
    }

    return fullProteinName;
};

iCn3DUI.prototype.getSequenceData = function (chnid, chnidBase, type, index) {
    var me = this;
    var fullProteinName = me.getProteinName(chnid);
    var proteinName = fullProteinName;
    if (proteinName.length > 40) proteinName = proteinName.substr(0, 40) + "...";

    var categoryStr = "";

    if (index == 0) {
        if (type == 'protein') {
            categoryStr = "<span class='icn3d-annoLargeTitle'><b>Proteins</b>: </span><br><br>";
        }
        else if (type == 'nucleotide') {
            categoryStr = "<span class='icn3d-annoLargeTitle'><b>Nucleotides</b>: </span><br><br>";
        }
        else if (type == 'chemical') {
            categoryStr = "<span class='icn3d-annoLargeTitle'><b>Chemicals/Ions</b>: </span><br><br>";
        }
    }

    //    $("#" + me.pre + "dl_annotations").append("<div id='" + me.pre + "anno_" + chnid + "' class='icn3d-annotation'><span style='font-weight:bold;' title='Sequences of " + chnid + "'>Sequences of " + chnid + proteinName + "</span> <div class='addtrack' chainid='" + chnid + "' style='display:inline-block; font-size:11px; font-weight:bold; width:60px!important;'><button class='link' style='-webkit-appearance:" + buttonStyle + "; height:18px; width:60px;'><span style='white-space:nowrap; margin-left:-3px;' title='Add a custom track'>Add Track</span></button></div></div>");
    $("#" + me.pre + "dl_annotations").append("<div id='" + me.pre + "anno_" + chnid + "' class='icn3d-annotation'>" + categoryStr + "<b>" + chnid + "</b>: " + "<span title='" + fullProteinName + "'>" + proteinName + "</span> </div>");

    // dt: detailed view, hide by default; ov: overview, show by default
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'giseq'));
    //$("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'custom'));
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'interaction'));

    $("#" + me.pre + "anno_" + chnid).append("<br><hr><br>");

    // show the sequence and 3D structure
    me.giSeq[chnid] = [];
    for (var i = 0; i < me.icn3d.chainsSeq[chnid].length; ++i) {
        var res = me.icn3d.chainsSeq[chnid][i].name;
        //me.giSeq[chnid][i] = (res.length > 1) ? res.substr(0, 1) : res;
        me.giSeq[chnid][i] = res;
    }

    me.matchedPos[chnid] = 0;
    me.baseResi[chnid] = me.icn3d.chainsSeq[chnid][0].resi - me.matchedPos[chnid] - 1;

    me.showSeq(chnid, chnidBase, type);

    //me.showInteraction(chnid, chnidBase);
};

iCn3DUI.prototype.getCombinedSequenceData = function (name, residArray, index) {
    var me = this;

    var categoryStr = (index == 0) ? "<span class='icn3d-annoLargeTitle'><b>Chemicals/Ions</b>: </span><br><br>" : "";

    var chemName;
    var pos = residArray[0].lastIndexOf('_');
    var firstChainid = residArray[0].substr(0, pos);

    var sid = (me.cfg.mmdbid !== undefined) ? me.chainid2sid[firstChainid] : undefined;
    if (sid !== undefined) {
        chemName = "<b><a class='icn3d-blue' href='https://pubchem.ncbi.nlm.nih.gov/substance/" + sid + "#section=2D-Structure' target='_blank'>" + name + " <img src='https://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?sid=" + sid + "'></a></b>";
    }
    else {
        chemName = "<b>" + name + "</b>";
    }

    $("#" + me.pre + "dl_annotations").append("<div id='" + me.pre + "anno_" + name + "' class='icn3d-annotation'>" + categoryStr + chemName + "</div>");

    // dt: detailed view, hide by default; ov: overview, show by default
    $("#" + me.pre + "anno_" + name).append("<div id='" + me.pre + "giseq_" + name + "'><div id='" + me.pre + "dt_giseq_" + name + "' style='display:none'></div><div id='" + me.pre + "ov_giseq_" + name + "'></div></div>");

    $("#" + me.pre + "anno_" + name).append("<br><hr><br>");


    // sequence, detailed view
    var htmlTmp = '<div id="' + me.pre + 'giseq_sequence" class="icn3d-dl_sequence">';

    var chainType = 'Chem.', chainTypeFull = 'Chemical';

    htmlTmp += '<div class="icn3d-seqTitle" anno="sequence"><span style="white-space:nowrap;" title="' + chainTypeFull + ' ' + name + '">' + chainType + ' ' + name + '</span></div>';

    htmlTmp += '<span class="icn3d-residueNum" style="width:60px!important;" title="starting protein sequence number">Count: ' + residArray.length + '</span>';
    htmlTmp += '<span class="icn3d-seqLine">';

    // sequence, overview
    var html = htmlTmp;
    var html2 = htmlTmp;

    for (var i = 0, il = residArray.length; i < il; ++i) {
        var cFull = name;

        var c = cFull;
        if (cFull.length > 3) {
            c = cFull.substr(0, 3);
        }

        if (i < residArray.length - 1) c = c + ',';

        var resid = residArray[i];
        var resi = resid.substr(resid.lastIndexOf('_') + 1);

        html += '<span id="giseq_' + me.pre + resid + '" title="' + cFull + resi + '" class="icn3d-residue icn3d-chemical">' + c + '</span>';
    }

    var color = me.GREY8;

    //html2 += '<div class="icn3d-seqTitle" style="display:inline-block; color:white; font-weight:bold; background-color:' + color + '; width:' + parseInt(me.seqAnnWidth * residArray.length / me.maxAnnoLength) + 'px;">' + name + '</div>';
    var width = parseInt(me.seqAnnWidth * residArray.length / me.maxAnnoLength);
    if (width < 1) width = 1;
    html2 += '<div class="icn3d-seqTitle" style="display:inline-block; color:white; font-weight:bold; background-color:' + color + '; width:' + width + 'px;">&nbsp;</div>';

    //htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">' + residArray.length + '</span>';
    //htmlTmp += '</span>';
    htmlTmp = '</span>';
    htmlTmp += '<br>';

    htmlTmp += '</div>';

    html += htmlTmp;
    html2 += htmlTmp;

    $("#" + me.pre + 'dt_giseq_' + name).html(html);
    $("#" + me.pre + 'ov_giseq_' + name).html(html2);
};

iCn3DUI.prototype.showSeq = function (chnid, chnidBase, type) {
    var me = this;
    var giSeq = me.giSeq[chnid];

    var divLength = me.RESIDUE_WIDTH * me.giSeq[chnid].length + 200;
    var seqLength = me.giSeq[chnid].length

    if (seqLength > me.maxAnnoLength) {
        me.maxAnnoLength = seqLength;
    }

    $("#" + me.pre + "giseq_" + chnid).width(divLength);
    $("#" + me.pre + "interaction_" + chnid).width(divLength);
    if ($("#" + me.pre + "custom_" + chnid).length) $("#" + me.pre + "custom_" + chnid).width(divLength);
    if ($("#" + me.pre + "clinvar_" + chnid).length) $("#" + me.pre + "clinvar_" + chnid).width(divLength);
    if ($("#" + me.pre + "snp_" + chnid).length) $("#" + me.pre + "snp_" + chnid).width(divLength);
    if ($("#" + me.pre + "cddsite_" + chnid).length) $("#" + me.pre + "cddsite_" + chnid).width(divLength);
    if ($("#" + me.pre + "domain_" + chnid).length) $("#" + me.pre + "domain_" + chnid).width(divLength);

    // gi html
    var html = '', html2 = '', html3 = '', htmlTmp;

    html += '<div class="icn3d-dl_sequence">';
    html3 += '<div class="icn3d-dl_sequence">';

    // html to display protein positions (10, 20, etc)
    //if(Object.keys(me.icn3d.chains[chnid]).length > 10) {
    if (me.giSeq[chnid].length > 10) {
        htmlTmp = '<div class="icn3d-residueLine" style="white-space:nowrap;">';
        var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chnid]);

        //if(me.baseResi[chnid] != 0 && (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined)) {
        if ((me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined) && atom.resi_ori !== undefined && atom.resi_ori != atom.resi) {
            htmlTmp += '<div class="icn3d-annoTitle" anno="0" title="NCBI Residue Numbers">NCBI Residue Numbers</div>';
        }
        else {
            htmlTmp += '<div class="icn3d-annoTitle" anno="0"></div>';
        }

        htmlTmp += '<span class="icn3d-residueNum"></span>';

        html3 += htmlTmp + '<br>';

        html += htmlTmp + '<span class="icn3d-seqLine">';

        var helixCnt = 0, sheetCnt = 0;

        for (var i = 0, il = giSeq.length; i < il; ++i) {
            var currResi = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

            html += '<span>'

            if (currResi % 10 === 0) {
                html += currResi + ' ';
            }

            // name of secondary structures
            var residueid = chnid + '_' + currResi;

            if (me.icn3d.residues.hasOwnProperty(residueid)) {
                var atom = me.icn3d.getFirstAtomObj(me.icn3d.residues[residueid]);

                if (me.icn3d.secondaries[residueid] == 'H' && atom.ssbegin) {
                    ++helixCnt;
                    html += '<span class="icn3d-helix-color">H' + helixCnt + '</span>';
                }
                else if (me.icn3d.secondaries[residueid] == 'E' && atom.ssbegin) {
                    ++sheetCnt;
                    html += '<span class="icn3d-sheet-color">S' + sheetCnt + '</span>';
                }
            }

            html += '</span>'
        }
        html += '<span class="icn3d-residueNum"></span>';
        html += '</span>';
        html += '<br>';
        html += '</div>';

        html3 += '</div>';
    }

    // html to display secondary structures
    htmlTmp = '<div class="icn3d-residueLine" style="white-space:nowrap;">';
    htmlTmp += '<div class="icn3d-annoTitle" anno="0"></div>';
    htmlTmp += '<span class="icn3d-residueNum"></span>';

    html3 += htmlTmp + '<br>';
    html += htmlTmp + '<span class="icn3d-seqLine">';

    for (var i = 0, il = giSeq.length; i < il; ++i) {
        //      var resi = (me.baseResi[chnid] + i+1).toString();
        //      var resi = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
        var resi = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

        var residueid = chnid + '_' + resi;

        if (me.icn3d.residues.hasOwnProperty(residueid)) {
            if (me.icn3d.secondaries[residueid] == 'H') {
                if (i % 2 == 0) {
                    html += '<span class="icn3d-helix">';
                }
                else {
                    html += '<span class="icn3d-helix2">';
                }

                html += '&nbsp;</span>';
            }
            else if (me.icn3d.secondaries[residueid] == 'E') {
                var atom = me.icn3d.getFirstAtomObj(me.icn3d.residues[residueid]);

                if (atom.ssend) {
                    html += '<span class="icn3d-sheet2">';
                }
                else {
                    html += '<span class="icn3d-sheet">';
                }

                html += '&nbsp;</span>';
            }
            else if (me.icn3d.secondaries[residueid] == 'c') {
                html += '<span class="icn3d-coil">&nbsp;</span>';
            }
            else if (me.icn3d.secondaries[residueid] == 'o') {
                html += '<span class="icn3d-other">&nbsp;</span>';
            }
        }
        else {
            html += '<span>-</span>'; //'<span>-</span>';
        }
    }
    html += '<span class="icn3d-residueNum"></span>';
    html += '</span>';
    html += '<br>';
    html += '</div>';

    html += '</div>'; // corresponds to above: html += '<div class="icn3d-dl_sequence">';

    html3 += '</div></div>';

    // sequence, detailed view
    htmlTmp = '<div id="' + me.pre + 'giseq_sequence" class="icn3d-dl_sequence">';

    var chainType = 'Protein', chainTypeFull = 'Protein';
    if (type !== undefined) {
        if (type == 'nucleotide') {
            chainType = 'Nucl.';
            chainTypeFull = 'Nucleotide';
        }
        else if (type == 'chemical') {
            chainType = 'Chem.';
            chainTypeFull = 'Chemical';
        }
    }

    htmlTmp += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" gi="' + chnid + '" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;" title="' + chainTypeFull + ' ' + chnid + '">' + chainType + ' ' + chnid + '</span></div>';

    htmlTmp += '<span class="icn3d-residueNum" title="starting protein sequence number">' + (me.baseResi[chnid] + 1).toString() + '</span>';

    html3 += htmlTmp + '<br>';

    var htmlTmp2 = '<span class="icn3d-seqLine">';

    // sequence, overview
    html += htmlTmp + htmlTmp2;
    html2 += htmlTmp + htmlTmp2;

    for (var i = 0, il = giSeq.length; i < il; ++i) {
        var cFull = giSeq[i];

        var c = cFull;
        if (cFull.length > 1) {
            c = cFull[0] + '..';
        }

        //      var pos = (me.baseResi[chnid] + i+1).toString();
        //      var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
        var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

        if (!me.icn3d.residues.hasOwnProperty(chnid + '_' + pos)) {
            c = c.toLowerCase();
            html += '<span title="' + cFull + pos + '" class="icn3d-residue">' + c + '</span>';
        }
        else {
            var atom = me.icn3d.getFirstAtomObj(me.icn3d.residues[chnid + '_' + pos]);
            var color = atom.color.getHexString();

            html += '<span id="giseq_' + me.pre + chnid + '_' + pos + '" title="' + cFull + pos + '" class="icn3d-residue" style="color:#' + color + '">' + c + '</span>';
        }
    }

    var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chnid]);
    var color = atom.color.getHexString();

    var width = parseInt(me.seqAnnWidth * giSeq.length / me.maxAnnoLength);
    if (width < 1) width = 1;

    html2 += '<div id="giseq_summary_' + me.pre + chnid + '" class="icn3d-seqTitle icn3d-link" gi chain="' + chnid + '" style="display:inline-block; color:white; font-weight:bold; background-color:#' + color + '; width:' + width + 'px;">' + chnid + '</div>';

    htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">' + pos + '</span>';
    htmlTmp += '</span>';
    htmlTmp += '<br>';

    htmlTmp += '</div>';

    html += htmlTmp;
    html2 += htmlTmp;
    html3 += '</div>';

    //if(Object.keys(me.icn3d.chains[chnid]).length > 10) {
    if (me.giSeq[chnid].length > 10) {
        var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chnid]);
        //if(me.baseResi[chnid] != 0 && (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined)) {
        if ((me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined) && atom.resi_ori !== undefined && atom.resi_ori != atom.resi) {
            htmlTmp = '<div class="icn3d-dl_sequence">';
            htmlTmp += '<div class="icn3d-residueLine" style="white-space:nowrap;">';
            htmlTmp += '<div class="icn3d-annoTitle" anno="0" title="PDB Residue Numbers">PDB Residue Numbers</div>';
            htmlTmp += '<span class="icn3d-residueNum"></span>';

            html3 += htmlTmp + '<br>';

            html += htmlTmp + '<span class="icn3d-seqLine">';

            for (var i = 0, il = giSeq.length; i < il; ++i) {
                if (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) {
                    var currResi = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi;

                    var residueid = chnid + '_' + currResi;

                    if (!me.icn3d.residues.hasOwnProperty(residueid)) {
                        html += '<span></span>';
                    }
                    else {
                        var atom = me.icn3d.getFirstAtomObj(me.icn3d.residues[residueid]);

                        var resi_ori = atom.resi_ori;

                        html += '<span>';

                        if (resi_ori % 10 === 0) {
                            html += resi_ori + ' ';
                        }

                        html += '</span>';
                    }
                }
                else {
                    html += '<span></span>';
                }
            }
            html += '<span class="icn3d-residueNum"></span>';
            html += '</span>';
            html += '<br>';
            html += '</div>';

            html += '</div>';

            html3 += '</div></div>';
        }
    }

    $("#" + me.pre + 'dt_giseq_' + chnid).html(html);
    $("#" + me.pre + 'ov_giseq_' + chnid).html(html2);
    $("#" + me.pre + 'tt_giseq_' + chnid).html(html3);
};

iCn3DUI.prototype.navClinVar = function (chnid) {
    var me = this;
    me.currClin[chnid] = - 1;

    $(document).on('click', "#" + me.pre + chnid + "_prevclin", function (e) {
        e.stopImmediatePropagation();
        //e.preventDefault();
        var maxLen = (me.resi2disease_nonempty[chnid] !== undefined) ? Object.keys(me.resi2disease_nonempty[chnid]).length : 0;

        --me.currClin[chnid];
        if (me.currClin[chnid] < 0) me.currClin[chnid] = maxLen - 1; // 0;

        me.showClinVarLabelOn3D(chnid);
    });

    $(document).on('click', "#" + me.pre + chnid + "_nextclin", function (e) {
        e.stopImmediatePropagation();
        //e.preventDefault();
        var maxLen = (me.resi2disease_nonempty[chnid] !== undefined) ? Object.keys(me.resi2disease_nonempty[chnid]).length : 0;

        ++me.currClin[chnid];
        if (me.currClin[chnid] > maxLen - 1) me.currClin[chnid] = 0; // me.resi2disease_nonempty[chnid].length - 1;

        me.showClinVarLabelOn3D(chnid);
    });
};

iCn3DUI.prototype.showClinVarLabelOn3D = function (chnid) {
    var me = this;
    var resiArray = Object.keys(me.resi2disease_nonempty[chnid]);

    var chainid, residueid;

    chainid = chnid;

    residueid = chainid + '_' + resiArray[me.currClin[chnid]];

    var label = '';

    var diseaseArray = me.resi2disease_nonempty[chnid][resiArray[me.currClin[chnid]]];

    for (var k = 0, kl = diseaseArray.length; k < kl; ++k) {
        if (diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
            label = diseaseArray[k];
            break;
        }
    }

    var position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.residues[residueid]));
    //position.center.add(new THREE.Vector3(3.0, 3.0, 3.0)); // shift a little bit

    var maxlen = 30;
    if (label.length > maxlen) label = label.substr(0, maxlen) + '...';

    me.removeSelection();

    if (me.icn3d.labels == undefined) me.icn3d.labels = {};
    me.icn3d.labels['clinvar'] = [];

    //var size = parseInt(me.icn3d.LABELSIZE * 10 / label.length);
    var size = me.icn3d.LABELSIZE;
    var color = "#FFFF00";
    me.addLabel(label, position.center.x + 1, position.center.y + 1, position.center.z + 1, size, color, undefined, 'clinvar');

    me.icn3d.hAtoms = {};

    for (var j in me.icn3d.residues[residueid]) {
        me.icn3d.hAtoms[j] = 1;
    }

    me.icn3d.addResiudeLabels(me.icn3d.hAtoms);

    $("#clinvar_" + me.pre + residueid).addClass('icn3d-highlightSeq');

    if (!$("#" + me.pre + "modeswitch")[0].checked) {
        me.setMode('selection');
    }

    me.icn3d.draw();
};

iCn3DUI.prototype.getSnpLine = function (line, totalLineNum, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, bStartEndRes, chnid, bOverview, bClinvar, bTitleOnly) {
    var me = this;

    var html = '';

    var altName = bClinvar ? 'clinvar' : 'snp';

    if (bStartEndRes) {
        var title1 = 'ClinVar', title2 = 'SNP';

        if (bClinvar) {
            html += '<div class="icn3d-seqTitle icn3d-link icn3d-blue icn3d-clinvar-path" clinvar="clinvar" posarray="' + posClinArray + '" shorttitle="' + title1 + '" setname="' + chnid + '_' + title1 + '" anno="sequence" chain="' + chnid + '" title="' + title1 + '">' + title1 + '</div>';
        }
        else {
            html += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" clinvar="clinvar" posarray="' + posarray + '" shorttitle="' + title2 + '" setname="' + chnid + '_' + title2 + '" anno="sequence" chain="' + chnid + '" title="' + title2 + '">' + title2 + '</div>';
        }
    }
    else if (line == 2 && bClinvar) {
        var buttonStyle = me.isMobile() ? 'none' : 'button';
        html += '<div id="' + me.pre + chnid + '_prevclin" style="display:inline-block; font-size:11px; font-weight:bold; width:60px!important;"><button class="link" style="-webkit-appearance:' + buttonStyle + '; height:18px; width:55px;"><span style="white-space:nowrap; margin-left:-40px;" title="Show the previous ClinVar on structure">&lt; ClinVar</span></button></div>';
        html += '<div id="' + me.pre + chnid + '_nextclin" style="display:inline-block; font-size:11px; font-weight:bold; width:60px!important;"><button class="link" style="-webkit-appearance:' + buttonStyle + '; height:18px; width:55px;"><span style="white-space:nowrap; margin-left:-40px;" title="Show the next ClinVar on structure">ClinVar &gt;</span></button></div>';
    }
    else {
        html += '<div class="icn3d-seqTitle"></div>';
    }

    var pre = altName;

    var snpCnt = 0, clinvarCnt = 0;

    var snpTypeHash = {}, currSnpTypeHash = {};

    for (var i = 1, il = me.giSeq[chnid].length; i <= il; ++i) {
        if (resi2index[i] !== undefined) {
            ++snpCnt;

            var snpType = '', allDiseaseTitle = '';
            for (var j = 0, jl = resi2snp[i].length; j < jl; ++j) {
                var diseaseArray = resi2disease[i][j].split('; ');
                var sigArray = resi2sig[i][j].split('; ');

                var diseaseTitle = '';
                for (var k = 0, kl = diseaseArray.length; k < kl; ++k) {
                    if (diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                        diseaseTitle += diseaseArray[k] + ' (' + sigArray[k] + '); ';
                    }
                }

                /*
                                if(diseaseTitle != '') {
                                    snpTypeHash[i] = 'icn3d-clinvar';
                                }
                */

                if (diseaseTitle != '') {
                    snpTypeHash[i] = 'icn3d-clinvar';

                    if (j == line - 2) { // just check the current line, "line = 2" means the first SNP
                        currSnpTypeHash[i] = 'icn3d-clinvar';

                        if (diseaseTitle.indexOf('Pathogenic') != -1) {
                            currSnpTypeHash[i] = 'icn3d-clinvar-path';
                        }
                    }
                }

                allDiseaseTitle += diseaseTitle + ' | ';
            }

            if (allDiseaseTitle.indexOf('Pathogenic') != -1) {
                snpTypeHash[i] = 'icn3d-clinvar-path';
            }

            if (snpTypeHash[i] == 'icn3d-clinvar' || snpTypeHash[i] == 'icn3d-clinvar-path') {
                ++clinvarCnt;
            }

            /*
                        if(allDiseaseTitle != '') {
                            ++clinvarCnt;
                        }
            */
        }
    }

    if (snpCnt == 0) {
        $("#" + me.pre + 'dt_clinvar_' + chnid).html('');
        $("#" + me.pre + 'ov_clinvar_' + chnid).html('');
        $("#" + me.pre + 'tt_clinvar_' + chnid).html('');

        $("#" + me.pre + 'dt_snp_' + chnid).html('');
        $("#" + me.pre + 'ov_snp_' + chnid).html('');
        $("#" + me.pre + 'tt_snp_' + chnid).html('');

        return '';
    }

    if (clinvarCnt == 0) {
        $("#" + me.pre + 'dt_clinvar_' + chnid).html('');
        $("#" + me.pre + 'ov_clinvar_' + chnid).html('');
        $("#" + me.pre + 'tt_clinvar_' + chnid).html('');

        return '';
    }

    var cnt = bClinvar ? clinvarCnt : snpCnt;

    if (clinvarCnt == 0) {
        me.bShowClinvar = false;
    }
    else {
        me.bShowClinvar = true;
    }

    //var start = bStartEndRes ? me.baseResi[chnid] + 1 : '';
    if (line == 1) {
        html += '<span class="icn3d-residueNum" title="residue count">' + cnt + ' Res</span>';
    }
    else {
        html += '<span class="icn3d-residueNum"></span>';
    }

    if (bTitleOnly !== undefined && bTitleOnly) {
        return html + '<br>';
    }

    html += '<span class="icn3d-seqLine">';
    var diseaseStr = '';

    var prevEmptyWidth = 0;
    var prevLineWidth = 0;
    var widthPerRes = 1;

    for (var i = 1, il = me.giSeq[chnid].length; i <= il; ++i) {
        if (bOverview) {
            if (resi2index[i] !== undefined) {
                // get the mouse over text
                var cFull = me.giSeq[chnid][i - 1];

                var c = cFull;
                if (cFull.length > 1) {
                    c = cFull[0] + '..';
                }

                var pos = (i >= me.matchedPos[chnid] && i - 1 - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - 1 - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i - 1;

                var snpTitle = pos + c + '>';
                var allDiseaseTitle = '';
                for (var j = 0, jl = resi2snp[i].length; j < jl; ++j) {
                    snpTitle += resi2snp[i][j];

                    var diseaseArray = resi2disease[i][j].split('; ');
                    var sigArray = resi2sig[i][j].split('; ');

                    var diseaseTitle = '';
                    for (var k = 0, kl = diseaseArray.length; k < kl; ++k) {
                        if (diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                            diseaseTitle += diseaseArray[k] + ' (' + sigArray[k] + '); ';
                        }
                    }

                    //if(diseaseTitle != '') {
                    //    snpType = 'icn3d-clinvar';
                    //}

                    allDiseaseTitle += diseaseTitle + ' | ';
                }

                //if(allDiseaseTitle.indexOf('Pathogenic') != -1) {
                //    snpType = 'icn3d-clinvar-path';
                //}

                var emptyWidth = parseInt(me.seqAnnWidth * (i - 1) / me.maxAnnoLength - prevEmptyWidth - prevLineWidth);
                if (emptyWidth < 0) emptyWidth = 0;



                if (bClinvar) {
                    if (snpTypeHash[i] == 'icn3d-clinvar' || snpTypeHash[i] == 'icn3d-clinvar-path') {
                        if (emptyWidth > 0) html += '<div style="display:inline-block; width:' + emptyWidth + 'px;"></div>';

                        html += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + snpTitle + '">&nbsp;</div>';

                        prevEmptyWidth += emptyWidth;
                        prevLineWidth += widthPerRes;
                    }
                }
                else {
                    if (emptyWidth > 0) html += '<div style="display:inline-block; width:' + emptyWidth + 'px;"></div>';

                    html += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + snpTitle + '">&nbsp;</div>';

                    prevEmptyWidth += emptyWidth;
                    prevLineWidth += widthPerRes;
                }
            }
        }
        else { // detailed view
            if (resi2index[i] !== undefined) {
                if (!bClinvar && line == 1) {
                    html += '<span>&dArr;</span>'; // or down triangle &#9660;
                }
                else {
                    var cFull = me.giSeq[chnid][i - 1];

                    var c = cFull;
                    if (cFull.length > 1) {
                        c = cFull[0] + '..';
                    }

                    var pos = (i >= me.matchedPos[chnid] && i - 1 - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - 1 - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i - 1;

                    var snpStr = "", snpTitle = "<div class='snptip'>"

                    //var snpType = '';

                    var jl = resi2snp[i].length;

                    var start = 0, end = 0;

                    var shownResCnt;

                    if (line == 2) {
                        start = 0;
                        end = 1;
                    }
                    else if (line == 3) {
                        start = 1;
                        end = jl;
                    }

                    if (!bClinvar) {
                        shownResCnt = 2;

                        for (var j = start; j < jl && j < end; ++j) {
                            if (j < shownResCnt) snpStr += resi2snp[i][j];

                            snpTitle += pos + c + '>' + resi2snp[i][j];

                            // disease and significace
                            var diseaseArray = resi2disease[i][j].split('; ');
                            var sigArray = resi2sig[i][j].split('; ');

                            var diseaseTitle = '';
                            var index = 0;
                            for (var k = 0, kl = diseaseArray.length; k < kl; ++k) {
                                if (diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                                    if (index > 0) {
                                        diseaseTitle += '; ';
                                    }
                                    else {
                                        if (j === 0 || j === 1) diseaseStr = 'disease="' + diseaseArray[k] + '"';
                                    }

                                    diseaseTitle += diseaseArray[k] + ' (' + sigArray[k] + ')';
                                    ++index;
                                }
                            }

                            //resi2rsnum, resi2clinAllele,

                            if (diseaseTitle != '') {
                                //snpType = 'icn3d-clinvar';

                                snpTitle += ': ' + diseaseTitle;
                                snpTitle += "<br>Links: <a href='https://www.ncbi.nlm.nih.gov/clinvar/?term=" + resi2clinAllele[i][j] + "[AlleleID]' target='_blank'>ClinVar</a>, <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP (rs" + resi2rsnum[i][j] + ")</a>";
                            }
                            else {
                                snpTitle += "<br>Link: <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP (rs" + resi2rsnum[i][j] + ")</a>"
                            }

                            if (j < jl - 1) {
                                //if(j < 1) snpStr += ';';
                                snpTitle += '<br><br>';
                            }
                        }

                        if (jl > shownResCnt && line == 3) snpStr += '..';
                    }
                    else { // if(bClinvar)
                        shownResCnt = 1;

                        var diseaseCnt = 0;
                        for (var j = start; j < jl && j < end; ++j) {
                            // disease and significace
                            var diseaseArray = resi2disease[i][j].split('; ');
                            var sigArray = resi2sig[i][j].split('; ');

                            var diseaseTitle = '';
                            var index = 0;
                            for (var k = 0, kl = diseaseArray.length; k < kl; ++k) {
                                if (diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                                    if (index > 0) {
                                        diseaseTitle += '; ';
                                    }
                                    else {
                                        if (j === 0 || j === 1) diseaseStr = 'disease="' + diseaseArray[k] + '"';
                                    }

                                    diseaseTitle += diseaseArray[k] + ' (' + sigArray[k] + ')';
                                    ++index;
                                }
                            }

                            if (diseaseTitle != '') {
                                if (diseaseCnt < shownResCnt) snpStr += resi2snp[i][j];

                                snpTitle += pos + c + '>' + resi2snp[i][j];

                                //snpType = 'icn3d-clinvar';

                                snpTitle += ': ' + diseaseTitle;
                                snpTitle += "<br>Links: <a href='https://www.ncbi.nlm.nih.gov/clinvar/?term=" + resi2clinAllele[i][j] + "[AlleleID]' target='_blank'>ClinVar</a>, <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP (rs" + resi2rsnum[i][j] + ")</a>";

                                if (j < jl - 1) {
                                    snpTitle += '<br><br>';
                                }

                                ++diseaseCnt;
                            } // if(diseaseTitle != '') {
                        } // for(var j = start; j < jl && j < end; ++j) {

                        if (diseaseCnt > shownResCnt && line == 3) snpStr += '..';
                    } // else { // if(bClinvar)

                    //if(snpTitle.indexOf('Pathogenic') != -1) {
                    //    snpType = 'icn3d-clinvar-path';
                    //}

                    snpTitle += '</div>';

                    if (bClinvar) {
                        if (snpTypeHash[i] == 'icn3d-clinvar' || snpTypeHash[i] == 'icn3d-clinvar-path') {
                            if (line == 1) {
                                html += '<span>&dArr;</span>'; // or down triangle &#9660;
                            }
                            else {
                                if (snpStr == '' || snpStr == ' ') {
                                    html += '<span>-</span>';
                                }
                                else {
                                    html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" ' + diseaseStr + ' class="icn3d-tooltip icn3d-residue ' + currSnpTypeHash[i] + '">' + snpStr + '</span>';
                                }
                            }
                        }
                        else {
                            html += '<span>-</span>';
                        }
                    }
                    else {
                        if (snpStr == '' || snpStr == ' ') {
                            html += '<span>-</span>';
                        }
                        else {
                            html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" ' + diseaseStr + ' class="icn3d-tooltip icn3d-residue ' + currSnpTypeHash[i] + '">' + snpStr + '</span>';
                        }
                    }
                } // if(!bClinvar && line == 1) {
            }
            else {
                html += '<span>-</span>'; //'<span>-</span>';
            }
        } // if(bOverview) {
    } // for

    //var end = bStartEndRes ? me.icn3d.chainsSeq[chnid][me.giSeq[chnid].length - 1 - me.matchedPos[chnid] ].resi : '';
    if (line == 1) {
        html += '<span class="icn3d-residueNum" title="residue count">&nbsp;' + cnt + ' Residues</span>';
    }
    else {
        html += '<span class="icn3d-residueNum"></span>';
    }

    html += '</span>';
    html += '<br>';

    return html;
};

iCn3DUI.prototype.showSnpClinvar = function (chnid, chnidBase) {
    var me = this;

    var url = "https://www.ncbi.nlm.nih.gov/projects/SNP/beVarSearch_mt.cgi?appname=iCn3D&format=bed&report=pdb2bed&acc=" + chnidBase;

    $.ajax({
        url: url,
        dataType: 'text',
        cache: true,
        tryCount: 0,
        retryLimit: 1,
        success: function (data) {
            if (data != "") {
                var html = '<div id="' + me.pre + chnid + '_snpseq_sequence" class="icn3d-dl_sequence">';
                var html2 = html;
                var html3 = html;

                var htmlClinvar = '<div id="' + me.pre + chnid + '_clinvarseq_sequence" class="icn3d-dl_sequence">';
                var htmlClinvar2 = htmlClinvar;
                var htmlClinvar3 = htmlClinvar;

                var lineArray = data.split('\n');

                var resi2snp = {};
                var resi2index = {};
                var resi2disease = {};
                me.resi2disease_nonempty[chnid] = {};
                var resi2sig = {};

                var resi2rsnum = {};
                var resi2clinAllele = {};

                var posHash = {}, posClinHash = {};

                var prevSnpStr = '';
                for (var i = 0, il = lineArray.length; i < il; ++i) {
                    //1310770    13    14    14Y>H    368771578    150500    Hereditary cancer-predisposing syndrome; Li-Fraumeni syndrome; not specified; Li-Fraumeni syndrome 1    Likely benign; Uncertain significance; Uncertain significance; Uncertain significance    1TSR_A    120407068    NP_000537.3
                    if (lineArray[i] != '') {
                        var fieldArray = lineArray[i].split('\t');

                        var snpStr = fieldArray[3];

                        if (snpStr == prevSnpStr) continue;
                        prevSnpStr = snpStr;

                        var resiStr = snpStr.substr(0, snpStr.length - 3);

                        var resi = parseInt(resiStr);
                        var currRes = snpStr.substr(snpStr.length - 3, 1);
                        var snpRes = snpStr.substr(snpStr.length - 1, 1);

                        var rsnum = fieldArray[4];
                        var clinAllele = fieldArray[5];
                        var disease = fieldArray[6];  // When more than 2+ diseases, they are separated by "; "
                        // Some are "not specified", "not provided"
                        var clinSig = fieldArray[7];     // Clinical significance, When more than 2+ diseases, they are separated by "; "

                        // "*" means terminating codon, "-" means deleted codon
                        //if(currRes !== '-' && currRes !== '*' && snpRes !== '-' && snpRes !== '*') {
                        posHash[resi] = 1;
                        if (disease != '') posClinHash[resi] = 1;
                        resi2index[resi] = i + 1;

                        if (resi2snp[resi] === undefined) {
                            resi2snp[resi] = [];
                        }
                        resi2snp[resi].push(snpRes);

                        if (resi2rsnum[resi] === undefined) {
                            resi2rsnum[resi] = [];
                        }
                        resi2rsnum[resi].push(rsnum);

                        if (resi2clinAllele[resi] === undefined) {
                            resi2clinAllele[resi] = [];
                        }
                        resi2clinAllele[resi].push(clinAllele);

                        if (resi2disease[resi] === undefined) {
                            resi2disease[resi] = [];
                        }
                        resi2disease[resi].push(disease);

                        if (disease != '') {
                            if (me.resi2disease_nonempty[chnid][resi] === undefined) {
                                me.resi2disease_nonempty[chnid][resi] = [];
                            }
                            me.resi2disease_nonempty[chnid][resi].push(disease);
                        }

                        if (resi2sig[resi] === undefined) {
                            resi2sig[resi] = [];
                        }
                        resi2sig[resi].push(clinSig);

                        //}
                    }
                }

                var posarray = Object.keys(posHash);
                var posClinArray = Object.keys(posClinHash);

                var bClinvar = false;

                html += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar);
                html += me.getSnpLine(2, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar);
                html += me.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar);

                html3 += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, true);
                html3 += me.getSnpLine(2, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true);
                html3 += me.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true);

                html2 += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, true, bClinvar);

                html += '</div>';
                html2 += '</div>';
                html3 += '</div>';

                $("#" + me.pre + 'dt_snp_' + chnid).html(html);
                $("#" + me.pre + 'ov_snp_' + chnid).html(html2);
                $("#" + me.pre + 'tt_snp_' + chnid).html(html3);

                bClinvar = true;

                htmlClinvar += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar);
                htmlClinvar += me.getSnpLine(2, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar);
                htmlClinvar += me.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar);

                htmlClinvar3 += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, true);
                htmlClinvar3 += me.getSnpLine(2, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true);
                htmlClinvar3 += me.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true);

                htmlClinvar2 += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, true, bClinvar);

                htmlClinvar += '</div>';
                htmlClinvar2 += '</div>';
                htmlClinvar3 += '</div>';

                if (me.bShowClinvar) {
                    $("#" + me.pre + 'dt_clinvar_' + chnid).html(htmlClinvar);
                    $("#" + me.pre + 'ov_clinvar_' + chnid).html(htmlClinvar2);
                    $("#" + me.pre + 'tt_clinvar_' + chnid).html(htmlClinvar3);
                }

                // add here after the ajax call
                me.enableHlSeq();

                me.navClinVar(chnid, chnidBase);
            } //if(data != "") {
            else {
                $("#" + me.pre + 'dt_clinvar_' + chnid).html('');
                $("#" + me.pre + 'ov_clinvar_' + chnid).html('');

                $("#" + me.pre + 'dt_snp_' + chnid).html('');
                $("#" + me.pre + 'ov_snp_' + chnid).html('');

                // add here after the ajax call
                me.enableHlSeq();

                console.log("No SNP data were found for the protein " + chnid + "...");
            }

            me.bAjaxSnpClinvar = true;

            if (me.deferredSnpClinvar !== undefined) me.deferredSnpClinvar.resolve();
        },
        error: function (xhr, textStatus, errorThrown) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }

            console.log("No SNP data were found for the protein " + chnid + "...");

            $("#" + me.pre + 'dt_clinvar_' + chnid).html('');
            $("#" + me.pre + 'ov_clinvar_' + chnid).html('');

            $("#" + me.pre + 'dt_snp_' + chnid).html('');
            $("#" + me.pre + 'ov_snp_' + chnid).html('');

            me.enableHlSeq();

            me.bAjaxSnpClinvar = true;

            if (me.deferredSnpClinvar !== undefined) me.deferredSnpClinvar.resolve();
            return;
        }
    });
};

iCn3DUI.prototype.showCddSite = function (chnid, chnidBase) {
    var me = this;

    // show conserved domains and binding sites
    var url = "https://www.ncbi.nlm.nih.gov/Structure/cdannots/cdannots.fcgi?fmt&queries=" + chnidBase;
    $.ajax({
        url: url,
        dataType: 'json',
        cache: true,
        tryCount: 0,
        retryLimit: 1,
        success: function (data) {
            var html = '<div id="' + me.pre + chnid + '_cddseq_sequence" class="icn3d-cdd icn3d-dl_sequence">';
            var html2 = html;
            var html3 = html;

            var domainArray = data.data[0].doms;

            var indexl = (domainArray !== undefined) ? domainArray.length : 0;

            for (var index = 0; index < indexl; ++index) {
                var acc = domainArray[index].acc;

                var type = domainArray[index].type;
                type = 'domain';

                var domain = domainArray[index].title.split(':')[0];
                var defline = domainArray[index].defline;
                var title = type + ': ' + domain;
                if (title.length > 14) title = title.substr(0, 14) + '...';

                //var fulltitle = type + ": " + domainArray[index].title + " (accession: " + acc + ")";
                //var fulltitle = type + ": " + domainArray[index].title;
                var fulltitle = type + ": " + domain;

                // each domain may have several repeat. Treat each repeat as a domain
                var domainRepeatArray = domainArray[index].locs;

                for (var r = 0, rl = domainRepeatArray.length; r < rl; ++r) {
                    // each domain repeat or domain may have several segments, i.e., a domain may not be continous
                    var fromArray = [], toArray = [];

                    //var domainFrom = parseInt(domainArray[index].locs[r].segs[0].from);
                    //var domainTo = parseInt(domainArray[index].locs[r].segs[0].to);
                    //var range = domainTo - domainFrom + 1;

                    var resiHash = {};
                    var resCnt = 0;

                    for (var s = 0, sl = domainRepeatArray[r].segs.length; s < sl; ++s) {
                        var domainFrom = parseInt(domainRepeatArray[r].segs[s].from);
                        var domainTo = parseInt(domainRepeatArray[r].segs[s].to);

                        fromArray.push(domainFrom);
                        toArray.push(domainTo);

                        for (var i = domainFrom; i <= domainTo; ++i) {
                            resiHash[i] = 1;
                        }

                        resCnt += domainTo - domainFrom + 1;
                    }

                    //html += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + acc + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" setname="' + chnid + '_' + type + '_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';

                    //var htmlTmp = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';

                    //htmlTmp += '<span class="icn3d-seqLine">';
                    //html += htmlTmp;

                    var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + acc + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" setname="' + chnid + '_' + type + '_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';

                    var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';

                    html3 += htmlTmp2 + htmlTmp3 + '<br>';

                    var htmlTmp = '<span class="icn3d-seqLine">';

                    html += htmlTmp2 + htmlTmp3 + htmlTmp;

                    html2 += '<div style="width:20px; display:inline-block;"><span id="' + me.pre + chnid + '_' + acc + '_' + r + '_cddseq_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + chnid + '_' + acc + '_' + r + '_cddseq_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div>';
                    html2 += '<div style="width:100px!important;" class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + acc + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_' + type + '_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                    html2 += htmlTmp3 + htmlTmp;

                    var pre = type + index.toString();
                    for (var i = 0, il = me.giSeq[chnid].length; i < il; ++i) {
                        if (resiHash.hasOwnProperty(i)) {
                            var cFull = me.giSeq[chnid][i];

                            var c = cFull;
                            if (cFull.length > 1) {
                                c = cFull[0] + '..';
                            }

                            //                var pos = (me.baseResi[chnid] + i+1).toString();
                            //                var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi
                            var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

                            html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';
                        }
                        else {
                            html += '<span>-</span>'; //'<span>-</span>';
                        }
                    }


                    var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chnid]);
                    var color = atom.color.getHexString();

                    //html2 += '<div style="display:inline-block; width:' + parseInt(me.seqAnnWidth * domainFrom / me.maxAnnoLength) + 'px;"></div>';
                    //html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + parseInt(me.seqAnnWidth * (domainTo - domainFrom + 1) / me.maxAnnoLength) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + acc + '" from="' + domainFrom.toString() + '" to="' + domainTo.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_' + type + '_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + domain + ' </div>';

                    for (var i = 0, il = fromArray.length; i < il; ++i) {
                        var emptyWidth = (i == 0) ? parseInt(me.seqAnnWidth * fromArray[i] / me.maxAnnoLength) : parseInt(me.seqAnnWidth * (fromArray[i] - toArray[i - 1] + 1) / me.maxAnnoLength);
                        html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;"></div>';

                        html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + parseInt(me.seqAnnWidth * (toArray[i] - fromArray[i] + 1) / me.maxAnnoLength) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + (index + 1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_domain_' + index + '_' + r + '" id="' + chnid + '_domain_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + domain + ' </div>';
                    }

                    htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';

                    htmlTmp += '</span>';
                    htmlTmp += '<br>';

                    html += htmlTmp;
                    html2 += htmlTmp;

                    html2 += '<div id="' + me.pre + chnid + '_' + acc + '_' + r + '_cddseq" style="display:none; white-space:normal;" class="icn3d-box">' + defline + ' (<a href="https://www.ncbi.nlm.nih.gov/Structure/cdd/cddsrv.cgi?uid=' + acc + '" target="_blank" class="icn3d-blue">open details view...</a>)</div>';
                } // for(var r = 0,
            }

            html += '</div>';
            html2 += '</div>';
            html3 += '</div>';

            $("#" + me.pre + "dt_cdd_" + chnid).html(html);
            $("#" + me.pre + "ov_cdd_" + chnid).html(html2);
            $("#" + me.pre + "tt_cdd_" + chnid).html(html3);

            html = '<div id="' + me.pre + chnid + '_siteseq_sequence" class="icn3d-dl_sequence">';
            html2 = html;
            html3 = html;

            var siteArray = data.data[0].sites;
            var indexl = (siteArray !== undefined) ? siteArray.length : 0;

            for (var index = 0; index < indexl; ++index) {
                var domain = siteArray[index].srcdom;
                var type = siteArray[index].type;
                var resCnt = siteArray[index].sz;

                var title = 'site: ' + siteArray[index].title;
                if (title.length > 17) title = title.substr(0, 17) + '...';

                //var fulltitle = "site: " + siteArray[index].title + " (domain: " + domain + ")";
                var fulltitle = siteArray[index].title;

                var resPosArray = siteArray[index].locs[0].coords;
                var adjustedResPosArray = [];
                for (var i = 0, il = resPosArray.length; i < il; ++i) {
                    adjustedResPosArray.push(parseInt(resPosArray[i]) + me.baseResi[chnid]);
                }

                var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" site="site" posarray="' + adjustedResPosArray.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_site_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';
                var htmlTmp = '<span class="icn3d-seqLine">';

                html3 += htmlTmp2 + htmlTmp3 + '<br>';

                html += htmlTmp2 + htmlTmp3 + htmlTmp;
                html2 += htmlTmp2 + htmlTmp3 + htmlTmp;

                var pre = 'site' + index.toString();
                var widthPerRes = me.seqAnnWidth / me.maxAnnoLength;

                var prevEmptyWidth = 0;
                var prevLineWidth = 0;
                var widthPerRes = 1;
                for (var i = 0, il = me.giSeq[chnid].length; i < il; ++i) {
                    if (resPosArray.indexOf(i) != -1) {
                        var cFull = me.giSeq[chnid][i];

                        var c = cFull;
                        if (cFull.length > 1) {
                            c = cFull[0] + '..';
                        }

                        //                var pos = (me.baseResi[chnid] + i+1).toString();
                        //                var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
                        var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

                        html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';

                        var emptyWidth = parseInt(me.seqAnnWidth * i / me.maxAnnoLength - prevEmptyWidth - prevLineWidth);
                        if (emptyWidth < 0) emptyWidth = 0;

                        html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;"></div>';
                        html2 += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + c + pos + '">&nbsp;</div>';

                        prevEmptyWidth += emptyWidth;
                        prevLineWidth += widthPerRes;
                    }
                    else {
                        html += '<span>-</span>'; //'<span>-</span>';
                    }
                }

                htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
                htmlTmp += '</span>';
                htmlTmp += '<br>';

                html += htmlTmp;
                html2 += htmlTmp;
            }

            html += '</div>';
            html2 += '</div>';
            html3 += '</div>';

            $("#" + me.pre + "dt_site_" + chnid).html(html);
            $("#" + me.pre + "ov_site_" + chnid).html(html2);
            $("#" + me.pre + "tt_site_" + chnid).html(html3);

            // add here after the ajax call
            me.enableHlSeq();

            me.bAjaxCddSite = true;

            if (me.deferredAnnoCddSite !== undefined) me.deferredAnnoCddSite.resolve();
        },
        error: function (xhr, textStatus, errorThrown) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }

            console.log("No CDD data were found for the protein " + chnid + "...");

            $("#" + me.pre + "dt_cdd_" + chnid).html('');
            $("#" + me.pre + "ov_cdd_" + chnid).html('');
            $("#" + me.pre + "tt_cdd_" + chnid).html('');

            $("#" + me.pre + "dt_site_" + chnid).html('');
            $("#" + me.pre + "ov_site_" + chnid).html('');
            $("#" + me.pre + "tt_site_" + chnid).html('');

            // add here after the ajax call
            me.enableHlSeq();

            me.bAjaxCddSite = true;

            if (me.deferredAnnoCddSite !== undefined) me.deferredAnnoCddSite.resolve();
            return;
        }
    });
};

iCn3DUI.prototype.showDomain = function (chnid, chnidBase) {
    var me = this;
    var pdbid = chnidBase.substr(0, chnid.indexOf('_'));

    // show 3D domains
    var url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&domain&molinfor&uid=" + pdbid;

    if (me.mmdb_data !== undefined) {
        me.showDomainWithData(chnid, me.mmdb_data);
    }
    else {
        $.ajax({
            url: url,
            dataType: 'json',
            cache: true,
            tryCount: 0,
            retryLimit: 1,
            success: function (data) {
                me.mmdb_data = data;

                me.showDomainWithData(chnid, me.mmdb_data);

                // add here after the ajax call
                me.enableHlSeq();

                me.bAjax3ddomain = true;

                if (me.deferred3ddomain !== undefined) me.deferred3ddomain.resolve();
            },
            error: function (xhr, textStatus, errorThrown) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }

                console.log("No 3D domain data were found for the protein " + chnid + "...");

                $("#" + me.pre + "dt_domain_" + chnid).html('');
                $("#" + me.pre + "ov_domain_" + chnid).html('');
                $("#" + me.pre + "tt_domain_" + chnid).html('');

                me.enableHlSeq();

                me.bAjax3ddomain = true;

                if (me.deferred3ddomain !== undefined) me.deferred3ddomain.resolve();
                return;
            }
        });
    }
};

iCn3DUI.prototype.showDomainWithData = function (chnid, data) {
    var me = this;
    var html = '<div id="' + me.pre + chnid + '_domainseq_sequence" class="icn3d-dl_sequence">';
    var html2 = html;
    var html3 = html;

    var domainArray, proteinname;

    var pos = chnid.indexOf('_');
    var chain = chnid.substr(pos + 1);

    var molinfo = data.moleculeInfor;
    var currMolid;
    for (var molid in molinfo) {
        if (molinfo[molid].chain === chain) {
            currMolid = molid;
            proteinname = molinfo[molid].name;
            break;
        }
    }

    if (currMolid !== undefined && data.domains[currMolid] !== undefined) {
        domainArray = data.domains[currMolid].domains;
    }

    if (domainArray === undefined) {
        domainArray = [];
    }

    for (var index = 0, indexl = domainArray.length; index < indexl; ++index) {
        //var fulltitle = '3D domain ' + (index+1).toString() + ' of ' + proteinname + ' (PDB ID: ' + data.pdbId + ')';
        var fulltitle = '3D domain ' + (index + 1).toString() + ' of ' + proteinname;
        var title = (fulltitle.length > 17) ? fulltitle.substr(0, 17) + '...' : fulltitle;

        var subdomainArray = domainArray[index].intervals;

        // remove duplicate, e.g., at https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&domain&molinfor&uid=1itw
        var domainHash = {};

        var fromArray = [], toArray = [];
        var resiHash = {};
        var resCnt = 0
        for (var i = 0, il = subdomainArray.length; i < il; ++i) {
            var domainFrom = parseInt(subdomainArray[i][0]) - 1; // 1-based
            var domainTo = parseInt(subdomainArray[i][1]) - 1;

            domainStr = domainFrom + "," + domainTo;

            if (domainHash.hasOwnProperty(domainStr)) {
                continue; // do nothing for duplicates, e.g, PDBID 1ITW
            }
            else {
                domainHash[domainStr] = 1;
            }

            fromArray.push(domainFrom);
            toArray.push(domainTo);
            resCnt += domainTo - domainFrom + 1;

            for (var j = domainFrom; j <= domainTo; ++j) {
                resiHash[j + 1] = 1;
            }
        }

        //var domainFrom = parseInt(domainArray[index].intervals.) - 1; // 1-based
        //var domainTo = parseInt(domainArray[index][0][1]) - 1;
        //var range = domainTo - domainFrom + 1;

        //var htmlTmp = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + (index+1).toString() + '" from="' + domainFrom.toString() + '" to="' + domainTo.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_3d_domain_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
        //var htmlTmp = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + (index+1).toString() + '" posarray="' + Object.keys(resiHash).toString() + '" shorttitle="' + title + '" setname="' + chnid + '_3d_domain_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
        var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" 3ddomain="' + (index + 1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_3d_domain_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';

        //htmlTmp += '<span class="icn3d-residueNum" title="starting protein sequence number">' + (me.baseResi[chnid] + fromArray[0]+1).toString() + '</span>';
        var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';

        html3 += htmlTmp2 + htmlTmp3 + '<br>';

        var htmlTmp = '<span class="icn3d-seqLine">';

        html += htmlTmp2 + htmlTmp3 + htmlTmp;
        html2 += htmlTmp2 + htmlTmp3 + htmlTmp;

        var pre = 'domain3d' + index.toString();
        for (var i = 0, il = me.giSeq[chnid].length; i < il; ++i) {
            //if(i >= domainFrom && i <= domainTo) {
            if (resiHash.hasOwnProperty(i + 1)) {
                var cFull = me.giSeq[chnid][i];

                var c = cFull;
                if (cFull.length > 1) {
                    c = cFull[0] + '..';
                }

                //                var pos = (me.baseResi[chnid] + i+1).toString();
                //                var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
                var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

                html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';
            }
            else {
                html += '<span>-</span>'; //'<span>-</span>';
            }
        }

        var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chnid]);
        var color = atom.color.getHexString();

        for (var i = 0, il = fromArray.length; i < il; ++i) {
            var emptyWidth = (i == 0) ? parseInt(me.seqAnnWidth * fromArray[i] / me.maxAnnoLength) : parseInt(me.seqAnnWidth * (fromArray[i] - toArray[i - 1] + 1) / me.maxAnnoLength);
            html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;"></div>';

            html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + parseInt(me.seqAnnWidth * (toArray[i] - fromArray[i] + 1) / me.maxAnnoLength) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" 3ddomain="' + (index + 1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_3d_domain_' + index + '" id="' + chnid + '_3d_domain_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">3D domain ' + (index + 1).toString() + '</div>';
        }

        //var lastToArray = toArray[toArray.length - 1];
        //var end = (lastToArray - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][lastToArray - me.matchedPos[chnid] ].resi : me.baseResi[chnid] + 1 + lastToArray;
        //htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">&nbsp;' + end + '</span>';

        htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';

        htmlTmp += '</span>';
        htmlTmp += '<br>';

        html += htmlTmp;
        html2 += htmlTmp;
    }

    html += '</div>';
    html2 += '</div>';
    html3 += '</div>';

    $("#" + me.pre + "dt_domain_" + chnid).html(html);
    $("#" + me.pre + "ov_domain_" + chnid).html(html2);
    $("#" + me.pre + "tt_domain_" + chnid).html(html3);
};

iCn3DUI.prototype.showInteraction = function (chnid, chnidBase) {
    var me = this;

    if (me.chainname2residues === undefined && (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined)) {
        // 2d interaction didn't finish loading data yet
        setTimeout(function () {
            me.showInteraction_base(chnid, chnidBase);
        }, 1000);
    }
    else {
        me.showInteraction_base(chnid, chnidBase);
    }
};

iCn3DUI.prototype.showInteraction_base = function (chnid, chnidBase) {
    var me = this;

    // set interaction
    if (me.chainname2residues === undefined) me.chainname2residues = {};

    var radius = 4;
    var chainArray = Object.keys(me.icn3d.chains);

    var chainid = chnid;

    var pos = parseInt(chainid.indexOf('_'));
    if (pos > 4) return; // NMR structures with structure id such as 2K042,2K043, ...

    var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chainid]);

    if (me.chainname2residues[chainid] === undefined) {
        me.chainname2residues[chainid] = {};

        var jl = chainArray.length;
        if (jl > 100 && me.cfg.mmdbid === undefined && me.cfg.gi === undefined && me.cfg.align === undefined) {
            //if(jl > 100) {
            //console.log("Do not show interactions if there are more than 100 chains");
            $("#" + me.pre + "dt_interaction_" + chnid).html("");
            $("#" + me.pre + "ov_interaction_" + chnid).html("");

            return; // skip interactions if there are more than 100 chains
        }

        for (var j = 0; j < jl; ++j) {
            var chainid2 = chainArray[j];
            if (chainid2 === chainid) continue;

            pos = parseInt(chainid.indexOf('_'));
            if (pos > 4) continue; // NMR structures with structure id such as 2K042,2K043, ...

            var atom2 = me.icn3d.getFirstAtomObj(me.icn3d.chains[chainid2]);
            //if(me.chainname2residues[chainid2] === undefined) me.chainname2residues[chainid2] = {};

            var type2;
            if (me.icn3d.chemicals.hasOwnProperty(atom2.serial)) { // 1. chemical interacting with proteins
                type2 = 'chemical';
            }
            else if (me.icn3d.nucleotides.hasOwnProperty(atom2.serial)) { // 2. DNA interacting with proteins
                type2 = 'nucleotide';
            }
            else if (me.icn3d.ions.hasOwnProperty(atom2.serial)) { // 3. ions interacting with proteins
                type2 = 'ion';
            }
            else if (me.icn3d.proteins.hasOwnProperty(atom2.serial)) { // 4. protein interacting with proteins
                type2 = 'protein';
            }

            // find atoms in chainid1, which interact with chainid2
            var atomsChainid1 = me.icn3d.getAtomsWithinAtom(me.icn3d.hash2Atoms(me.icn3d.chains[chainid]), me.icn3d.hash2Atoms(me.icn3d.chains[chainid2]), radius);

            if (Object.keys(atomsChainid1).length == 0) continue;

            var residues = {};

            for (var k in atomsChainid1) {
                var atom = me.icn3d.atoms[k];
                var residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                residues[residueid] = 1;
            }

            var name = chainid2.substr(chainid2.indexOf('_') + 1) + " (" + type2 + ")";

            me.chainname2residues[chainid][name] = Object.keys(residues);
        } // for
    }

    var html = '<div id="' + me.pre + chnid + '_interseq_sequence" class="icn3d-dl_sequence">';
    var html2 = html;
    var html3 = html;

    var index = 0;
    for (var chainname in me.chainname2residues[chnid]) {
        var residueArray = me.chainname2residues[chnid][chainname];
        var resCnt = residueArray.length;

        var title = "Interact ." + chainname;
        if (title.length > 17) title = title.substr(0, 17) + '...';

        var fulltitle = "Interact ." + chainname;

        var resPosArray = [];
        for (var i = 0, il = residueArray.length; i < il; ++i) {
            resPosArray.push(parseInt(residueArray[i].substr(residueArray[i].lastIndexOf('_') + 1)));
        }

        var chainnameNospace = chainname.replace(/\s/g, '');

        var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" interaction="' + (index + 1).toString() + '" posarray="' + resPosArray.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_' + chainnameNospace + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
        var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';

        html3 += htmlTmp2 + htmlTmp3 + '<br>';

        var htmlTmp = '<span class="icn3d-seqLine">';

        html += htmlTmp2 + htmlTmp3 + htmlTmp;
        html2 += htmlTmp2 + htmlTmp3 + htmlTmp;

        var pre = 'inter' + index.toString();

        var prevEmptyWidth = 0;
        var prevLineWidth = 0;
        var widthPerRes = 1;

        for (var i = 0, il = me.giSeq[chnid].length; i < il; ++i) {
            if (resPosArray.indexOf(i + 1) != -1) {
                var cFull = me.giSeq[chnid][i];

                var c = cFull;
                if (cFull.length > 1) {
                    c = cFull[0] + '..';
                }

                //            var pos = (me.baseResi[chnid] + i+1).toString();
                //            var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
                var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

                html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + cFull + pos + '" class="icn3d-residue">' + c + '</span>';

                var emptyWidth = parseInt(me.seqAnnWidth * i / me.maxAnnoLength - prevEmptyWidth - prevLineWidth);
                if (emptyWidth < 0) emptyWidth = 0;

                html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;"></div>';
                html2 += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + c + pos + '">&nbsp;</div>';

                prevEmptyWidth += emptyWidth;
                prevLineWidth += widthPerRes;
            }
            else {
                html += '<span>-</span>'; //'<span>-</span>';
            }
        }

        htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
        htmlTmp += '</span>';
        htmlTmp += '<br>';

        html += htmlTmp;
        html2 += htmlTmp;

        ++index;
    }

    html += '</div>';
    html2 += '</div>';
    html3 += '</div>';

    $("#" + me.pre + "dt_interaction_" + chnid).html(html);
    $("#" + me.pre + "ov_interaction_" + chnid).html(html2);
    $("#" + me.pre + "tt_interaction_" + chnid).html(html3);

    // add here after the ajax call
    if (!me.isMobile()) {
        me.selectSequenceNonMobile();
    }
    else {
        me.selectSequenceMobile();
        me.selectChainMobile();
    }
};

iCn3DUI.prototype.hideAllAnno = function () {
    var me = this;
    $("[id^=" + me.pre + "site]").hide();
    $("[id^=" + me.pre + "snp]").hide();
    $("[id^=" + me.pre + "clinvar]").hide();
    $("[id^=" + me.pre + "cdd]").hide();
    $("[id^=" + me.pre + "domain]").hide();
    $("[id^=" + me.pre + "interaction]").hide();
    $("[id^=" + me.pre + "custom]").hide();
};

iCn3DUI.prototype.setAnnoTabAll = function () {
    var me = this;
    if ($("#" + me.pre + "anno_all").length) $("#" + me.pre + "anno_all")[0].checked = true;

    if ($("#" + me.pre + "anno_binding").length) $("#" + me.pre + "anno_binding")[0].checked = true;
    if ($("#" + me.pre + "anno_snp").length) $("#" + me.pre + "anno_snp")[0].checked = true;
    if ($("#" + me.pre + "anno_clinvar").length) $("#" + me.pre + "anno_clinvar")[0].checked = true;
    if ($("#" + me.pre + "anno_cdd").length) $("#" + me.pre + "anno_cdd")[0].checked = true;
    if ($("#" + me.pre + "anno_3dd").length) $("#" + me.pre + "anno_3dd")[0].checked = true;
    if ($("#" + me.pre + "anno_interact").length) $("#" + me.pre + "anno_interact")[0].checked = true;
    if ($("#" + me.pre + "anno_custom").length) $("#" + me.pre + "anno_custom")[0].checked = true;

    //$("[id^=" + me.pre + "custom]").show();
    $("[id^=" + me.pre + "site]").show();
    $("[id^=" + me.pre + "snp]").show();
    $("[id^=" + me.pre + "clinvar]").show();
    $("[id^=" + me.pre + "cdd]").show();
    $("[id^=" + me.pre + "domain]").show();
    $("[id^=" + me.pre + "interaction]").show();
    $("[id^=" + me.pre + "custom]").show();

    me.updateSnpClinvar();
    me.updateDomain();
    me.updateInteraction();
};

iCn3DUI.prototype.hideAnnoTabAll = function () {
    var me = this;
    if ($("#" + me.pre + "anno_all").length) $("#" + me.pre + "anno_all")[0].checked = false;

    if ($("#" + me.pre + "anno_binding").length) $("#" + me.pre + "anno_binding")[0].checked = false;
    if ($("#" + me.pre + "anno_snp").length) $("#" + me.pre + "anno_snp")[0].checked = false;
    if ($("#" + me.pre + "anno_clinvar").length) $("#" + me.pre + "anno_clinvar")[0].checked = false;
    if ($("#" + me.pre + "anno_cdd").length) $("#" + me.pre + "anno_cdd")[0].checked = false;
    if ($("#" + me.pre + "anno_3dd").length) $("#" + me.pre + "anno_3dd")[0].checked = false;
    if ($("#" + me.pre + "anno_interact").length) $("#" + me.pre + "anno_interact")[0].checked = false;
    if ($("#" + me.pre + "anno_custom").length) $("#" + me.pre + "anno_custom")[0].checked = false;

    me.hideAllAnno();
};

iCn3DUI.prototype.setAnnoTabCustom = function () {
    var me = this;
    $("[id^=" + me.pre + "custom]").show();
    if ($("#" + me.pre + "anno_custom").length) $("#" + me.pre + "anno_custom")[0].checked = true;
};

iCn3DUI.prototype.hideAnnoTabCustom = function () {
    var me = this;
    $("[id^=" + me.pre + "custom]").hide();
    if ($("#" + me.pre + "anno_custom").length) $("#" + me.pre + "anno_custom")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabClinvar = function () {
    var me = this;
    $("[id^=" + me.pre + "clinvar]").show();
    if ($("#" + me.pre + "anno_clinvar").length) $("#" + me.pre + "anno_clinvar")[0].checked = true;

    me.updateSnpClinvar();
};

iCn3DUI.prototype.hideAnnoTabClinvar = function () {
    var me = this;
    $("[id^=" + me.pre + "clinvar]").hide();
    if ($("#" + me.pre + "anno_clinvar").length) $("#" + me.pre + "anno_clinvar")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabSnp = function () {
    var me = this;
    $("[id^=" + me.pre + "snp]").show();
    if ($("#" + me.pre + "anno_snp").length) $("#" + me.pre + "anno_snp")[0].checked = true;

    me.updateSnpClinvar();
};

iCn3DUI.prototype.hideAnnoTabSnp = function () {
    var me = this;
    $("[id^=" + me.pre + "snp]").hide();
    if ($("#" + me.pre + "anno_snp").length) $("#" + me.pre + "anno_snp")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabCdd = function () {
    var me = this;
    $("[id^=" + me.pre + "cdd]").show();
    if ($("#" + me.pre + "anno_cdd").length) $("#" + me.pre + "anno_cdd")[0].checked = true;
};

iCn3DUI.prototype.hideAnnoTabCdd = function () {
    var me = this;
    $("[id^=" + me.pre + "cdd]").hide();
    if ($("#" + me.pre + "anno_cdd").length) $("#" + me.pre + "anno_cdd")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTab3ddomain = function () {
    var me = this;
    $("[id^=" + me.pre + "domain]").show();
    if ($("#" + me.pre + "anno_3dd").length) $("#" + me.pre + "anno_3dd")[0].checked = true;

    me.updateDomain();
};

iCn3DUI.prototype.hideAnnoTab3ddomain = function () {
    var me = this;
    $("[id^=" + me.pre + "domain]").hide();
    if ($("#" + me.pre + "anno_3dd").length) $("#" + me.pre + "anno_3dd")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabSite = function () {
    var me = this;
    $("[id^=" + me.pre + "site]").show();
    if ($("#" + me.pre + "anno_site").length) $("#" + me.pre + "anno_site")[0].checked = true;
};

iCn3DUI.prototype.hideAnnoTabSite = function () {
    var me = this;
    $("[id^=" + me.pre + "site]").hide();
    if ($("#" + me.pre + "anno_site").length) $("#" + me.pre + "anno_site")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabInteraction = function () {
    var me = this;
    $("[id^=" + me.pre + "interaction]").show();
    if ($("#" + me.pre + "anno_interact").length) $("#" + me.pre + "anno_interact")[0].checked = true;

    me.updateInteraction();
};

iCn3DUI.prototype.hideAnnoTabInteraction = function () {
    var me = this;
    $("[id^=" + me.pre + "interaction]").hide();
    if ($("#" + me.pre + "anno_interact").length) $("#" + me.pre + "anno_interact")[0].checked = false;
};

iCn3DUI.prototype.setTabs = function () {
    var me = this;
    //        $("#" + me.pre + "dl_annotations_tabs").tabs();
    $("#" + me.pre + "dl_addtrack_tabs").tabs();
    $("#" + me.pre + "dl_anno_view_tabs").tabs();

    $("#" + me.pre + "anno_all").click(function (e) {
        if ($("#" + me.pre + "anno_all")[0].checked) {
            me.setAnnoTabAll();
            me.setLogCmd("set annotation all", true);
        }
        else {
            me.hideAnnoTabAll();
            me.setLogCmd("hide annotation all", true);
        }
    });

    $("#" + me.pre + "anno_binding").click(function (e) {
        if ($("#" + me.pre + "anno_binding")[0].checked) {
            me.setAnnoTabSite();
            me.setLogCmd("set annotation site", true);
        }
        else {
            me.hideAnnoTabSite();
            me.setLogCmd("hide annotation site", true);
        }
    });

    $("#" + me.pre + "anno_snp").click(function (e) {
        if ($("#" + me.pre + "anno_snp")[0].checked) {
            me.setAnnoTabSnp();
            me.setLogCmd("set annotation snp", true);
        }
        else {
            me.hideAnnoTabSnp();
            me.setLogCmd("hide annotation snp", true);
        }
    });

    $("#" + me.pre + "anno_clinvar").click(function (e) {
        if ($("#" + me.pre + "anno_clinvar")[0].checked) {
            me.setAnnoTabClinvar();
            me.setLogCmd("set annotation clinvar", true);
        }
        else {
            me.hideAnnoTabClinvar();
            me.setLogCmd("hide annotation clinvar", true);
        }
    });

    $("#" + me.pre + "anno_cdd").click(function (e) {
        me.clickCdd();
    });

    $("#" + me.pre + "anno_3dd").click(function (e) {
        if ($("#" + me.pre + "anno_3dd")[0].checked) {
            me.setAnnoTab3ddomain();
            me.setLogCmd("set annotation 3ddomain", true);
        }
        else {
            me.hideAnnoTab3ddomain();
            me.setLogCmd("hide annotation 3ddomain", true);
        }
    });

    $("#" + me.pre + "anno_interact").click(function (e) {
        if ($("#" + me.pre + "anno_interact")[0].checked) {
            me.setAnnoTabInteraction();
            me.setLogCmd("set annotation interaction", true);
        }
        else {
            me.hideAnnoTabInteraction();
            me.setLogCmd("hide annotation interaction", true);
        }
    });


    $("#" + me.pre + "anno_custom").click(function (e) {
        if ($("#" + me.pre + "anno_custom")[0].checked) {
            me.setAnnoTabCustom();
            me.setLogCmd("set annotation custom", true);
        }
        else {
            me.hideAnnoTabCustom();
            me.setLogCmd("hide annotation custom", true);
        }
    });

};

iCn3DUI.prototype.clickCdd = function () {
    var me = this;
    if ($("[id^=" + me.pre + "cdd]").length > 0) {
        if ($("#" + me.pre + "anno_cdd")[0].checked) {
            me.setAnnoTabCdd();
            me.setLogCmd("set annotation cdd", true);
        }
        else {
            me.hideAnnoTabCdd();
            me.setLogCmd("hide annotation cdd", true);
        }
    }
};

// jquery tooltip
//https://stackoverflow.com/questions/18231315/jquery-ui-tooltip-html-with-links
iCn3DUI.prototype.setToolTip = function () {
    var me = this;
    $("[id^=" + me.pre + "snp]").add("[id^=" + me.pre + "clinvar]").tooltip({
        content: function () {
            return $(this).prop('title');
        },
        show: null,
        close: function (event, ui) {
            ui.tooltip.hover(

                function () {
                    $(this).stop(true).fadeTo(400, 1);
                },

                function () {
                    $(this).fadeOut("200", function () {
                        $(this).remove();
                    })
                });
        }
    });
};

iCn3DUI.prototype.showAnnoSelectedChains = function () {
    var me = this;
    // show selected chains in annotation window
    var chainHash = {};
    for (var i in me.icn3d.hAtoms) {
        var atom = me.icn3d.atoms[i];
        var chainid = atom.structure + '_' + atom.chain;
        chainHash[chainid] = 1;
    }

    $("#" + me.pre + "dl_annotations > .icn3d-annotation").hide();
    for (var chainid in chainHash) {
        if ($("#" + me.pre + "anno_" + chainid).length) {
            $("#" + me.pre + "anno_" + chainid).show();
        }

        var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chainid]);
        var oneLetterRes = me.icn3d.residueName2Abbr(atom.resn.substr(0, 3));

        $("#" + me.pre + "anno_" + oneLetterRes).show();
    }
};

iCn3DUI.prototype.showAnnoAllChains = function () {
    var me = this;
    $("#" + me.pre + "dl_annotations > .icn3d-annotation").show();
};

iCn3DUI.prototype.setAnnoView = function (view) {
    var me = this;
    if (view === 'detailed view') {
        me.view = 'detailed view';

        // set text
        //        $("#" + me.pre + "viewdetail").show();
        //        $("#" + me.pre + "overview").hide();

        //$("#" + me.pre + "viewswitch")[0].checked = false;

        $("#" + me.pre + "dl_anno_view_tabs").tabs("option", "active", 1);
    }
    else { // overview
        me.view = 'overview';

        // set text
        //        $("#" + me.pre + "viewdetail").hide();
        //        $("#" + me.pre + "overview").show();

        //$("#" + me.pre + "viewswitch")[0].checked = true;

        $("#" + me.pre + "dl_anno_view_tabs").tabs("option", "active", 0);
    }
};

iCn3DUI.prototype.showFixedTitle = function () {
    var me = this;
    var style = 'display:block;'
    $("[id^=" + me.pre + "tt_giseq]").attr('style', style);
    $("[id^=" + me.pre + "tt_custom]").attr('style', style);
    $("[id^=" + me.pre + "tt_site]").attr('style', style);
    $("[id^=" + me.pre + "tt_snp]").attr('style', style);
    $("[id^=" + me.pre + "tt_clinvar]").attr('style', style);
    $("[id^=" + me.pre + "tt_cdd]").attr('style', style);
    $("[id^=" + me.pre + "tt_domain]").attr('style', style);
    $("[id^=" + me.pre + "tt_interaction]").attr('style', style);
};

iCn3DUI.prototype.hideFixedTitle = function () {
    var me = this;
    var style = 'display:none!important;'
    $("[id^=" + me.pre + "tt_giseq]").attr('style', style);
    $("[id^=" + me.pre + "tt_custom]").attr('style', style);
    $("[id^=" + me.pre + "tt_site]").attr('style', style);
    $("[id^=" + me.pre + "tt_snp]").attr('style', style);
    $("[id^=" + me.pre + "tt_clinvar]").attr('style', style);
    $("[id^=" + me.pre + "tt_cdd]").attr('style', style);
    $("[id^=" + me.pre + "tt_domain]").attr('style', style);
    $("[id^=" + me.pre + "tt_interaction]").attr('style', style);
};

iCn3DUI.prototype.setAnnoViewAndDisplay = function (view) {
    var me = this;
    if (view === 'detailed view') {
        me.setAnnoView('detailed view');

        var style = 'display:block;'
        $("[id^=" + me.pre + "dt_giseq]").attr('style', style);
        $("[id^=" + me.pre + "dt_custom]").attr('style', style);
        $("[id^=" + me.pre + "dt_site]").attr('style', style);
        $("[id^=" + me.pre + "dt_snp]").attr('style', style);
        $("[id^=" + me.pre + "dt_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "dt_cdd]").attr('style', style);
        $("[id^=" + me.pre + "dt_domain]").attr('style', style);
        $("[id^=" + me.pre + "dt_interaction]").attr('style', style);

        $("#" + me.pre + "seqguide_wrapper").attr('style', style);

        style = 'display:none;'
        $("[id^=" + me.pre + "ov_giseq]").attr('style', style);
        $("[id^=" + me.pre + "ov_custom]").attr('style', style);
        $("[id^=" + me.pre + "ov_site]").attr('style', style);
        $("[id^=" + me.pre + "ov_snp]").attr('style', style);
        $("[id^=" + me.pre + "ov_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "ov_cdd]").attr('style', style);
        $("[id^=" + me.pre + "ov_domain]").attr('style', style);
        $("[id^=" + me.pre + "ov_interaction]").attr('style', style);
    }
    else { // overview
        me.setAnnoView('overview');

        me.hideFixedTitle();

        var style = 'display:none;'
        $("[id^=" + me.pre + "dt_giseq]").attr('style', style);
        $("[id^=" + me.pre + "dt_custom]").attr('style', style);
        $("[id^=" + me.pre + "dt_site]").attr('style', style);
        $("[id^=" + me.pre + "dt_snp]").attr('style', style);
        $("[id^=" + me.pre + "dt_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "dt_cdd]").attr('style', style);
        $("[id^=" + me.pre + "dt_domain]").attr('style', style);
        $("[id^=" + me.pre + "dt_interaction]").attr('style', style);

        $("#" + me.pre + "seqguide_wrapper").attr('style', style);

        style = 'display:block;'
        $("[id^=" + me.pre + "ov_giseq]").attr('style', style);
        $("[id^=" + me.pre + "ov_custom]").attr('style', style);
        $("[id^=" + me.pre + "ov_site]").attr('style', style);
        $("[id^=" + me.pre + "ov_snp]").attr('style', style);
        $("[id^=" + me.pre + "ov_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "ov_cdd]").attr('style', style);
        $("[id^=" + me.pre + "ov_domain]").attr('style', style);
        $("[id^=" + me.pre + "ov_interaction]").attr('style', style);
    }
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.addTrack = function () {
    var me = this;
    $(document).on('click', ".addtrack", function (e) {
        e.stopImmediatePropagation();

        $("#" + me.pre + "anno_custom")[0].checked = true;
        $("[id^=" + me.pre + "custom]").show();

        //e.preventDefault();
        var chainid = $(this).attr('chainid');
        $("#" + me.pre + "track_chainid").val(chainid);
        me.openDialog(me.pre + 'dl_addtrack', 'Add track for Chain: ' + chainid);
        $("#" + me.pre + "track_gi").focus();
    });
};

iCn3DUI.prototype.simplifyText = function (text) {
    var me = this;
    var out = ''; // 1-based text positions
    var bFoundText = false;

    var i, prevEmptyPos = -1;
    for (i = 0, il = text.length; i < il; ++i) {
        if (text[i] == '-' || text[i] == ' ') {
            if (bFoundText && i !== prevEmptyPos) {
                if (prevEmptyPos + 1 == i - 1) {
                    out += (prevEmptyPos + 1 + 1).toString() + ' ' + text.substr(prevEmptyPos + 1, i - 1 - prevEmptyPos) + ', ';
                }
                else {
                    out += (prevEmptyPos + 1 + 1).toString() + '-' + (i - 1 + 1).toString() + ' ' + text.substr(prevEmptyPos + 1, i - 1 - prevEmptyPos) + ', ';
                }
                bFoundText = false;
            }

            prevEmptyPos = i;
        }
        else {
            bFoundText = true;
        }
    }

    if (bFoundText && i == il) {
        if (prevEmptyPos + 1 == i - 1) {
            out += (prevEmptyPos + 1 + 1).toString() + ' ' + text.substr(prevEmptyPos + 1, i - 1 - prevEmptyPos) + ', ';
        }
        else {
            out += (prevEmptyPos + 1 + 1).toString() + '-' + (i - 1 + 1).toString() + ' ' + text.substr(prevEmptyPos + 1, i - 1 - prevEmptyPos) + ', ';
        }
    }

    return out;
}

iCn3DUI.prototype.clickAddTrackButton = function () {
    var me = this;
    // ncbi gi
    $(document).on('click', "#" + me.pre + "addtrack_button1", function (e) {
        e.stopImmediatePropagation();

        //e.preventDefault();
        dialog.dialog("close");

        var chainid = $("#" + me.pre + "track_chainid").val();

        var gi = $("#" + me.pre + "track_gi").val().toUpperCase();
        var title = (isNaN(gi)) ? 'Acc ' + gi : 'gi ' + gi;

        //var text = $("#" + me.pre + "track_text").val();
        var url = 'https://www.ncbi.nlm.nih.gov/Structure/pwaln/pwaln.fcgi?fmt';
        $.ajax({
            url: url,
            type: 'POST',
            data: { 'targets': chainid, 'queries': gi },
            dataType: 'jsonp',
            tryCount: 0,
            retryLimit: 1,
            success: function (data) {
                var query, target;

                if (data.data !== undefined) {
                    query = data.data[0].query;
                    target = data.data[0].targets[chainid];
                }

                var text = '';

                if (query !== undefined && query.to > 0 && target !== undefined) {
                    var queryStart = query.start;
                    var queryEnd = query.end;

                    var targetStart = target.start;
                    var targetEnd = target.end;

                    // two sequences are combined to determine the start and end
                    var offset = targetStart - queryStart;

                    var from = (targetStart < queryStart) ? query.from : query.from - offset;
                    var to = (targetStart < queryStart) ? query.to : query.to - offset;

                    var evalue = target.scores.e_value.toPrecision(2);
                    if (evalue > 1e-200) evalue = parseFloat(evalue).toExponential();
                    //if(evalue.length > 10) evalue = evalue.substr(0, 10);

                    var bitscore = target.scores.bit_score;

                    var seq = target.seqdata;
                    var querySeq = query.seqdata;

                    // the missing residuesatthe end ofthe seq will be filled up in the API showNewTrack()
                    for (var i = 0, il = seq.length; i < il && i <= to; ++i) {
                        if (i < from) {
                            text += '-';
                        }
                        else {
                            //text += seq[i];
                            text += querySeq[i + offset];
                        }
                    }

                    //title += ' (eval: ' + evalue + ')';
                    title += ', E: ' + evalue;
                }
                else {
                    text += "cannot be aligned";
                }

                me.showNewTrack(chainid, title, text);

                me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + me.simplifyText(text), true);
            },
            error: function (xhr, textStatus, errorThrown) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }
                return;
            }
        });
    });

    // FASTA
    $(document).on('click', "#" + me.pre + "addtrack_button2", function (e) {
        e.stopImmediatePropagation();
        //e.preventDefault();
        dialog.dialog("close");

        var chainid = $("#" + me.pre + "track_chainid").val();

        var fasta = $("#" + me.pre + "track_fasta").val();
        var title = 'fasta ' + fasta.substr(0, 5);

        //var text = $("#" + me.pre + "track_text").val();
        var url = 'https://www.ncbi.nlm.nih.gov/Structure/pwaln/pwaln.fcgi?fmt';
        $.ajax({
            url: url,
            type: 'POST',
            data: { 'targets': chainid, 'queries': fasta },
            dataType: 'jsonp',
            tryCount: 0,
            retryLimit: 1,
            success: function (data) {
                var query, target;

                if (data.data !== undefined) {
                    query = data.data[0].query;
                    target = data.data[0].targets[chainid];
                }

                var text = '';

                if (query !== undefined && query.to > 0 && target !== undefined) {
                    var queryStart = query.start;
                    var queryEnd = query.end;

                    var targetStart = target.start;
                    var targetEnd = target.end;

                    // two sequences are combined to determine the start and end
                    var offset = targetStart - queryStart;

                    var from = (targetStart < queryStart) ? query.from : query.from - offset;
                    var to = (targetStart < queryStart) ? query.to : query.to - offset;

                    var evalue = target.scores.e_value.toPrecision(2);
                    if (evalue > 1e-200) evalue = parseFloat(evalue).toExponential();
                    //                  if(evalue.length > 10) evalue = evalue.substr(0, 10);

                    var bitscore = target.scores.bit_score;

                    var seq = target.seqdata;
                    var querySeq = query.seqdata;

                    // the missing residuesatthe end ofthe seq will be filled up in the API showNewTrack()
                    for (var i = 0, il = seq.length; i < il && i <= to; ++i) {
                        if (i < from) {
                            text += '-';
                        }
                        else {
                            //text += seq[i];
                            text += querySeq[i + offset];
                        }
                    }

                    //title += ' (eval: ' + evalue + ')';
                    title += ', E: ' + evalue;
                }
                else {
                    text += "cannot be aligned";
                }

                me.showNewTrack(chainid, title, text);

                me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + me.simplifyText(text), true);
            },
            error: function (xhr, textStatus, errorThrown) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }
                return;
            }
        });
    });

    // BED file
    $(document).on('click', "#" + me.pre + "addtrack_button3", function (e) {
        e.stopImmediatePropagation();
        //e.preventDefault();
        dialog.dialog("close");

        var chainid = $("#" + me.pre + "track_chainid").val();


        var file = $("#" + me.pre + "track_bed")[0].files[0];

        if (!file) {
            alert("Please select a file...");
        }
        else {
            if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
            }

            var reader = new FileReader();
            reader.onload = function (e) {
                var dataStr = e.target.result; // or = reader.result;

                var lineArray = dataStr.split('\n');

                var bItemRgb = false, bColorByStrand = false;
                var strandRgbArray;
                for (var i = 0, il = lineArray.length; i < il; ++i) {
                    if (lineArray[i].substr(0, 7) == 'browser') continue;

                    if (lineArray[i].substr(0, 5) == 'track') {
                        if (lineArray[i].toLowerCase().indexOf('itemrgb') != -1) bItemRgb = true;
                        if (lineArray[i].toLowerCase().indexOf('colorbystrand=') != -1) {
                            bColorByStrand = true;

                            //e.g., colorByStrand="255,0,0 0,0,255"
                            var pos = lineArray[i].toLowerCase().indexOf('colorbystrand=');
                            var restStr = lineArray[i].substr(pos);
                            var quotePos = restStr.indexOf('"');
                            if (quotePos != -1) {
                                var quoteStr = restStr.substr(quotePos + 1);
                                var quotePos2 = quoteStr.indexOf('"');
                                if (quotePos != -1) {
                                    var colorList = quoteStr.substr(0, quotePos2);
                                    strandRgbArray = colorList.split(' ');
                                }
                            }

                        }
                    }
                    else { // tracks
                        if (lineArray[i] == '') continue;
                        var fieldArray = lineArray[i].replace(/\s+/g, ' ').split(' ');

                        if (fieldArray.length > 8 || fieldArray.length < 6) bColorByStrand = false;
                        if (fieldArray.length < 9) bItemRgb = false;

                        //https://genome.ucsc.edu/FAQ/FAQformat.html#format1
                        var chromName = fieldArray[0];
                        var chromStart = fieldArray[1];
                        var chromEnd = fieldArray[2];
                        var trackName = fieldArray[3];

                        if (fieldArray.length > 4) var score = fieldArray[4];
                        if (fieldArray.length > 5) var strand = fieldArray[5]; // ., +, or -
                        if (fieldArray.length > 6) var thickStart = fieldArray[6];
                        if (fieldArray.length > 7) var thickEnd = fieldArray[7];
                        if (fieldArray.length > 8) var itemRgb = fieldArray[8];
                        if (fieldArray.length > 9) var blockCount = fieldArray[9];
                        if (fieldArray.length > 10) var blockSizes = fieldArray[10];
                        if (fieldArray.length > 11) var blockStarts = fieldArray[11];

                        var title = trackName;

                        var rgbColor = '51,51,51';
                        if (bItemRgb) {
                            rgbColor = itemRgb;
                        }
                        else if (bColorByStrand) {
                            if (strand == '+' && strandRgbArray.length > 0) {
                                rgbColor = strandRgbArray[0];
                            }
                            else if (strand == '-' && strandRgbArray.length > 1) {
                                rgbColor = strandRgbArray[1];
                            }
                            else if (strand == '.' && strandRgbArray.length > 2) {
                                rgbColor = strandRgbArray[2];
                            }
                        }

                        var text = '';
                        var cssColorArray = [];
                        for (var j = 0, jl = chromEnd; j < jl; ++j) {
                            if (j < chromStart) {
                                text += '-';
                                cssColorArray.push('');
                            }
                            else {
                                text += me.giSeq[chainid][j];
                                cssColorArray.push('rgb(' + rgbColor + ')');
                            }
                        }

                        me.showNewTrack(chainid, title, text, cssColorArray);

                        me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + me.simplifyText(text), true);
                    }
                }
            };

            reader.readAsText(file);
        }
    });

    // custom
    $(document).on('click', "#" + me.pre + "addtrack_button4", function (e) {
        e.stopImmediatePropagation();
        //e.preventDefault();
        dialog.dialog("close");

        var chainid = $("#" + me.pre + "track_chainid").val();
        var title = $("#" + me.pre + "track_title").val();
        var text = $("#" + me.pre + "track_text").val(); // input simplifyText

        //me.showNewTrack(chainid, title, text);
        //me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + me.simplifyText(text), true);

        me.showNewTrack(chainid, title, me.getFullText(text));
        me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + text, true);
    });

    // current selection
    $(document).on('click', "#" + me.pre + "addtrack_button5", function (e) {
        e.stopImmediatePropagation();
        //e.preventDefault();
        dialog.dialog("close");

        var chainid = $("#" + me.pre + "track_chainid").val();
        var title = $("#" + me.pre + "track_selection").val();
        var text = '';

        var selectedAtoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.chains[chainid]);

        var residueHash = me.icn3d.getResiduesFromAtoms(selectedAtoms);

        var cssColorArray = [];
        for (var i = 0, il = me.giSeq[chainid].length; i < il; ++i) {
            var cFull = me.giSeq[chainid][i];

            var c = cFull;
            if (cFull.length > 1) {
                //c = cFull[0] + '..';
                c = cFull[0]; // one letter for each residue
            }

            var pos = (i >= me.matchedPos[chainid] && i - me.matchedPos[chainid] < me.icn3d.chainsSeq[chainid].length) ? me.icn3d.chainsSeq[chainid][i - me.matchedPos[chainid]].resi : me.baseResi[chainid] + 1 + i;

            if (residueHash.hasOwnProperty(chainid + '_' + pos)) {
                var atom = me.icn3d.getFirstAtomObj(me.icn3d.residues[chainid + '_' + pos]);
                var color = atom.color.getHexString();

                text += c;
                cssColorArray.push('#' + color);
            }
            else {
                text += '-';
                cssColorArray.push('');
            }
        }

        me.showNewTrack(chainid, title, text, cssColorArray);

        me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + me.simplifyText(text), true);
    });

};

iCn3DUI.prototype.showNewTrack = function (chnid, title, text, cssColorArray) {
    var me = this;
    //if(me.customTracks[chnid] === undefined) {
    //    me.customTracks[chnid] = {};
    //}

    var bErrorMess = false;
    if (text == 'cannot be aligned') {
        bErrorMess = true;
    }

    var textForCnt = text.replace(/-/g, '');
    var resCnt = textForCnt.length;
    if (resCnt > me.giSeq[chnid].length) {
        resCnt = me.giSeq[chnid].length;
    }

    if (text.length > me.giSeq[chnid].length) {
        text = text.substr(0, me.giSeq[chnid].length);
    }
    else if (text.length < me.giSeq[chnid].length && !bErrorMess) {
        // .fill is not supported in IE
        //var extra = Array(me.giSeq[chnid].length - text.length).fill(' ').join('');
        var extra = '';
        for (var i = 0, il = me.giSeq[chnid].length - text.length; i < il; ++i) {
            extra += '-';
        }

        text += extra;
    }

    var simpTitle = title.replace(/\s/g, '_').replace(/\./g, 'dot').replace(/\W/g, '');
    if (simpTitle.length > 20) simpTitle = simpTitle.substr(0, 20);

    //me.customTracks[chnid][simpTitle] = text;

    var divLength = me.RESIDUE_WIDTH * text.length + 200;

    $("#" + me.pre + "dt_custom_" + chnid).append("<div id='" + me.pre + "dt_custom_" + chnid + "_" + simpTitle + "'></div>");
    $("#" + me.pre + "dt_custom_" + chnid + "_" + simpTitle).width(divLength);

    $("#" + me.pre + "ov_custom_" + chnid).append("<div id='" + me.pre + "ov_custom_" + chnid + "_" + simpTitle + "'></div>");
    $("#" + me.pre + "ov_custom_" + chnid + "_" + simpTitle).width(divLength);

    $("#" + me.pre + "tt_custom_" + chnid).append("<div id='" + me.pre + "tt_custom_" + chnid + "_" + simpTitle + "'></div>");
    $("#" + me.pre + "tt_custom_" + chnid + "_" + simpTitle).width(divLength);

    var html = '<div id="' + me.pre + 'giseq_sequence" class="icn3d-dl_sequence">';
    var html2 = html;
    var html3 = html;

    //var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" gi="' + chnid + '" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;">' + title + '</span></div>';
    var htmlTmp2 = '<div class="icn3d-seqTitle" gi="' + chnid + '" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;">' + title + '</span></div>';
    var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Pos</span>';

    html3 += htmlTmp2 + htmlTmp3 + '<br>';

    var htmlTmp = '<span class="icn3d-seqLine">';

    html += htmlTmp2 + htmlTmp3 + htmlTmp;
    html2 += htmlTmp2 + htmlTmp3 + htmlTmp;

    //var pre ='cst' + me.customTracks[chnid].length;
    var posTmp = chnid.indexOf('_');
    var pre = 'cst' + chnid.substr(posTmp);

    var prevEmptyWidth = 0;
    var prevLineWidth = 0;
    var widthPerRes = 1;

    for (var i = 0, il = text.length; i < il; ++i) {
        var c = text.charAt(i);

        if (c != ' ' && c != '-') {
            //var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
            var pos = me.icn3d.chainsSeq[chnid][i].resi - me.matchedPos[chnid];

            if (cssColorArray !== undefined && cssColorArray[i] != '') {
                html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue" style="color:' + cssColorArray[i] + '">' + c + '</span>';
            }
            else {
                html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + c + '</span>';
            }

            var emptyWidth = parseInt(me.seqAnnWidth * i / me.maxAnnoLength - prevEmptyWidth - prevLineWidth);
            if (emptyWidth < 0) emptyWidth = 0;

            html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;"></div>';
            if (cssColorArray !== undefined && cssColorArray[i] != '') {
                html2 += '<div style="display:inline-block; background-color:' + cssColorArray[i] + '; width:' + widthPerRes + 'px;" title="' + c + (i + 1).toString() + '">&nbsp;</div>';
            }
            else {
                html2 += '<div style="display:inline-block; background-color:#333; width:' + widthPerRes + 'px;" title="' + c + (i + 1).toString() + '">&nbsp;</div>';
            }

            prevEmptyWidth += emptyWidth;
            prevLineWidth += widthPerRes;
        }
        else {
            if (bErrorMess) {
                html += '<span>' + c + '</span>';
            }
            else {
                html += '<span>-</span>';
            }
        }
    }
    var htmlTmp = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Pos</span>';
    htmlTmp += '</span>';
    htmlTmp += '<br>';

    htmlTmp += '</div>';

    html += htmlTmp;
    html2 += htmlTmp;

    html3 += '</div>';

    $("#" + me.pre + "dt_custom_" + chnid + "_" + simpTitle).html(html);
    $("#" + me.pre + "ov_custom_" + chnid + "_" + simpTitle).html(html2);
    $("#" + me.pre + "tt_custom_" + chnid + "_" + simpTitle).html(html3);
};

iCn3DUI.prototype.checkGiSeq = function (chainid, title, text, index) {
    var me = this;
    if (index > 20) return false;

    if (me.giSeq !== undefined && me.giSeq[chainid] !== undefined) {
        text = me.getFullText(text);
        me.showNewTrack(chainid, title, text);
        return false;
    }

    // wait for me.giSeq to be available
    setTimeout(function () { me.checkGiSeq(chainid, title, text, index + 1); }, 100);
};

iCn3DUI.prototype.getFullText = function (text) {
    var me = this;
    var out = '';

    var textArray = text.split(',');
    var lastTextPos = -1;
    for (var i = 0, il = textArray.length; i < il; ++i) {
        var eachText = textArray[i].trim();
        if (eachText.length == 0) continue;

        var range_text = eachText.split(' ');
        if (range_text.length !== 2) continue;

        var rangeText = range_text[1];
        var start_end = range_text[0].split('-');

        var start, end;
        if (start_end.length == 2) {
            start = start_end[0] - 1; // 1-based
            end = start_end[1] - 1;
        }
        else if (start_end.length == 1) {
            start = start_end[0] - 1;
            end = start;
        }
        else {
            continue;
        }

        // previous empty text
        for (var j = 0; j < start - lastTextPos - 1; ++j) {
            out += '-';
        }

        var range = end - start + 1;

        if (rangeText.length > range) {
            out += rangeText.substr(0, range);
        }
        else {
            out += rangeText;
        }

        // fill up rangeText
        for (var j = 0; j < range - rangeText.length; ++j) {
            out += '-';
        }

        lastTextPos = end;
    }

    return out;
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.clickShow_selected = function () {
    var me = this;
    $("#" + me.pre + "show_selected").add("#" + me.pre + "mn2_show_selected").click(function (e) {
        //me.setLogCmd("show selection", true);

        me.showSelection();
        me.setLogCmd("show selection", true);
    });
};

iCn3DUI.prototype.showSelection = function (id) {
    var me = this;
    me.icn3d.dAtoms = {};

    me.icn3d.dAtoms = me.icn3d.cloneHash(me.icn3d.hAtoms);

    var centerAtomsResults = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.dAtoms));
    me.icn3d.maxD = centerAtomsResults.maxD;
    if (me.icn3d.maxD < 5) me.icn3d.maxD = 5;

    //show selected rotationcenter
    me.icn3d.opts['rotationcenter'] = 'display center';
    me.icn3d.opts['hbonds'] = 'no';
    me.icn3d.opts['ssbonds'] = 'no';

    me.icn3d.lines['hbond'] = [];
    me.icn3d.lines['ssbond'] = [];

    me.saveSelectionIfSelected();

    me.icn3d.draw();

    me.update2DdgmContent();
    me.updateHl2D();

    // show selected chains in annotation window
    me.showAnnoSelectedChains();
};

iCn3DUI.prototype.clickModeswitch = function () {
    var me = this;
    $("#" + me.pre + "modeswitch").click(function (e) {
        if ($("#" + me.pre + "modeswitch")[0].checked) { // mode: selection
            me.setModeAndDisplay('selection');
        }
        else { // mode: all
            me.setModeAndDisplay('all');
        }
    });

    $("#" + me.pre + "mn6_modeall").click(function (e) {
        me.setModeAndDisplay('all');
    });

    $("#" + me.pre + "mn6_modeselection").click(function (e) {
        me.setModeAndDisplay('selection');
    });
};

iCn3DUI.prototype.selectAll = function () {
    var me = this;
    me.icn3d.hAtoms = {};

    for (var i in me.icn3d.chains) {
        me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[i]);
        me.icn3d.dAtoms = me.icn3d.unionHash(me.icn3d.dAtoms, me.icn3d.chains[i]);
    }

    me.icn3d.removeHlObjects();
    me.removeHl2D();
    me.removeHlMenus();

    me.bSelectResidue = false;
    me.bSelectAlignResidue = false;

    me.removeSeqResidueBkgd();
    me.update2DdgmContent();

    // show annotations for all protein chains
    $("#" + me.pre + "dl_annotations > .icn3d-annotation").show();

    me.setMode('all');
};

iCn3DUI.prototype.setModeAndDisplay = function (mode) {
    var me = this;
    if (mode === 'all') { // mode all
        me.setMode('all');

        // remember previous selection
        me.icn3d.prevHighlightAtoms = me.icn3d.cloneHash(me.icn3d.hAtoms);

        // select all
        me.setLogCmd("set mode all", true);

        me.selectAll();

        me.icn3d.draw();
    }
    else { // mode selection
        me.setMode('selection');

        // get the previous hAtoms
        if (me.icn3d.prevHighlightAtoms !== undefined) {
            me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.prevHighlightAtoms);
        }
        else {
            me.selectAll();
        }

        me.setLogCmd("set mode selection", true);

        me.updateHlAll();
    }
};

iCn3DUI.prototype.setMode = function (mode) {
    var me = this;
    if (mode === 'all') { // mode all
        // set text
        $("#" + me.pre + "modeall").show();
        $("#" + me.pre + "modeselection").hide();

        $("#" + me.pre + "modeswitch")[0].checked = false;

        if ($("#" + me.pre + "style").hasClass('icn3d-modeselection')) $("#" + me.pre + "style").removeClass('icn3d-modeselection');
        if ($("#" + me.pre + "color").hasClass('icn3d-modeselection')) $("#" + me.pre + "color").removeClass('icn3d-modeselection');
        //if($("#" + me.pre + "surface").hasClass('icn3d-modeselection')) $("#" + me.pre + "surface").removeClass('icn3d-modeselection');
    }
    else { // mode selection
        //if(Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) {
        // set text
        $("#" + me.pre + "modeall").hide();
        $("#" + me.pre + "modeselection").show();

        $("#" + me.pre + "modeswitch")[0].checked = true;

        if (!$("#" + me.pre + "style").hasClass('icn3d-modeselection')) $("#" + me.pre + "style").addClass('icn3d-modeselection');
        if (!$("#" + me.pre + "color").hasClass('icn3d-modeselection')) $("#" + me.pre + "color").addClass('icn3d-modeselection');
        //if(!$("#" + me.pre + "surface").hasClass('icn3d-modeselection')) $("#" + me.pre + "surface").addClass('icn3d-modeselection');

        // show selected chains in annotation window
        //me.showAnnoSelectedChains();
        //}
    }
};

iCn3DUI.prototype.saveSelection = function (name, description) {
    var me = this;
    me.selectedResidues = {};

    for (var i in me.icn3d.hAtoms) {
        if (me.icn3d.hAtoms[i] !== undefined) {
            var residueid = me.icn3d.atoms[i].structure + '_' + me.icn3d.atoms[i].chain + '_' + me.icn3d.atoms[i].resi;
            me.selectedResidues[residueid] = 1;
        }
    }

    me.selectResidueList(me.selectedResidues, name, description);
    me.updateHlAll();

    me.updateSelectionNameDesc();

    //me.setLogCmd('select ' + me.residueids2spec(Object.keys(me.selectedResidues)) + ' | name ' + name + ' | description ' + description, true);
    me.setLogCmd('select ' + me.residueids2spec(Object.keys(me.selectedResidues)) + ' | name ' + name, true);
};

iCn3DUI.prototype.removeSelection = function () {
    var me = this;
    if (!me.bAnnotations) {
        me.removeSeqChainBkgd();
    }
    //else {
    //    me.removeSeqChainBkgd();
    //}

    if (!me.icn3d.bCtrl && !me.icn3d.bShift) {
        me.removeSeqResidueBkgd();

        me.removeSeqChainBkgd();
    }

    //      me.removeSeqChainBkgd();
    //      me.removeSeqResidueBkgd();

    me.selectedResidues = {};
    me.icn3d.hAtoms = {};

    me.icn3d.removeHlObjects();

    me.removeHl2D();
};

iCn3DUI.prototype.updateSelectionNameDesc = function () {
    var me = this;
    var numDef = Object.keys(me.icn3d.defNames2Residues).length + Object.keys(me.icn3d.defNames2Atoms).length;

    $("#" + me.pre + "seq_command_name").val("seq_" + numDef);
    //$("#" + me.pre + "seq_command_desc").val("seq_desc_" + numDef);

    $("#" + me.pre + "seq_command_name2").val("seq_" + numDef);
    //$("#" + me.pre + "seq_command_desc2").val("seq_desc_" + numDef);

    $("#" + me.pre + "alignseq_command_name").val("alseq_" + numDef);
    //$("#" + me.pre + "alignseq_command_desc").val("alseq_desc_" + numDef);
};

iCn3DUI.prototype.selectAChain = function (chainid, commandname, bAlign, bUnion) {
    var me = this;
    var commandname = commandname.replace(/\s/g, '');
    var command = 'select chain ' + chainid;

    //var residueHash = {}, chainHash = {};

    if (bUnion === undefined || !bUnion) {
        me.icn3d.hAtoms = {};
        me.menuHlHash = {};
    }
    else {
        // update residueHash from me.icn3d.hAtoms
        //residueHash = me.icn3d.getResiduesFromAtoms(me.icn3d.hAtoms);

        // update chainHash from me.icn3d.hAtoms
        //chainHash = me.icn3d.getChainsFromAtoms(me.icn3d.hAtoms);

        me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[chainid]);

        if (me.menuHlHash === undefined) me.menuHlHash = {};
    }

    me.menuHlHash[chainid] = 1;

    //chainHash[chainid] = 1;

    var chnsSeq = (bAlign) ? me.icn3d.alnChainsSeq[chainid] : me.icn3d.chainsSeq[chainid];

    var oriResidueHash = {};
    for (var i = 0, il = chnsSeq.length; i < il; ++i) { // get residue number
        var resObj = chnsSeq[i];
        var residueid = chainid + "_" + resObj.resi;

        var value = resObj.name;

        if (value !== '' && value !== '-') {
            oriResidueHash[residueid] = 1;
            for (var j in me.icn3d.residues[residueid]) {
                me.icn3d.hAtoms[j] = 1;
            }
        }
    }

    if ((me.icn3d.defNames2Atoms === undefined || !me.icn3d.defNames2Atoms.hasOwnProperty(chainid)) && (me.icn3d.defNames2Residues === undefined || !me.icn3d.defNames2Residues.hasOwnProperty(chainid))) {
        me.addCustomSelection(Object.keys(oriResidueHash), commandname, commandname, command, true);
    }

    if (bAlign) {
        me.updateHlAll(undefined, undefined, bUnion);
    }
    else {
        me.updateHlAll(Object.keys(me.menuHlHash), undefined, bUnion);
    }

    //        me.icn3d.addHlObjects();
    //        me.updateHl2D(Object.keys(chainHash));
};

iCn3DUI.prototype.selectResidueList = function (residueHash, commandname, commanddescr, bUnion, bUpdateHighlight) {
    var me = this;
    if (Object.keys(residueHash).length > 0) {
        var chainHash = {};
        if (bUnion === undefined || !bUnion) {
            me.icn3d.hAtoms = {};
            me.menuHlHash = {};
        }
        else {
            if (me.menuHlHash === undefined) me.menuHlHash = {};
        }

        for (var i in residueHash) {
            for (var j in me.icn3d.residues[i]) {
                me.icn3d.hAtoms[j] = 1;
            }
        }

        var commandname = commandname.replace(/\s/g, '');

        me.menuHlHash[commandname] = 1;

        var select = "select " + me.residueids2spec(Object.keys(residueHash));

        var oriResidueArray = Object.keys(residueHash);

        //if( (me.icn3d.defNames2Atoms === undefined || !me.icn3d.defNames2Atoms.hasOwnProperty(commandname)) && (me.icn3d.defNames2Residues === undefined || !me.icn3d.defNames2Residues.hasOwnProperty(commandname)) ) {
        me.addCustomSelection(oriResidueArray, commandname, commanddescr, select, true);
        //}

        if (bUpdateHighlight === undefined || bUpdateHighlight) me.updateHlAll(Object.keys(me.menuHlHash), undefined, bUnion);
    }
};

iCn3DUI.prototype.addCustomSelection = function (residueAtomArray, commandname, commanddesc, select, bSelectResidues) {
    var me = this;
    if (bSelectResidues) {
        me.icn3d.defNames2Residues[commandname] = residueAtomArray;
    }
    else {
        me.icn3d.defNames2Atoms[commandname] = residueAtomArray;
    }

    me.icn3d.defNames2Command[commandname] = select;
    me.icn3d.defNames2Descr[commandname] = commanddesc;

    me.updateHlMenus([commandname]);
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.clickCommand_apply = function () {
    var me = this;
    $("#" + me.pre + "command_apply").click(function (e) {
        e.preventDefault();

        var select = $("#" + me.pre + "command").val();
        var commandname = $("#" + me.pre + "command_name").val().replace(/;/g, '_').replace(/\s+/g, '_');
        //var commanddesc = $("#" + me.pre + "command_desc").val().replace(/;/g, '_').replace(/\s+/g, '_');

        me.selectByCommand(select, commandname, commandname);
        //me.setLogCmd('select ' + select + ' | name ' + commandname + ' | description ' + commanddesc, true);
        me.setLogCmd('select ' + select + ' | name ' + commandname, true);
    });
};

iCn3DUI.prototype.selectByCommand = function (select, commandname, commanddesc) {
    var me = this;
    var selectTmp = select.replace(/ AND /g, ' and ').replace(/ OR /g, ' or ').replace(/ or and /g, ' and ').replace(/ and /g, ' or and ').replace(/ or not /g, ' not ').replace(/ not /g, ' or not ');

    var commandStr = (selectTmp.trim().substr(0, 6) === 'select') ? selectTmp.trim().substr(7) : selectTmp.trim();

    // each select command may have several commands separated by ' or '
    var commandArray = commandStr.split(' or ');
    var allHighlightAtoms = {};

    for (var i = 0, il = commandArray.length; i < il; ++i) {
        var command = commandArray[i].trim().replace(/\s+/g, ' ');
        var pos = command.indexOf(' ');

        me.icn3d.hAtoms = {};

        if (command.substr(0, pos).toLowerCase() === 'and') { // intersection
            me.applyCommand('select ' + command.substr(pos + 1));

            allHighlightAtoms = me.icn3d.intHash(allHighlightAtoms, me.icn3d.hAtoms);
        }
        else if (command.substr(0, pos).toLowerCase() === 'not') { // negation
            me.applyCommand('select ' + command.substr(pos + 1));

            allHighlightAtoms = me.icn3d.exclHash(allHighlightAtoms, me.icn3d.hAtoms);
        }
        else { // union
            me.applyCommand('select ' + command);

            allHighlightAtoms = me.icn3d.unionHash(allHighlightAtoms, me.icn3d.hAtoms);
        }
    }

    me.icn3d.hAtoms = me.icn3d.cloneHash(allHighlightAtoms);

    var atomArray = Object.keys(me.icn3d.hAtoms);
    //var residueArray = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.hAtoms));
    var residueArray = undefined;

    if (commandname !== "") {
        me.addCustomSelection(atomArray, commandname, commanddesc, select, false);

        var nameArray = [commandname];
        //me.changeCustomResidues(nameArray);

        me.changeCustomAtoms(nameArray);
    }
};

iCn3DUI.prototype.selectBySpec = function (select, commandname, commanddesc, bDisplay) {
    var me = this;
    select = (select.trim().substr(0, 6) === 'select') ? select.trim().substr(7) : select.trim();

    me.icn3d.hAtoms = {};

    // selection definition is similar to Chimera: https://www.cgl.ucsf.edu/chimera/docs/UsersGuide/midas/frameatom_spec.html
    // There will be no ' or ' in the spec. It's already separated in selectByCommand()
    // There could be ' and ' in the spec.
    var commandArray = select.replace(/\s+/g, ' ').replace(/ AND /g, ' and ').split(' and ');

    var residueHash = {};
    var atomHash = {};

    var bSelectResidues = true;
    for (var i = 0, il = commandArray.length; i < il; ++i) {
        //$1,2,3.A,B,C:5-10,LYS,chemicals@CA,C
        // $1,2,3: Structure
        // .A,B,C: chain
        // :5-10,LYS,chemicals: residues, could be 'proteins', 'nucleotides', 'chemicals', 'ions', and 'water'
        // @CA,C: atoms
        // wild card * can be used to select all
        //var currHighlightAtoms = {};

        var dollarPos = commandArray[i].indexOf('$');
        var periodPos = commandArray[i].indexOf('.');
        var colonPos = commandArray[i].indexOf(':');
        var atPos = commandArray[i].indexOf('@');

        var moleculeStr, chainStr, residueStr, atomStr;
        var testStr = commandArray[i];

        if (atPos === -1) {
            atomStr = "*";
        }
        else {
            atomStr = testStr.substr(atPos + 1);
            testStr = testStr.substr(0, atPos);
        }

        if (colonPos === -1) {
            residueStr = "*";
        }
        else {
            residueStr = testStr.substr(colonPos + 1);
            testStr = testStr.substr(0, colonPos);
        }

        if (periodPos === -1) {
            chainStr = "*";
        }
        else {
            chainStr = testStr.substr(periodPos + 1);
            testStr = testStr.substr(0, periodPos);
        }

        if (dollarPos === -1) {
            moleculeStr = "*";
        }
        else {
            moleculeStr = testStr.substr(dollarPos + 1);
            testStr = testStr.substr(0, dollarPos);
        }

        if (atomStr !== '*') {
            bSelectResidues = false; // selected atoms
        }

        var molecule, chain, molecule_chain, moleculeArray = [], Molecule_ChainArray = [], start, end;

        if (moleculeStr === '*') {
            moleculeArray = Object.keys(me.icn3d.structures);
        }
        else {
            moleculeArray = moleculeStr.split(",")
        }

        if (chainStr === '*') {
            var tmpArray = Object.keys(me.icn3d.chains);  // 1_A (molecule_chain)

            for (var j = 0, jl = tmpArray.length; j < jl; ++j) {
                molecule_chain = tmpArray[j];

                molecule = molecule_chain.substr(0, molecule_chain.indexOf('_'));
                if (moleculeArray.toString().toLowerCase().indexOf(molecule.toLowerCase()) !== -1) {
                    Molecule_ChainArray.push(molecule_chain);
                }
            }
        }
        else {
            for (var j = 0, jl = moleculeArray.length; j < jl; ++j) {
                molecule = moleculeArray[j];

                var chainArray = chainStr.split(",");
                for (var k in chainArray) {
                    Molecule_ChainArray.push(molecule + '_' + chainArray[k]);
                }
            }
        }

        var residueStrArray = residueStr.split(',');
        for (var j = 0, jl = residueStrArray.length; j < jl; ++j) {
            var bResidueId = false;

            var hyphenPos = residueStrArray[j].indexOf('-');

            var oneLetterResidueStr;
            var bAllResidues = false;
            var bResidueArray = false;

            if (hyphenPos !== -1) {
                start = residueStrArray[j].substr(0, hyphenPos);
                end = residueStrArray[j].substr(hyphenPos + 1);
                bResidueId = true;
            }
            else {
                if (residueStrArray[j] !== '' && !isNaN(residueStrArray[j])) { // residue id
                    start = residueStrArray[j];
                    end = start;
                    bResidueId = true;
                }
                else if (residueStrArray[j] === '*') { // all resiues
                    bAllResidues = true;
                }
                else if (residueStrArray[j] !== 'proteins' && residueStrArray[j] !== 'nucleotides' && residueStrArray[j] !== 'chemicals' && residueStrArray[j] !== 'ions' && residueStrArray[j] !== 'water') { // residue name
                    var tmpStr = residueStrArray[j].toUpperCase();
                    //oneLetterResidue = (residueStrArray[j].length === 1) ? tmpStr : me.icn3d.residueName2Abbr(tmpStr);
                    oneLetterResidueStr = tmpStr;
                    bResidueArray = true;
                }
            }

            for (var mc = 0, mcl = Molecule_ChainArray.length; mc < mcl; ++mc) {
                molecule_chain = Molecule_ChainArray[mc];

                if (bResidueId) {
                    for (var k = parseInt(start); k <= parseInt(end); ++k) {
                        var residueId = molecule_chain + '_' + k;
                        if (i === 0) {
                            residueHash[residueId] = 1;
                        }
                        else {
                            // if not exit previously, "and" operation will remove this one
                            //if(!residueHash.hasOwnProperty(residueId)) residueHash[residueId] = undefined;
                            if (!residueHash.hasOwnProperty(residueId)) delete residueHash[residueId];
                        }

                        for (var m in me.icn3d.residues[residueId]) {
                            if (atomStr === '*' || atomStr === me.icn3d.atoms[m].name) {
                                if (i === 0) {
                                    //currHighlightAtoms[m] = 1;
                                    atomHash[m] = 1;
                                }
                                else {
                                    //if(!currHighlightAtoms.hasOwnProperty(m)) currHighlightAtoms[m] = undefined;
                                    //if(!atomHash.hasOwnProperty(m)) atomHash[m] = undefined;
                                    if (!atomHash.hasOwnProperty(m)) delete atomHash[m];
                                }
                            }
                        }
                    }
                }
                else {
                    if (molecule_chain in me.icn3d.chains) {
                        var chainAtomHash = me.icn3d.chains[molecule_chain];
                        for (var m in chainAtomHash) {
                            // residue could also be 'proteins', 'nucleotides', 'chemicals', 'ions', and 'water'
                            var tmpStr = me.icn3d.atoms[m].resn.substr(0, 3).toUpperCase();
                            if (bAllResidues
                                //|| me.icn3d.residueName2Abbr(tmpStr) === oneLetterResidue
                                || (residueStrArray[j] === 'proteins' && m in me.icn3d.proteins)
                                || (residueStrArray[j] === 'nucleotides' && m in me.icn3d.nucleotides)
                                || (residueStrArray[j] === 'chemicals' && m in me.icn3d.chemicals)
                                || (residueStrArray[j] === 'ions' && m in me.icn3d.ions)
                                || (residueStrArray[j] === 'water' && m in me.icn3d.water)
                            ) {
                                // many duplicates
                                if (i === 0) {
                                    residueHash[molecule_chain + '_' + me.icn3d.atoms[m].resi] = 1;
                                }
                                else {
                                    var residTmp = molecule_chain + '_' + me.icn3d.atoms[m].resi;
                                    //if(!residueHash.hasOwnProperty(residTmp)) residueHash[residTmp] = undefined;
                                    if (!residueHash.hasOwnProperty(residTmp)) delete residueHash[residTmp];
                                }

                                if (atomStr === '*' || atomStr === me.icn3d.atoms[m].name) {
                                    if (i === 0) {
                                        //currHighlightAtoms[m] = 1;
                                        atomHash[m] = 1;
                                    }
                                    else {
                                        //if(!currHighlightAtoms.hasOwnProperty(m)) currHighlightAtoms[m] = undefined;
                                        //if(!atomHash.hasOwnProperty(m)) atomHash[m] = undefined;
                                        if (!atomHash.hasOwnProperty(m)) delete atomHash[m];
                                    }
                                }

                            }
                        } // end for(var m in atomHash) {

                        if (bResidueArray) {
                            //oneLetterResidueStr.length;
                            var chainSeq = '', resiArray = [];
                            for (var s = 0, sl = me.icn3d.chainsSeq[molecule_chain].length; s < sl; ++s) {
                                chainSeq += (me.icn3d.chainsSeq[molecule_chain][s].name.length == 1) ? me.icn3d.chainsSeq[molecule_chain][s].name : me.icn3d.chainsSeq[molecule_chain][s].name.substr(0, 1);
                                resiArray.push(me.icn3d.chainsSeq[molecule_chain][s].resi);
                            }

                            chainSeq = chainSeq.toUpperCase();

                            var seqReg = oneLetterResidueStr.replace(/x/gi, ".");
                            var posArray = [];

                            var searchReg = new RegExp(seqReg, 'i');

                            var targetStr = chainSeq;
                            var pos = targetStr.search(searchReg);
                            var sumPos = pos;
                            while (pos !== -1) {
                                posArray.push(sumPos);
                                targetStr = targetStr.substr(pos + 1);
                                pos = targetStr.search(searchReg);
                                sumPos += pos + 1;
                            }

                            for (var s = 0, sl = posArray.length; s < sl; ++s) {
                                var pos = posArray[s];

                                for (var t = 0, tl = oneLetterResidueStr.length; t < tl; ++t) {
                                    var residueId = molecule_chain + '_' + resiArray[t + pos];
                                    if (i === 0) {
                                        residueHash[residueId] = 1;
                                    }
                                    else {
                                        //if(!residueHash.hasOwnProperty(residueId)) residueHash[residueId] = undefined;
                                        if (!residueHash.hasOwnProperty(residueId)) delete residueHash[residueId];
                                    }

                                    for (var m in me.icn3d.residues[residueId]) {
                                        if (atomStr === '*' || atomStr === me.icn3d.atoms[m].name) {
                                            if (i === 0) {
                                                //currHighlightAtoms[m] = 1;
                                                atomHash[m] = 1;
                                            }
                                            else {
                                                //if(!currHighlightAtoms.hasOwnProperty(m)) currHighlightAtoms[m] = undefined;
                                                //if(!atomHash.hasOwnProperty(m)) atomHash[m] = undefined;
                                                if (!atomHash.hasOwnProperty(m)) delete atomHash[m];
                                            }
                                        }
                                    }
                                } // for
                            } // end for(s = 0
                        }
                    } // end if(molecule_chain
                } // end else
            } // end for(var mc = 0
        } // for (j
        /*
               if(i === 0) {
                   me.icn3d.hAtoms = me.icn3d.cloneHash(currHighlightAtoms);
               }
               else {
                   me.icn3d.hAtoms = me.icn3d.intHash(me.icn3d.hAtoms, currHighlightAtoms);
               }
        */
    }  // for (i

    me.icn3d.hAtoms = me.icn3d.cloneHash(atomHash);

    if (bDisplay === undefined || bDisplay) me.updateHlAll();

    var residueAtomArray;
    if (bSelectResidues) {
        residueAtomArray = Object.keys(residueHash);
    }
    else {
        residueAtomArray = Object.keys(atomHash);
    }

    //   if(commandname == "") commandname = "tmp_" + select;

    if (commandname != "") {
        me.addCustomSelection(residueAtomArray, commandname, commanddesc, select, bSelectResidues);

        var nameArray = [commandname];
        me.changeCustomAtoms(nameArray);
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.showSets = function () {
    var me = this;
    me.openDialog(me.pre + 'dl_definedsets', 'Select Sets');
    $("#" + me.pre + "atomsCustom").resizable();

    if (me.bSetChainsAdvancedMenu === undefined || !me.bSetChainsAdvancedMenu) {
        me.setPredefinedInMenu();

        me.bSetChainsAdvancedMenu = true;
    }

    me.updateHlMenus();
};

iCn3DUI.prototype.clickCustomAtoms = function () {
    var me = this;
    $("#" + me.pre + "atomsCustom").change(function (e) {
        var nameArray = $(this).val();

        if (nameArray !== null) {
            // log the selection
            //me.setLogCmd('select saved atoms ' + nameArray.toString(), true);

            var bUpdateHlMenus = false;
            me.changeCustomAtoms(nameArray, bUpdateHlMenus);
            me.setLogCmd('select saved atoms ' + nameArray.toString(), true);

            me.bSelectResidue = false;
        }
    });

    $("#" + me.pre + "atomsCustom").focus(function (e) {
        if (me.isMobile()) $("#" + me.pre + "atomsCustom").val("");
    });
};

iCn3DUI.prototype.changeCustomAtoms = function (nameArray, bUpdateHlMenus) {
    var me = this;
    me.icn3d.hAtoms = {};

    //var allResidues = {};
    for (var i = 0; i < nameArray.length; ++i) {
        var selectedSet = nameArray[i];

        if ((me.icn3d.defNames2Atoms === undefined || !me.icn3d.defNames2Atoms.hasOwnProperty(selectedSet)) && (me.icn3d.defNames2Residues === undefined || !me.icn3d.defNames2Residues.hasOwnProperty(selectedSet))) continue;

        //var residueHash = {};
        if (me.icn3d.defNames2Atoms !== undefined && me.icn3d.defNames2Atoms.hasOwnProperty(selectedSet)) {
            var atomArray = me.icn3d.defNames2Atoms[selectedSet];

            for (var j = 0, jl = atomArray.length; j < jl; ++j) {
                //var atom = me.icn3d.atoms[atomArray[j]];
                //var residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                //residueHash[residueid] = 1;
                me.icn3d.hAtoms[atomArray[j]] = 1;
            }
        }

        if (me.icn3d.defNames2Residues !== undefined && me.icn3d.defNames2Residues.hasOwnProperty(selectedSet)) {
            var residueArrayTmp = me.icn3d.defNames2Residues[selectedSet];

            for (var j = 0, jl = residueArrayTmp.length; j < jl; ++j) {
                //residueHash[residueArrayTmp[j]] = 1;
                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[residueArrayTmp[j]]);
            }
        }

        //var residueArray = Object.keys(residueHash);

        //if(residueArray === undefined) continue;

        //for(var j = 0, jl = residueArray.length; j < jl; ++j) {
        //  allResidues[residueArray[j]] = 1;
        //}
    } // outer for

    //me.removeSeqChainBkgd();

    //me.highlightResidues(Object.keys(allResidues));
    me.updateHlAll(nameArray, bUpdateHlMenus);

    // show selected chains in annotation window
    me.showAnnoSelectedChains();

    // clear commmand
    $("#" + me.pre + "command").val("");
    $("#" + me.pre + "command_name").val("");
    //$("#" + me.pre + "command_desc").val("");

    // update the commands in the dialog
    for (var i = 0, il = nameArray.length; i < il; ++i) {
        var atomArray = me.icn3d.defNames2Atoms[nameArray[i]];
        var residueArray = me.icn3d.defNames2Residues[nameArray[i]];
        var atomTitle = me.icn3d.defNames2Descr[nameArray[i]];
        var atomCommand = me.icn3d.defNames2Command[nameArray[i]];

        if (atomCommand === undefined) continue;

        if (atomCommand.indexOf('select ') !== -1) atomCommand = atomCommand.replace(/select /g, '');

        if (i === 0) {
            $("#" + me.pre + "command").val(atomCommand);
            $("#" + me.pre + "command_name").val(nameArray[i]);
            //$("#" + me.pre + "command_desc").val(atomTitle);
        }
        else {
            var prevValue = $("#" + me.pre + "command").val();
            $("#" + me.pre + "command").val(prevValue + " or " + atomCommand);

            var prevValue = $("#" + me.pre + "command_name").val();
            $("#" + me.pre + "command_name").val(prevValue + " or " + nameArray[i]);

            //var prevValue = $("#" + me.pre + "command_desc").val();
            //$("#" + me.pre + "command_desc").val(prevValue + " or " + atomTitle);
        }

        if (atomArray !== undefined) {
            for (var j = 0, jl = atomArray.length; j < jl; ++j) {
                me.icn3d.hAtoms[atomArray[j]] = 1;
            }
        }
        else if (residueArray !== undefined) {
            for (var j = 0, jl = residueArray.length; j < jl; ++j) {
                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[residueArray[j]]);
            }
        }
    } // outer for
};


iCn3DUI.prototype.setProtNuclLigInMenu = function () {
    var me = this;
    for (var chain in me.icn3d.chains) {
        // Initially, add proteins, nucleotides, chemicals, ions, water into the mn "custom selections"
        if (Object.keys(me.icn3d.proteins).length > 0) {
            //me.icn3d.defNames2Atoms['proteins'] = Object.keys(me.icn3d.proteins);
            me.icn3d.defNames2Residues['proteins'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.proteins));
            me.icn3d.defNames2Descr['proteins'] = 'proteins';
            me.icn3d.defNames2Command['proteins'] = 'select :proteins';
        }

        if (Object.keys(me.icn3d.nucleotides).length > 0) {
            //me.icn3d.defNames2Atoms['nucleotides'] = Object.keys(me.icn3d.nucleotides);
            me.icn3d.defNames2Residues['nucleotides'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.nucleotides));
            me.icn3d.defNames2Descr['nucleotides'] = 'nucleotides';
            me.icn3d.defNames2Command['nucleotides'] = 'select :nucleotides';
        }

        if (Object.keys(me.icn3d.chemicals).length > 0) {
            //me.icn3d.defNames2Atoms['chemicals'] = Object.keys(me.icn3d.chemicals);
            me.icn3d.defNames2Residues['chemicals'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.chemicals));
            me.icn3d.defNames2Descr['chemicals'] = 'chemicals';
            me.icn3d.defNames2Command['chemicals'] = 'select :chemicals';
        }

        if (Object.keys(me.icn3d.ions).length > 0) {
            //me.icn3d.defNames2Atoms['ions'] = Object.keys(me.icn3d.ions);
            me.icn3d.defNames2Residues['ions'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.ions));
            me.icn3d.defNames2Descr['ions'] = 'ions';
            me.icn3d.defNames2Command['ions'] = 'select :ions';
        }

        if (Object.keys(me.icn3d.water).length > 0) {
            //me.icn3d.defNames2Atoms['water'] = Object.keys(me.icn3d.water);
            me.icn3d.defNames2Residues['water'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.water));
            me.icn3d.defNames2Descr['water'] = 'water';
            me.icn3d.defNames2Command['water'] = 'select :water';
        }
    }
};

iCn3DUI.prototype.setChainsInMenu = function () {
    var me = this;
    for (var chainid in me.icn3d.chains) {
        // skip chains with one residue/chemical
        if (me.icn3d.chainsSeq[chainid].length > 1) {
            //me.icn3d.defNames2Atoms[chainid] = Object.keys(me.icn3d.chains[chainid]);
            me.icn3d.defNames2Residues[chainid] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.chains[chainid]));
            me.icn3d.defNames2Descr[chainid] = chainid;

            var pos = chainid.indexOf('_');
            var structure = chainid.substr(0, pos);
            var chain = chainid.substr(pos + 1);

            me.icn3d.defNames2Command[chainid] = 'select $' + structure + '.' + chain;
        }
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.loadScript = function (dataStr, bStatefile) {
    var me = this;
    // allow the "loading structure..." message to be shown while loading script
    me.bCommandLoad = true;

    me.icn3d.bRender = false;
    me.icn3d.bStopRotate = true;

    // firebase dynamic links replace " " with "+". So convert it back
    dataStr = dataStr.replace(/\+/g, ' ').replace(/;/g, '\n');

    var preCommands = [];
    if (me.icn3d.commands.length > 0) preCommands[0] = me.icn3d.commands[0];

    me.icn3d.commands = dataStr.split('\n');
    me.STATENUMBER = me.icn3d.commands.length;

    me.icn3d.commands = preCommands.concat(me.icn3d.commands);
    me.STATENUMBER = me.icn3d.commands.length;

    if (bStatefile !== undefined && bStatefile) {
        me.execCommands(0, me.STATENUMBER - 1, me.STATENUMBER);
    }
    else {
        // skip the first loading step
        me.execCommands(1, me.STATENUMBER - 1, me.STATENUMBER);
    }
};

iCn3DUI.prototype.loadSelection = function (dataStr) {
    var me = this;
    var nameCommandArray = dataStr.trim().split('\n');

    for (var i = 0, il = nameCommandArray.length; i < il; ++i) {
        var nameCommand = nameCommandArray[i].split('\t');
        var name = nameCommand[0];
        var command = nameCommand[1];

        var pos = command.indexOf(' '); // select ...

        me.selectByCommand(command.substr(pos + 1), name, name, false);
    }
};

iCn3DUI.prototype.execCommands = function (start, end, steps) {
    var me = this;
    me.icn3d.bRender = false;

    // initialize icn3dui
    //    me.init();
    //    me.icn3d.init();

    // fresh start
    me.icn3d.reinitAfterLoad();

    me.icn3d.opts = me.icn3d.cloneHash(me.opts);

    //me.execCommandsBase(0, steps-1, steps);
    me.execCommandsBase(start, end, steps);
};

iCn3DUI.prototype.execCommandsBase = function (start, end, steps) {
    var me = this;
    for (var i = start; i <= end; ++i) {
        if (me.icn3d.commands[i].indexOf('load') !== -1) {
            if (end === 0 && start === end) {
                if (me.bNotLoadStructure) {
                    me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.atoms);
                    me.icn3d.bRender = true;

                    // end of all commands
                    if (1 === me.icn3d.commands.length) me.bAddCommands = true;
                    me.renderFinalStep(steps);
                }
                else {
                    $.when(me.applyCommandLoad(me.icn3d.commands[i])).then(function () {
                        me.icn3d.bRender = true;

                        // end of all commands
                        if (1 === me.icn3d.commands.length) me.bAddCommands = true;
                        me.renderFinalStep(steps);
                    });
                }
                return;
            }
            else {
                if (me.bNotLoadStructure) {
                    me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.atoms);

                    // undo/redo requires render the first step
                    if (me.backForward !== undefined && me.backForward) me.renderFinalStep(1);

                    me.execCommandsBase(i + 1, end, steps);
                }
                else {
                    $.when(me.applyCommandLoad(me.icn3d.commands[i])).then(function () {
                        // undo/redo requires render the first step
                        if (me.backForward !== undefined && me.backForward) me.renderFinalStep(1);

                        me.execCommandsBase(i + 1, end, steps);
                    });
                }

                return;
            }
        }
        else if (me.icn3d.commands[i].trim().indexOf('view annotations') == 0
            //|| me.icn3d.commands[i].trim().indexOf('set annotation cdd') == 0
            //|| me.icn3d.commands[i].trim().indexOf('set annotation site') == 0
        ) { // the command may have "|||{"factor"...
            var strArray = me.icn3d.commands[i].split("|||");
            if (Object.keys(me.icn3d.proteins).length > 0 && (me.bAjaxCddSite === undefined || !me.bAjaxCddSite)) {
                $.when(me.applyCommandAnnotationsAndCddSite(strArray[0].trim())).then(function () {
                    me.execCommandsBase(i + 1, end, steps);
                });
            }
            else {
                if (Object.keys(me.icn3d.proteins).length == 0) {
                    me.applyCommandAnnotationsAndCddSiteBase(strArray[0].trim());
                }

                me.execCommandsBase(i + 1, end, steps);
            }

            return;
        }
        else if (me.icn3d.commands[i].trim().indexOf('set annotation clinvar') == 0
            || me.icn3d.commands[i].trim().indexOf('set annotation snp') == 0) { // the command may have "|||{"factor"...
            var strArray = me.icn3d.commands[i].split("|||");

            if (Object.keys(me.icn3d.proteins).length > 0 && (me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar)) {
                $.when(me.applyCommandSnpClinvar(strArray[0].trim())).then(function () {
                    me.execCommandsBase(i + 1, end, steps);
                });
            }
            else {
                if (Object.keys(me.icn3d.proteins).length == 0) {
                    me.applyCommandSnpClinvar(strArray[0].trim());
                }

                me.execCommandsBase(i + 1, end, steps);
            }

            return;
        }
        else if (me.icn3d.commands[i].trim().indexOf('set annotation 3ddomain') == 0) { // the command may have "|||{"factor"...
            var strArray = me.icn3d.commands[i].split("|||");

            if (Object.keys(me.icn3d.proteins).length > 0 && me.mmdb_data === undefined && (me.bAjax3ddomain === undefined || !me.bAjax3ddomain)) {
                $.when(me.applyCommand3ddomain(strArray[0].trim())).then(function () {
                    me.execCommandsBase(i + 1, end, steps);
                });
            }
            else {
                if (Object.keys(me.icn3d.proteins).length == 0) {
                    me.applyCommand3ddomain(strArray[0].trim());
                }

                me.execCommandsBase(i + 1, end, steps);
            }

            return;
        }
        else if (me.icn3d.commands[i].trim().indexOf('set annotation all') == 0) { // the command may have "|||{"factor"...
            var strArray = me.icn3d.commands[i].split("|||");
            //$.when(me.applyCommandAnnotationsAndCddSite(strArray[0].trim()))
            //  .then(me.applyCommandSnpClinvar(strArray[0].trim()))

            if (Object.keys(me.icn3d.proteins).length > 0 && (me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar)
                && (me.bAjax3ddomain === undefined || !me.bAjax3ddomain || me.mmdb_data === undefined)) {
                $.when(me.applyCommandSnpClinvar(strArray[0].trim()))
                    .then(me.applyCommand3ddomain(strArray[0].trim()))
                    .then(function () {
                        me.setAnnoTabAll();

                        me.execCommandsBase(i + 1, end, steps);
                    });
            }
            else if (Object.keys(me.icn3d.proteins).length > 0 && (me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar)) {
                $.when(me.applyCommandSnpClinvar(strArray[0].trim()))
                    .then(function () {
                        me.setAnnoTabAll();

                        me.execCommandsBase(i + 1, end, steps);
                    });
            }
            else if (Object.keys(me.icn3d.proteins).length > 0 && (me.bAjax3ddomain === undefined || !me.bAjax3ddomain || me.mmdb_data === undefined)) {
                $.when(me.applyCommand3ddomain(strArray[0].trim()))
                    .then(function () {
                        me.setAnnoTabAll();

                        me.execCommandsBase(i + 1, end, steps);
                    });
            }
            else {
                if (Object.keys(me.icn3d.proteins).length == 0) {
                    if ((me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar)
                        && (me.bAjax3ddomain === undefined || !me.bAjax3ddomain || me.mmdb_data === undefined)) {
                        me.applyCommandSnpClinvarBase(strArray[0].trim());
                        me.applyCommand3ddomainBase(strArray[0].trim());
                    }
                    else if (me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar) {
                        me.applyCommandSnpClinvarBase(strArray[0].trim());
                    }
                    else if (me.bAjax3ddomain === undefined || !me.bAjax3ddomain || me.mmdb_data === undefined) {
                        me.applyCommand3ddomainBase(strArray[0].trim());
                    }
                }

                me.setAnnoTabAll();

                me.execCommandsBase(i + 1, end, steps);
            }

            return;
        }
        else if (me.icn3d.commands[i].trim().indexOf('view interactions') == 0 && me.cfg.align !== undefined) { // the command may have "|||{"factor"...
            var strArray = me.icn3d.commands[i].split("|||");

            if (me.b2DShown === undefined || !me.b2DShown) {
                $.when(me.applyCommandViewinteraction(strArray[0].trim())).then(function () {
                    me.execCommandsBase(i + 1, end, steps);
                });
            }
            else {
                me.execCommandsBase(i + 1, end, steps);
            }

            return;
        }
        else {
            me.applyCommand(me.icn3d.commands[i]);
        }
    }

    //if(i === steps - 1) {
    if (i === steps) {
        // enable me.hideLoading
        me.bCommandLoad = false;

        // hide "loading ..."
        me.hideLoading();

        me.icn3d.bRender = true;

        // end of all commands
        if (i + 1 === me.icn3d.commands.length) me.bAddCommands = true;

        me.renderFinalStep(steps);
    }
};

iCn3DUI.prototype.renderFinalStep = function (steps) {
    var me = this;
    var commandTransformation = me.icn3d.commands[steps - 1].split('|||');

    if (commandTransformation.length == 2) {
        var transformation = JSON.parse(commandTransformation[1]);

        me.icn3d._zoomFactor = transformation.factor;

        me.icn3d.mouseChange.x = transformation.mouseChange.x;
        me.icn3d.mouseChange.y = transformation.mouseChange.y;

        me.icn3d.quaternion._x = transformation.quaternion._x;
        me.icn3d.quaternion._y = transformation.quaternion._y;
        me.icn3d.quaternion._z = transformation.quaternion._z;
        me.icn3d.quaternion._w = transformation.quaternion._w;
    }

    // simple if all atoms are modified
    //if( me.cfg.command === undefined && (steps === 1 || (Object.keys(me.icn3d.hAtoms).length === Object.keys(me.icn3d.atoms).length) || (me.icn3d.optsHistory[steps - 1] !== undefined && me.icn3d.optsHistory[steps - 1].hasOwnProperty('hlatomcount') && me.icn3d.optsHistory[steps - 1].hlatomcount === Object.keys(me.icn3d.atoms).length) ) ) {
    if (steps === 1
        || (Object.keys(me.icn3d.hAtoms).length === Object.keys(me.icn3d.atoms).length)
        || (me.icn3d.optsHistory[steps - 1] !== undefined && me.icn3d.optsHistory[steps - 1].hasOwnProperty('hlatomcount') && me.icn3d.optsHistory[steps - 1].hlatomcount === Object.keys(me.icn3d.atoms).length)) {
        if (steps === 1) {
            // assign styles and color using the options at that stage
            me.icn3d.setAtomStyleByOptions(me.icn3d.optsHistory[steps - 1]);
            me.icn3d.setColorByOptions(me.icn3d.optsHistory[steps - 1], me.icn3d.hAtoms);
        }

        if (me.icn3d.optsHistory.length >= steps) {
            var pkOption = me.icn3d.optsHistory[steps - 1].pk;
            if (pkOption === 'no') {
                me.icn3d.pk = 0;
            }
            else if (pkOption === 'atom') {
                me.icn3d.pk = 1;
            }
            else if (pkOption === 'residue') {
                me.icn3d.pk = 2;
            }
            else if (pkOption === 'strand') {
                me.icn3d.pk = 3;
            }

            if (steps === 1) {
                me.icn3d.applyOriginalColor();
            }

            me.updateHlAll();

            jQuery.extend(me.icn3d.opts, me.icn3d.optsHistory[steps - 1]);
            me.icn3d.draw();
        }
        else {
            me.updateHlAll();

            me.icn3d.draw();
        }
    }
    else { // more complicated if partial atoms are modified
        me.icn3d.draw();
    }
};

iCn3DUI.prototype.applyCommandLoad = function (commandStr) {
    var me = this;
    //me.bCommandLoad = true;

    // chain functions together
    me.deferred2 = $.Deferred(function () {
        me.bAddCommands = false;
        var commandTransformation = commandStr.split('|||');

        var commandOri = commandTransformation[0].replace(/\s\s/g, ' ').trim();
        var command = commandOri.toLowerCase();

        if (command.indexOf('load') !== -1) { // 'load pdb [pdbid]'
            var load_parameters = command.split(' | ');

            var loadStr = load_parameters[0];
            if (load_parameters.length > 1) {
                var firstSpacePos = load_parameters[load_parameters.length - 1].indexOf(' ');
                me.cfg.inpara = load_parameters[load_parameters.length - 1].substr(firstSpacePos + 1);
                if (me.cfg.inpara === 'undefined') {
                    me.cfg.inpara = '';
                }
            }

            // load pdb, mmcif, mmdb, cid
            var id = loadStr.substr(loadStr.lastIndexOf(' ') + 1);
            me.inputid = id;
            if (command.indexOf('load mmtf') !== -1) {
                me.cfg.mmtfid = id;
                me.downloadMmtf(id);
            }
            else if (command.indexOf('load pdb') !== -1) {
                me.cfg.pdbid = id;
                me.downloadPdb(id);
            }
            else if (command.indexOf('load mmcif') !== -1) {
                me.cfg.mmcifid = id;
                me.downloadMmcif(id);
            }
            else if (command.indexOf('load mmdb') !== -1) {
                me.cfg.mmdbid = id;
                me.downloadMmdb(id);
            }
            else if (command.indexOf('load gi') !== -1) {
                me.cfg.gi = id;
                me.downloadGi(id);
            }
            else if (command.indexOf('load cid') !== -1) {
                me.cfg.cid = id;
                me.downloadCid(id);
            }
            else if (command.indexOf('load align') !== -1) {
                me.cfg.align = id;
                me.downloadAlignment(id);
            }
            else if (command.indexOf('load url') !== -1) {
                var typeStr = load_parameters[1]; // type pdb
                var pos = (typeStr !== undefined) ? typeStr.indexOf('type ') : -1;
                var type = 'pdb';

                if (pos !== -1) {
                    type = typeStr.substr(pos + 5);
                }

                me.cfg.url = id;
                me.downloadUrl(id, type);
            }
        }

        me.bAddCommands = true;
    }); // end of me.deferred = $.Deferred(function() {

    return me.deferred2.promise();
};

iCn3DUI.prototype.applyCommandAnnotationsAndCddSiteBase = function (command) {
    var me = this;
    // chain functions together
    if (command == "view annotations") {
        if (me.cfg.showanno === undefined || !me.cfg.showanno) {
            me.showAnnotations();
        }
    }
};

iCn3DUI.prototype.applyCommandAnnotationsAndCddSite = function (command) {
    var me = this;
    // chain functions together
    me.deferredAnnoCddSite = $.Deferred(function () {
        me.applyCommandAnnotationsAndCddSiteBase(command);
    }); // end of me.deferred = $.Deferred(function() {

    return me.deferredAnnoCddSite.promise();
};

iCn3DUI.prototype.applyCommandSnpClinvarBase = function (command) {
    var me = this;
    // chain functions together
    var pos = command.lastIndexOf(' '); // set annotation clinvar
    var type = command.substr(pos + 1);

    if (type == 'clinvar') {
        me.setAnnoTabClinvar();
    }
    else if (type == 'snp') {
        me.setAnnoTabSnp();
    }
    else if (type == 'all') {
        me.setAnnoTabClinvar();
        me.setAnnoTabSnp();
    }
};

iCn3DUI.prototype.applyCommandSnpClinvar = function (command) {
    var me = this;
    // chain functions together
    me.deferredSnpClinvar = $.Deferred(function () {
        me.applyCommandSnpClinvarBase(command);
    }); // end of me.deferred = $.Deferred(function() {

    return me.deferredSnpClinvar.promise();
};

iCn3DUI.prototype.applyCommand3ddomainBase = function (command) {
    var me = this;
    // chain functions together
    var pos = command.lastIndexOf(' ');
    var type = command.substr(pos + 1);

    if (type == '3ddomain' || type == 'all') {
        me.setAnnoTab3ddomain();
    }
};

iCn3DUI.prototype.applyCommand3ddomain = function (command) {
    var me = this;
    // chain functions together
    me.deferred3ddomain = $.Deferred(function () {
        me.applyCommand3ddomainBase(command);
    }); // end of me.deferred = $.Deferred(function() {

    return me.deferred3ddomain.promise();
};

iCn3DUI.prototype.applyCommandViewinteractionBase = function (command) {
    var me = this;
    // chain functions together
    if (me.cfg.align !== undefined) {
        var structureArray = Object.keys(me.icn3d.structures);
        me.set2DDiagramsForAlign(structureArray[0].toUpperCase(), structureArray[1].toUpperCase());
    }
};

iCn3DUI.prototype.applyCommandViewinteraction = function (command) {
    var me = this;
    // chain functions together
    me.deferredViewinteraction = $.Deferred(function () {
        me.applyCommandViewinteractionBase(command);
    }); // end of me.deferred = $.Deferred(function() {

    return me.deferredViewinteraction.promise();
};

iCn3DUI.prototype.applyCommand = function (commandStr) {
    var me = this;
    me.bAddCommands = false;

    var commandTransformation = commandStr.split('|||');

    var commandOri = commandTransformation[0].replace(/\s+/g, ' ').trim();
    var command = commandOri.toLowerCase();

    var bShowLog = true;

    // exact match =============

    if (command == 'export state file') { // last step to update transformation
        // the last transformation will be applied
    }
    else if (command == 'export canvas') {
        setTimeout(function () {
            me.saveFile(me.inputid + '.png', 'png');
        }, 500);
    }
    else if (command == 'export interactions') {
        me.exportInteractions();
    }
    else if (command == 'export stl file') {
        setTimeout(function () {
            //me.hideStabilizer();

            var text = me.saveStlFile();
            me.saveFile(me.inputid + '.stl', 'binary', text);
            text = '';
        }, 500);
    }
    else if (command == 'export vrml file') {
        setTimeout(function () {
            //me.hideStabilizer();

            var text = me.saveVrmlFile();
            me.saveFile(me.inputid + '.wrl', 'text', text);
            text = '';
        }, 500);
    }
    else if (command == 'export stl stabilizer file') {
        setTimeout(function () {
            //me.icn3d.bRender = false;

            me.hideStabilizer();
            me.resetAfter3Dprint();
            me.addStabilizer();

            var text = me.saveStlFile();

            //me.hideStabilizer();
            //me.icn3d.bRender = true;
            //me.icn3d.draw();

            me.saveFile(me.inputid + '_stab.stl', 'binary', text);
            text = '';
        }, 500);
    }
    else if (command == 'export vrml stabilizer file') {
        setTimeout(function () {
            //me.icn3d.bRender = false;

            me.hideStabilizer();
            me.resetAfter3Dprint();
            me.addStabilizer();

            var text = me.saveVrmlFile();

            //me.hideStabilizer();
            //me.icn3d.bRender = true;
            //me.icn3d.draw();

            me.saveFile(me.inputid + '_stab.wrl', 'text', text);
            text = '';
        }, 500);
    }
    else if (command == 'select all') {
        me.selectAll();
        //me.icn3d.addHlObjects();
    }
    else if (command == 'select complement') {
        me.selectComplement();
    }
    else if (command == 'set pk atom') {
        me.icn3d.pk = 1;
        me.icn3d.opts['pk'] = 'atom';
    }
    else if (command == 'set pk off') {
        me.icn3d.pk = 0;
        me.icn3d.opts['pk'] = 'no';
        me.icn3d.draw();
        me.icn3d.removeHlObjects();
    }
    else if (command == 'set pk residue') {
        me.icn3d.pk = 2;
        me.icn3d.opts['pk'] = 'residue';
    }
    else if (command == 'set pk strand') {
        me.icn3d.pk = 3;
        me.icn3d.opts['pk'] = 'strand';
    }
    else if (command == 'set pk chain') {
        me.icn3d.pk = 4;
        me.icn3d.opts['pk'] = 'chain';
    }
    else if (command == 'set surface wireframe on') {
        me.icn3d.opts['wireframe'] = 'yes';
        me.icn3d.applySurfaceOptions();
    }
    else if (command == 'set surface wireframe off') {
        me.icn3d.opts['wireframe'] = 'no';
        me.icn3d.applySurfaceOptions();
    }
    else if (command == 'set surface neighbors on') {
        me.icn3d.bConsiderNeighbors = true;
        me.icn3d.applySurfaceOptions();
    }
    else if (command == 'set surface neighbors off') {
        me.icn3d.bConsiderNeighbors = false;
        me.icn3d.applySurfaceOptions();
    }
    else if (command == 'set axis on') {
        me.icn3d.opts['axis'] = 'yes';
    }
    else if (command == 'set axis off') {
        me.icn3d.opts['axis'] = 'no';
    }
    else if (command == 'set fog on') {
        me.icn3d.opts['fog'] = 'yes';
    }
    else if (command == 'set fog off') {
        me.icn3d.opts['fog'] = 'no';
    }
    else if (command == 'set slab on') {
        me.icn3d.opts['slab'] = 'yes';
    }
    else if (command == 'set slab off') {
        me.icn3d.opts['slab'] = 'no';
    }
    else if (command == 'set assembly on') {
        me.icn3d.bAssembly = true;
    }
    else if (command == 'set assembly off') {
        me.icn3d.bAssembly = false;
    }
    else if (command == 'set chemicalbinding show') {
        me.setOption('chemicalbinding', 'show');
    }
    else if (command == 'set chemicalbinding hide') {
        me.setOption('chemicalbinding', 'hide');
    }
    else if (command == 'set hbonds off') {
        me.icn3d.hideHbonds();
        me.icn3d.draw();
    }
    else if (command == 'set stabilizer off') {
        me.hideStabilizer();
        me.icn3d.draw();
    }
    else if (command == 'set disulfide bonds off') {
        me.icn3d.opts["ssbonds"] = "no";
        me.icn3d.draw();
    }
    else if (command == 'set cross linkage off') {
        me.icn3d.bShowCrossResidueBond = false;
        //me.opts['proteins'] = 'ribbon';
        //me.icn3d.draw();
        me.setStyle('proteins', 'ribbon')
    }
    else if (command == 'set lines off') {
        me.icn3d.labels['distance'] = [];
        me.icn3d.lines['distance'] = [];

        me.icn3d.draw();
    }
    else if (command == 'set labels off') {
        //me.icn3d.labels['residue'] = [];
        //me.icn3d.labels['custom'] = [];

        for (var name in me.icn3d.labels) {
            //if(name === 'residue' || name === 'custom') {
            me.icn3d.labels[name] = [];
            //}
        }

        me.icn3d.draw();
    }
    else if (command == 'set mode all') {
        me.setModeAndDisplay('all');
    }
    else if (command == 'set mode selection') {
        me.setModeAndDisplay('selection');
    }
    else if (command == 'set view detailed view') {
        me.setAnnoViewAndDisplay('detailed view');
    }
    else if (command == 'set view overview') {
        me.setAnnoViewAndDisplay('overview');
    }
    /*
      else if(command.indexOf('set annotation') == 0) {
          var pos = command.lastIndexOf(' ');
          var type = command.substr(pos + 1);
    
          if(type == 'all') {
              me.setAnnoTabAll();
          }
          else if(type == 'custom') {
              me.setAnnoTabCustom();
          }
          else if(type == 'clinvar') {
              me.setAnnoTabClinvar();
          }
          else if(type == 'snp') {
              me.setAnnoTabSnp();
          }
          else if(type == 'cdd') {
              me.setAnnoTabCdd();
          }
          else if(type == '3ddomain') {
              me.setAnnoTab3ddomain();
          }
          else if(type == 'site') {
              me.setAnnoTabSite();
          }
          else if(type == 'interaction') {
              me.setAnnoTabInteraction();
          }
      }
    */
    else if (command == 'set annotation custom') {
        me.setAnnoTabCustom();
    }
    else if (command == 'set annotation interaction') {
        me.setAnnoTabInteraction();
    }
    else if (command == 'set annotation cdd') {
        me.setAnnoTabCdd();
    }
    else if (command == 'set annotation site') {
        me.setAnnoTabSite();
    }
    else if (command.indexOf('hide annotation') == 0) {
        var pos = command.lastIndexOf(' ');
        var type = command.substr(pos + 1);

        if (type == 'all') {
            me.hideAnnoTabAll();
        }
        else if (type == 'custom') {
            me.hideAnnoTabCustom();
        }
        else if (type == 'clinvar') {
            me.hideAnnoTabClinvar();
        }
        else if (type == 'snp') {
            me.hideAnnoTabSnp();
        }
        else if (type == 'cdd') {
            me.hideAnnoTabCdd();
        }
        else if (type == '3ddomain') {
            me.hideAnnoTab3ddomain();
        }
        else if (type == 'site') {
            me.hideAnnoTabSite();
        }
        else if (type == 'interaction') {
            me.hideAnnoTabInteraction();
        }
    }
    else if (command == 'add residue labels') {
        me.icn3d.addResiudeLabels(me.icn3d.hAtoms);

        me.icn3d.draw();
    }
    else if (command == 'add chain labels') {
        me.addChainLabels(me.icn3d.hAtoms);

        me.icn3d.draw();
    }
    else if (command == 'rotate left') {
        me.icn3d.bStopRotate = false;
        me.ROT_DIR = 'left';

        me.rotStruc('left');
    }
    else if (command == 'rotate right') {
        me.icn3d.bStopRotate = false;
        me.ROT_DIR = 'right';

        me.rotStruc('right');
    }
    else if (command == 'rotate up') {
        me.icn3d.bStopRotate = false;
        me.ROT_DIR = 'up';

        me.rotStruc('up');
    }
    else if (command == 'rotate down') {
        me.icn3d.bStopRotate = false;
        me.ROT_DIR = 'down';

        me.rotStruc('down');
    }
    else if (command === 'reset') {
        //location.reload();
        me.icn3d.reinitAfterLoad();
        me.renderFinalStep(1);

        // need to render
        me.icn3d.render();
    }
    else if (command === 'reset orientation') {
        me.icn3d.resetOrientation();
        me.icn3d.draw();
    }
    else if (command == 'reset thickness') {
        me.resetAfter3Dprint();
        me.icn3d.draw();
    }
    else if (command == 'clear selection') {
        //if(me.icn3d.prevHighlightObjects.length > 0) { // remove
        me.icn3d.removeHlObjects();
        me.removeHl2D();
        me.icn3d.bShowHighlight = false;
        //}
    }
    else if (command == 'zoom selection') {
        me.icn3d.zoominSelection();
        me.icn3d.draw();
    }
    else if (command == 'center selection') {
        me.icn3d.centerSelection();
        me.icn3d.draw();
    }
    else if (command == 'show selection') {
        me.showSelection();
    }
    else if (command == 'output selection') {
        me.outputSelection();
    }
    else if (command == 'toggle selection') {
        me.toggleSelection();
    }
    else if (command == 'toggle highlight') {
        if (me.icn3d.prevHighlightObjects.length > 0) { // remove
            me.icn3d.removeHlObjects();
            me.icn3d.bShowHighlight = false;
        }
        else { // add
            me.icn3d.addHlObjects();
            me.icn3d.bShowHighlight = true;
        }
    }
    else if (command == 'stabilizer') {
        me.addStabilizer();

        me.prepareFor3Dprint();
        //me.icn3d.draw();
    }
    else if (command == 'disulfide bonds') {
        me.showSsbonds();
    }
    else if (command == 'cross linkage') {
        me.icn3d.bShowCrossResidueBond = true;

        me.setStyle('proteins', 'lines')
    }
    else if (command == 'back') {
        me.back();
    }
    else if (command == 'forward') {
        me.forward();
    }
    else if (command == 'clear all') {
        me.selectAll();
    }
    else if (command == 'defined sets') {
        me.showSets();
    }
    else if (command == 'view interactions') {
        if (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) {
            me.set2DDiagrams(me.inputid);
        }
        //else if(me.cfg.align !== undefined) {
        //    var structureArray = Object.keys(me.icn3d.structures);
        //    me.set2DDiagramsForAlign(structureArray[0].toUpperCase(), structureArray[1].toUpperCase());
        //}
    }
    //      else if(command == 'view annotations') {
    //          if(me.cfg.showanno === undefined || !me.cfg.showanno) { // previously done the following call
    //              me.showAnnotations();
    //          }
    //      }
    else if (command == 'show annotations all chains') {
        me.showAnnoAllChains();
    }

    // start with =================
    else if (commandOri.indexOf('select interaction') == 0) {
        var idArray = commandOri.substr(commandOri.lastIndexOf(' ') + 1).split(',');
        if (idArray !== null) {
            var mmdbid = idArray[0].split('_')[0];
            if (!me.b2DShown) me.download2Ddgm(mmdbid.toUpperCase());

            me.selectInteraction(idArray[0], idArray[1]);
        }
    }

    else if (commandOri.indexOf('select saved atoms') == 0) {
        var idArray = commandOri.substr(commandOri.lastIndexOf(' ') + 1).split(',');
        if (idArray !== null) me.changeCustomAtoms(idArray);
    }
    else if (commandOri.indexOf('select chain') !== -1) {
        var idArray = commandOri.substr(commandOri.lastIndexOf(' ') + 1).split(',');

        //if(idArray !== null) me.changeChainid(idArray);
        for (var i = 0, il = idArray.length; i < il; ++i) {
            me.selectAChain(idArray[i], idArray[i]);
        }
    }
    else if (command.indexOf('select zone cutoff') == 0) {
        var radius = parseFloat(command.substr(command.lastIndexOf(' ') + 1));

        me.pickCustomSphere(radius);
    }
    else if (command.indexOf('set surface opacity') == 0) {
        var value = command.substr(command.lastIndexOf(' ') + 1);
        me.icn3d.opts['opacity'] = value;
        me.icn3d.applySurfaceOptions();
    }
    else if (command.indexOf('set surface') == 0) {
        var value = command.substr(12);

        me.icn3d.opts['surface'] = value;
        me.icn3d.applySurfaceOptions();
    }
    else if (command.indexOf('set camera') == 0) {
        var value = command.substr(command.lastIndexOf(' ') + 1);
        me.icn3d.opts['camera'] = value;
    }
    else if (command.indexOf('set background') == 0) {
        var value = command.substr(command.lastIndexOf(' ') + 1);
        me.icn3d.opts['background'] = value;
    }
    else if (commandOri.indexOf('set thickness') == 0) {
        var paraArray = command.split(' | ');

        me.bSetThickness = true;

        for (var i = 1, il = paraArray.length; i < il; ++i) {
            var p1Array = paraArray[i].split(' ');

            var para = p1Array[0];
            var value = parseFloat(p1Array[1]);

            if (para == 'linerad') me.icn3d.lineRadius = value;
            if (para == 'coilrad') me.icn3d.coilWidth = value;
            if (para == 'stickrad') me.icn3d.cylinderRadius = value;
            if (para == 'tracerad') me.icn3d.traceRadius = value;
            if (para == 'ballscale') me.icn3d.dotSphereScale = value;

            if (para == 'ribbonthick') me.icn3d.ribbonthickness = value;
            if (para == 'proteinwidth') me.icn3d.helixSheetWidth = value;
            if (para == 'nucleotidewidth') me.icn3d.nucleicAcidWidth = value;

            me.icn3d.draw();
        }
    }
    else if (command.indexOf('set highlight color') == 0) {
        var color = command.substr(20);
        if (color === 'yellow') {
            me.icn3d.hColor = new THREE.Color(0xFFFF00);
            me.icn3d.matShader = me.icn3d.setOutlineColor('yellow');
        }
        else if (color === 'green') {
            me.icn3d.hColor = new THREE.Color(0x00FF00);
            me.icn3d.matShader = me.icn3d.setOutlineColor('green');
        }
        else if (color === 'red') {
            me.icn3d.hColor = new THREE.Color(0xFF0000);
            me.icn3d.matShader = me.icn3d.setOutlineColor('red');
        }
        me.icn3d.draw(); // required to make it work properly
    }
    else if (command.indexOf('set highlight style') == 0) {
        var style = command.substr(20);

        if (style === 'outline') {
            me.icn3d.bHighlight = 1;
        }
        else if (style === '3d') {
            me.icn3d.bHighlight = 2;
        }

        me.icn3d.draw();
    }
    else if (command.indexOf('add line') == 0) {
        var paraArray = command.split(' | ');
        var p1Array = paraArray[1].split(' ');
        var p2Array = paraArray[2].split(' ');
        var color = paraArray[3].substr(paraArray[3].lastIndexOf(' ') + 1);
        var dashed = paraArray[4].substr(paraArray[4].lastIndexOf(' ') + 1) === 'true' ? true : false;
        var type = paraArray[5].substr(paraArray[5].lastIndexOf(' ') + 1);

        me.addLine(parseFloat(p1Array[1]), parseFloat(p1Array[3]), parseFloat(p1Array[5]), parseFloat(p2Array[1]), parseFloat(p2Array[3]), parseFloat(p2Array[5]), color, dashed, type);
        me.icn3d.draw();
    }
    else if (commandOri.indexOf('add label') == 0) {
        var paraArray = commandOri.split(' | ');
        var text = paraArray[0].substr(('add label').length + 1);

        // add label Text | x 40.45 y 24.465000000000003 z 53.48 | size 40 | color #ffff00 | background #cccccc | type custom
        var x, y, z, size, color, background, type;
        for (var i = 1, il = paraArray.length; i < il; ++i) {
            var wordArray = paraArray[i].split(' ');

            var bPosition = false;
            if (wordArray[0] == 'x') {
                bPosition = true;
                x = wordArray[1];
                y = wordArray[3];
                z = wordArray[5];
            }
            else if (wordArray[0] == 'size') {
                size = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
            }
            else if (wordArray[0] == 'color') {
                color = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
            }
            else if (wordArray[0] == 'background') {
                background = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
            }
            else if (wordArray[0] == 'type') {
                type = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
            }

            if (!bPosition) {
                var position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.hAtoms));
                x = position.center.x;
                y = position.center.y;
                z = position.center.z;
            }
        }

        me.addLabel(text, x, y, z, size, color, background, type);
        me.icn3d.draw();
    }
    else if (commandOri.indexOf('add track') == 0) {
        //"add track | chainid " + chainid + " | title " + title + " | text " + text
        var paraArray = commandOri.split(' | ');

        var chainid = paraArray[1].substr(8).toUpperCase();
        var title = paraArray[2].substr(6);
        var text = paraArray[3].substr(5);

        $("#" + me.pre + "anno_custom")[0].checked = true;
        $("[id^=" + me.pre + "custom]").show();

        me.checkGiSeq(chainid, title, text, 0);
    }
    else if (command.indexOf('remove one stabilizer') == 0) {
        var paraArray = command.split(' | ');
        var p1Array = paraArray[1].split(' ');

        var rmLineArray = [];
        rmLineArray.push(parseInt(p1Array[0]));
        rmLineArray.push(parseInt(p1Array[1]));

        me.removeOneStabilizer(rmLineArray);

        //me.updateStabilizer();

        me.icn3d.draw();
    }
    else if (command.indexOf('add one stabilizer') == 0) {
        var paraArray = command.split(' | ');
        var p1Array = paraArray[1].split(' ');

        if (me.icn3d.pairArray === undefined) me.icn3d.pairArray = [];
        me.icn3d.pairArray.push(parseInt(p1Array[0]));
        me.icn3d.pairArray.push(parseInt(p1Array[1]));

        //me.updateStabilizer();

        me.icn3d.draw();
    }

    // start with, single word =============
    else if (command.indexOf('pickatom') == 0) {
        var atomid = parseInt(command.substr(command.lastIndexOf(' ') + 1));

        me.icn3d.pAtom = me.icn3d.atoms[atomid];

        me.icn3d.showPicking(me.icn3d.pAtom);
    }
    else if (command.indexOf('hbonds') == 0) {
        var threshold = parseFloat(command.substr(command.indexOf(' ') + 1));

        if (!isNaN(threshold)) me.showHbonds(threshold);
    }
    else if (command.indexOf('color') == 0) {
        var color = command.substr(command.indexOf(' ') + 1);
        me.icn3d.opts['color'] = color;

        me.icn3d.setColorByOptions(me.icn3d.opts, me.icn3d.hAtoms);

        me.updateHlAll();
    }
    else if (command.indexOf('style') == 0) {
        var secondPart = command.substr(command.indexOf(' ') + 1);

        var selectionType = secondPart.substr(0, secondPart.indexOf(' '));
        var style = secondPart.substr(secondPart.indexOf(' ') + 1);

        me.setStyle(selectionType, style);
    }

    // special, select ==========

    else if (command.indexOf('select') == 0 && command.indexOf('name') !== -1) {
        var paraArray = commandOri.split(' | '); // atom names might be case-sensitive

        var select = '', commandname = '', commanddesc = '';
        for (var i = 0, il = paraArray.length; i < il; ++i) {
            var para = paraArray[i];

            if (para.indexOf('select') !== -1) {
                select = para.substr(para.indexOf(' ') + 1);
            }
            else if (para.indexOf('name') !== -1) {
                commandname = para.substr(para.indexOf(' ') + 1);
            }
            //        else if(para.indexOf('description') !== -1) {
            //            commanddesc = para.substr(para.indexOf(' ') + 1);
            //        }
        }

        //    if(paraArray.length < 3) commanddesc = commandname;
        commanddesc = commandname;

        me.selectByCommand(select, commandname, commanddesc);
    }
    else if (command.indexOf('select $') !== -1 || command.indexOf('select .') !== -1 || command.indexOf('select :') !== -1 || command.indexOf('select @') !== -1) {
        var paraArray = commandOri.split(' | '); // atom names might be case-sensitive

        var select = paraArray[0].substr(paraArray[0].indexOf(' ') + 1);
        var commandname = '', commanddesc = '';

        if (paraArray.length > 1) {
            commandname = paraArray[1].substr(paraArray[1].indexOf(' ') + 1);
        }

        if (paraArray.length > 2) {
            commanddesc = paraArray[2].substr(paraArray[2].indexOf(' ') + 1);
        }

        if (select.indexOf(' or ') !== -1) { // "select " command without " | name"
            me.selectByCommand(select, commandname, commanddesc);
        }
        else { // only single query from selectByCommand()
            me.selectBySpec(select, commandname, commanddesc);
        }
    }

    if (bShowLog) {
        me.setLogCmd(commandOri, false);
    }

    me.bAddCommands = true;
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.selectResidues = function (id, that) {
    var me = this;
    if (id !== undefined && id !== '') {
        // add "align_" in front of id so that full sequence and aligned sequence will not conflict
        //if(id.substr(0, 5) === 'align') id = id.substr(5);

        // seq_div0_1TSR_A_1, align_div0..., giseq_div0..., snp_div0..., interaction_div0..., cddsite_div0..., domain_div0...
        id = id.substr(id.indexOf('_') + 1);

        me.bSelectResidue = true;

        $(that).toggleClass('icn3d-highlightSeq');

        var residueid = id.substr(id.indexOf('_') + 1);

        if (me.icn3d.residues.hasOwnProperty(residueid)) {
            if ($(that).hasClass('icn3d-highlightSeq')) {
                for (var j in me.icn3d.residues[residueid]) {
                    me.icn3d.hAtoms[j] = 1;
                }
                me.selectedResidues[residueid] = 1;

                if (me.bAnnotations && $(that).attr('disease') !== undefined) {
                    var label = $(that).attr('disease');

                    var position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.residues[residueid]));
                    //position.center.add(new THREE.Vector3(3.0, 3.0, 3.0)); // shift a little bit

                    var maxlen = 15;
                    if (label.length > maxlen) label = label.substr(0, maxlen) + '...';

                    //var size = parseInt(me.icn3d.LABELSIZE * 10 / label.length);
                    var size = me.icn3d.LABELSIZE;
                    var color = me.GREYD;
                    me.addLabel(label, position.center.x, position.center.y, position.center.z, size, color, undefined, 'custom');
                }
            }
            else {
                for (var i in me.icn3d.residues[residueid]) {
                    //me.icn3d.hAtoms[i] = undefined;
                    delete me.icn3d.hAtoms[i];
                }
                //me.selectedResidues[residueid] = undefined;
                delete me.selectedResidues[residueid];

                me.icn3d.removeHlObjects();
            }
        }
    }
};

iCn3DUI.prototype.selectTitle = function (that) {
    var me = this;
    if ($(that).hasClass('icn3d-seqTitle')) {
        var chainid = $(that).attr('chain');

        if (me.bAlignSeq) {
            me.bSelectAlignResidue = false;
        }
        else {
            me.bSelectResidue = false;
        }

        if (!me.bAnnotations) {
            me.removeSeqChainBkgd(chainid);
        }
        //else {
        //    me.removeSeqChainBkgd();
        //}

        if (!me.icn3d.bCtrl && !me.icn3d.bShift) {
            me.removeSeqResidueBkgd();

            me.removeSeqChainBkgd();
        }

        $(that).toggleClass('icn3d-highlightSeq');

        var commandname, commanddescr, position;
        if (!me.bAnnotations) {
            if (me.bAlignSeq) {
                commandname = "align_" + chainid;
            }
            else {
                commandname = chainid;
            }
        }
        else {
            commandname = $(that).attr('setname');
            commanddescr = $(that).attr('title');
        }

        if ($(that).hasClass('icn3d-highlightSeq')) {
            if (!me.bAnnotations) {
                if (me.bAlignSeq) {
                    if (me.icn3d.bCtrl || me.icn3d.bShift) {
                        me.selectAChain(chainid, commandname, true, true);
                    }
                    else {
                        me.selectAChain(chainid, commandname, true);
                    }

                    me.setLogCmd('select alignChain ' + chainid, true);
                }
                else {
                    if (me.icn3d.bCtrl || me.icn3d.bShift) {
                        me.selectAChain(chainid, commandname, false, true);
                    }
                    else {
                        me.selectAChain(chainid, commandname, false);
                    }

                    me.setLogCmd('select chain ' + chainid, true);
                }
            }
            else {
                if ($(that).hasClass('icn3d-highlightSeq')) {
                    me.removeHl2D();

                    if ($(that).attr('gi') !== undefined) {
                        if (me.icn3d.bCtrl || me.icn3d.bShift) {
                            me.selectAChain(chainid, chainid, false, true);
                        }
                        else {
                            me.selectAChain(chainid, chainid, false);
                        }

                        me.setLogCmd('select chain ' + chainid, true);
                    }
                    else {
                        var residueidHash = {};
                        if ($(that).attr('domain') !== undefined || $(that).attr('3ddomain') !== undefined) {
                            me.hlSummaryDomain3ddomain(that);

                            var fromArray = $(that).attr('from').split(',');
                            var toArray = $(that).attr('to').split(',');

                            //me.icn3d.hAtoms = {};

                            //removeAllLabels();

                            // protein chains
                            //var atomHash = {}, residueidHash = {};
                            var residueid;
                            for (var i = 0, il = fromArray.length; i < il; ++i) {
                                var from = parseInt(fromArray[i]);
                                var to = parseInt(toArray[i]);

                                for (var j = from; j <= to; ++j) {
                                    residueid = chainid + '_' + (j + 1).toString();
                                    residueidHash[residueid] = 1;

                                    //atomHash = me.icn3d.unionHash(atomHash, me.icn3d.residues[residueid]);
                                }
                            }

                            if (me.icn3d.bCtrl || me.icn3d.bShift) {
                                me.selectResidueList(residueidHash, commandname, commanddescr, true);
                            }
                            else {
                                me.selectResidueList(residueidHash, commandname, commanddescr, false);
                            }

                            //me.updateHlAll();

                            residueid = chainid + '_' + parseInt((from + to) / 2).toString();
                            //residueid = chainid + '_' + from.toString();
                            position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.residues[residueid]));
                        }
                        //else if($(that).attr('site') !== undefined || $(that).attr('clinvar') !== undefined) {
                        else {
                            var posArray = $(that).attr('posarray').split(',');

                            //me.icn3d.hAtoms = {};

                            //removeAllLabels();

                            //var  atomHash = {}, residueidHash = {};
                            var residueid;
                            for (var i = 0, il = posArray.length; i < il; ++i) {
                                if ($(that).attr('site') !== undefined) {
                                    residueid = chainid + '_' + (parseInt(posArray[i]) + 1).toString();
                                }
                                //else if($(that).attr('clinvar') !== undefined) {
                                else {
                                    residueid = chainid + '_' + posArray[i];
                                }

                                residueidHash[residueid] = 1;
                                //atomHash = me.icn3d.unionHash(atomHash, me.icn3d.residues[residueid]);
                            }

                            if (me.icn3d.bCtrl || me.icn3d.bShift) {
                                me.selectResidueList(residueidHash, commandname, commanddescr, true);
                            }
                            else {
                                me.selectResidueList(residueidHash, commandname, commanddescr, false);
                            }

                            //me.updateHlAll();

                            residueid = chainid + '_' + posArray[parseInt((0 + posArray.length) / 2)].toString();
                            //residueid = chainid + '_' + posArray[0].toString();
                            position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.residues[residueid]));
                        }

                        //removeAllLabels
                        for (var name in me.icn3d.labels) {
                            //if(name === 'residue' || name === 'custom' || name === 'clinvar') {
                            if (name !== 'schematic' && name !== 'distance') {
                                me.icn3d.labels[name] = [];
                            }
                        }

                        //var size = parseInt(me.icn3d.LABELSIZE * 10 / commandname.length);
                        var size = me.icn3d.LABELSIZE;
                        var color = "FFFF00";
                        me.addLabel(commanddescr, position.center.x, position.center.y, position.center.z, size, color, undefined, 'custom');

                        //                        me.icn3d.addHlObjects();
                        //                        me.updateHl2D([chainid]);

                        me.icn3d.draw();

                        //me.setLogCmd('select ' + commandname, true);
                        //me.setLogCmd('select ' + me.residueids2spec(Object.keys(residueidHash)) + ' | name ' + commandname + ' | description ' + commanddescr, true);
                        me.setLogCmd('select ' + me.residueids2spec(Object.keys(residueidHash)) + ' | name ' + commandname, true);
                    } // if($(that).attr('gi') !== undefined) {
                } // if($(that).hasClass('icn3d-highlightSeq')) {
            } // if(!me.bAnnotations) {
        } // if($(that).hasClass('icn3d-highlightSeq')) {
        else {
            me.icn3d.removeHlObjects();
            me.removeHl2D();

            //me.icn3d.hAtoms = {};

            $("#" + me.pre + "atomsCustom").val("");
        }

    }
};

iCn3DUI.prototype.selectSequenceNonMobile = function () {
    var me = this;
    //$("#" + me.pre + "dl_sequence").add("#" + me.pre + "dl_sequence2").add("#" + me.pre + "dl_annotations").selectable({
    $("#" + me.pre + "dl_sequence2").add("[id^=" + me.pre + "dt_giseq]").add("[id^=" + me.pre + "dt_site]").add("[id^=" + me.pre + "dt_snp]").add("[id^=" + me.pre + "dt_clinvar]").add("[id^=" + me.pre + "dt_cdd]").add("[id^=" + me.pre + "dt_domain]").add("[id^=" + me.pre + "dt_interaction]")
        .add("[id^=" + me.pre + "tt_giseq]").add("[id^=" + me.pre + "tt_site]").add("[id^=" + me.pre + "tt_snp]").add("[id^=" + me.pre + "tt_clinvar]").add("[id^=" + me.pre + "tt_cdd]").add("[id^=" + me.pre + "tt_domain]").add("[id^=" + me.pre + "tt_interaction]")
        .selectable({
            //$(".icn3d-dl_sequence").selectable({
            stop: function () {
                if ($(this).attr('id') === me.pre + "dl_sequence2") {
                    me.bAlignSeq = true;
                    me.bAnnotations = false;
                }
                //else if($(this).attr('id') === me.pre + "dl_annotations") {
                else {
                    me.bAlignSeq = false;
                    me.bAnnotations = true;
                }

                if (me.bSelectResidue === false && !me.icn3d.bShift && !me.icn3d.bCtrl) {
                    me.removeSelection();
                }

                // select residues
                $("span.ui-selected", this).each(function () {
                    var id = $(this).attr('id');

                    if (id !== undefined) {
                        me.selectResidues(id, this);
                    }
                });

                /*
                          if(me.bAnnotations) {
                              me.addResiudeLabels(me.icn3d.hAtoms);
                
                              me.icn3d.draw();
                          }
                          else {
                              me.icn3d.addHlObjects();  // render() is called
                          }
                */

                me.icn3d.addResiudeLabels(me.icn3d.hAtoms, false, 0.5);
                me.icn3d.addHlObjects();  // render() is called

                // get all chainid in the selected residues
                var chainHash = {};
                for (var residueid in me.selectedResidues) {
                    var pos = residueid.lastIndexOf('_');
                    var chainid = residueid.substr(0, pos);

                    chainHash[chainid] = 1;
                }

                // highlight the nodes
                var chainArray2d = Object.keys(chainHash);
                me.updateHl2D(chainArray2d);

                // select annotation title
                $("div.ui-selected", this).each(function () {
                    if ($(this).attr('chain') !== undefined) {

                        me.selectTitle(this);
                    }
                });
            }
        });

    $("[id^=" + me.pre + "ov_giseq]").add("[id^=" + me.pre + "ov_site]").add("[id^=" + me.pre + "ov_snp]").add("[id^=" + me.pre + "ov_clinvar]").add("[id^=" + me.pre + "ov_cdd]").add("[id^=" + me.pre + "ov_domain]").add("[id^=" + me.pre + "ov_interaction]")
        .add("[id^=" + me.pre + "tt_giseq]").add("[id^=" + me.pre + "tt_site]").add("[id^=" + me.pre + "tt_snp]").add("[id^=" + me.pre + "tt_clinvar]").add("[id^=" + me.pre + "tt_cdd]").add("[id^=" + me.pre + "tt_domain]").add("[id^=" + me.pre + "tt_interaction]")
        .on('click', '.icn3d-seqTitle', function (e) {
            e.stopImmediatePropagation();

            me.bAlignSeq = false;
            me.bAnnotations = true;

            // select annotation title
            //$("div .ui-selected", this).each(function() {
            me.selectTitle(this);

            me.hlSummaryDomain3ddomain(this);
            //});
        });
};

iCn3DUI.prototype.hlSummaryDomain3ddomain = function (that) {
    var me = this;
    if ($(that).attr('domain') !== undefined) { // domain
        var index = $(that).attr('index');
        var chainid = $(that).attr('chain');

        if ($("[id^=" + chainid + "_domain_" + index + "]").length !== 0) {
            $("[id^=" + chainid + "_domain_" + index + "]").addClass('icn3d-highlightSeqBox');
        }
    }

    if ($(that).attr('3ddomain') !== undefined) { // 3d domain
        var index = $(that).attr('index');
        var chainid = $(that).attr('chain');

        if ($("[id^=" + chainid + "_3d_domain_" + index + "]").length !== 0) {
            $("[id^=" + chainid + "_3d_domain_" + index + "]").addClass('icn3d-highlightSeqBox');
        }
    }
};

iCn3DUI.prototype.selectSequenceMobile = function () {
    var me = this;
    $("#" + me.pre + "dl_sequence2").add("[id^=" + me.pre + "giseq]").add("[id^=" + me.pre + "site]").add("[id^=" + me.pre + "clinvar]").add("[id^=" + me.pre + "snp]").add("[id^=" + me.pre + "cdd]").add("[id^=" + me.pre + "domain]").add("[id^=" + me.pre + "interaction]").on('click', '.icn3d-residue', function (e) {
        //$(".icn3d-dl_sequence").on('click', '.icn3d-residue', function(e) {
        e.stopImmediatePropagation();

        if ($(this).attr('id') === me.pre + "dl_sequence2") {
            me.bAlignSeq = true;
            me.bAnnotations = false;
        }
        //else if($(this).attr('id') === me.pre + "dl_annotations") {
        else {
            me.bAlignSeq = false;
            me.bAnnotations = true;
        }

        // select residues
        //$("span.ui-selected", this).each(function() {
        var id = $(this).attr('id');

        if (id !== undefined) {
            me.selectResidues(id, this);
        }
        //});

        if (me.bAnnotations) {
            me.icn3d.addResiudeLabels(me.icn3d.hAtoms);

            me.icn3d.draw();
        }
        else {
            me.icn3d.addHlObjects();  // render() is called
        }

        // get all chainid in the selected residues
        var chainHash = {};
        for (var residueid in me.selectedResidues) {
            var pos = residueid.lastIndexOf('_');
            var chainid = residueid.substr(0, pos);

            chainHash[chainid] = 1;
        }

        // clear nodes in 2d dgm
        me.removeHl2D();

        // highlight the nodes
        var chainArray2d = Object.keys(chainHash);
        me.updateHl2D(chainArray2d);
    });
};

iCn3DUI.prototype.selectChainMobile = function () {
    var me = this;
    $("#" + me.pre + "dl_sequence2").add("[id^=" + me.pre + "giseq]").add("[id^=" + me.pre + "site]").add("[id^=" + me.pre + "clinvar]").add("[id^=" + me.pre + "snp]").add("[id^=" + me.pre + "cdd]").add("[id^=" + me.pre + "domain]").add("[id^=" + me.pre + "interaction]").on('click', '.icn3d-seqTitle', function (e) {
        //$(".icn3d-dl_sequence").on('click', '.icn3d-seqTitle', function(e) {
        e.stopImmediatePropagation();

        if ($(this).attr('id') === me.pre + "dl_sequence2") {
            me.bAlignSeq = true;
            me.bAnnotations = false;
        }
        //else if($(this).attr('id') === me.pre + "dl_annotations") {
        else {
            me.bAlignSeq = false;
            me.bAnnotations = true;
        }

        // select annotation title
        //$("div.ui-selected", this).each(function() {
        me.selectTitle(this);

        me.hlSummaryDomain3ddomain(this);
        //});
    });
};

// remove highlight of chains
iCn3DUI.prototype.removeSeqChainBkgd = function (currChain) {
    if (currChain === undefined) {
        $(".icn3d-seqTitle").each(function (index) {
            $(this).removeClass('icn3d-highlightSeq');
            $(this).removeClass('icn3d-highlightSeqBox');
        });
    }
    else {
        $(".icn3d-seqTitle").each(function (index) {
            if ($(this).attr('chain') !== currChain) {
                $(this).removeClass('icn3d-highlightSeq');
                $(this).removeClass('icn3d-highlightSeqBox');
            }
        });
    }
};

// remove all highlighted residue color
iCn3DUI.prototype.removeSeqResidueBkgd = function () {
    $(".icn3d-residue").each(function (index) {
        $(this).removeClass('icn3d-highlightSeq');
    });
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.update2DdgmContent = function () {
    var me = this;
    // update 2D diagram to show just the displayed parts
    var html2ddgm = '';
    if (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) {
        html2ddgm += me.draw2Ddgm(me.interactionData, me.inputid, undefined, true);
        html2ddgm += me.set2DdgmNote();

        $("#" + me.pre + "dl_2ddgm").html(html2ddgm);
    }
    else if (me.cfg.align !== undefined) {
        html2ddgm += me.draw2Ddgm(me.interactionData1, me.mmdbidArray[0].toUpperCase(), 0, true);
        html2ddgm += me.draw2Ddgm(me.interactionData2, me.mmdbidArray[1].toUpperCase(), 1, true);
        html2ddgm += me.set2DdgmNote(true);

        $("#" + me.pre + "dl_2ddgm").html(html2ddgm);
    }
};

iCn3DUI.prototype.changeSeqColor = function (residueArray) {
    var me = this;
    for (var i = 0, il = residueArray.length; i < il; ++i) {
        var pickedResidue = residueArray[i];
        if ($("[id$=" + me.pre + pickedResidue + "]").length !== 0) {
            var atom = me.icn3d.getFirstAtomObj(me.icn3d.residues[pickedResidue]);
            var color = (atom.color !== undefined) ? "#" + atom.color.getHexString() : me.icn3d.defaultAtomColor;
            //$("[id$=" + me.pre + pickedResidue + "]").attr('style', 'color:' + color);
            // annotations will have their own color, only the chain will have the changed color
            $("[id=giseq_" + me.pre + pickedResidue + "]").attr('style', 'color:' + color);
            if (me.cfg.align !== undefined) $("[id=align_" + me.pre + pickedResidue + "]").attr('style', 'color:' + color);
        }
    }
};

iCn3DUI.prototype.removeHlAll = function () {
    var me = this;
    me.removeHlObjects();
    me.removeHlSeq();
    me.removeHl2D();
    me.removeHlMenus();
};

iCn3DUI.prototype.removeHlObjects = function () {
    var me = this;
    me.icn3d.removeHlObjects();
};

// remove highlight in sequence
iCn3DUI.prototype.removeHlSeq = function () {
    var me = this;
    //       me.removeSeqChainBkgd();
    me.removeSeqResidueBkgd();
};

// remove highlight in 2D window
iCn3DUI.prototype.removeHl2D = function () {
    var me = this;
    // clear nodes in 2d dgm
    $("#" + me.pre + "dl_2ddgm rect").attr('stroke', '#000000');
    $("#" + me.pre + "dl_2ddgm circle").attr('stroke', '#000000');
    $("#" + me.pre + "dl_2ddgm polygon").attr('stroke', '#000000');

    $("#" + me.pre + "dl_2ddgm svg line").attr('stroke', '#000000');

    $("#" + me.pre + "dl_2ddgm rect").attr('stroke-width', 1);
    $("#" + me.pre + "dl_2ddgm circle").attr('stroke-width', 1);
    $("#" + me.pre + "dl_2ddgm polygon").attr('stroke-width', 1);

    $("#" + me.pre + "dl_2ddgm line").attr('stroke-width', 1);
};

// remove highlight in the menu of defined sets
iCn3DUI.prototype.removeHlMenus = function () {
    var me = this;
    $("#" + me.pre + "atomsCustom").val("");
};

iCn3DUI.prototype.updateHlAll = function (commandnameArray, bSetMenu, bUnion) {
    var me = this;
    me.updateHlObjects();

    if (commandnameArray !== undefined) {
        me.updateHlSeqInChain(commandnameArray, bUnion);
    }
    else {
        me.updateHlSeq(undefined, undefined, bUnion);
    }

    me.updateHl2D();
    if (bSetMenu === undefined || bSetMenu) me.updateHlMenus(commandnameArray);

    //me.showAnnoSelectedChains();
};

iCn3DUI.prototype.updateHlObjects = function () {
    var me = this;
    me.icn3d.removeHlObjects();
    me.icn3d.addHlObjects();
};

// update highlight in sequence, slow if sequence is long
iCn3DUI.prototype.updateHlSeq = function (bShowHighlight, residueHash, bUnion) {
    var me = this;
    if (bUnion === undefined || !bUnion) {
        me.removeHlSeq();
    }

    if (residueHash === undefined) residueHash = me.icn3d.getResiduesFromAtoms(me.icn3d.hAtoms);

    me.hlSeq(Object.keys(residueHash));
    me.changeSeqColor(Object.keys(residueHash));
};

iCn3DUI.prototype.updateHlSeqInChain = function (commandnameArray, bUnion) {
    var me = this;
    if (bUnion === undefined || !bUnion) {
        me.removeHlSeq();
    }
    //if(residueHash === undefined) residueHash = me.icn3d.getResiduesFromAtoms(me.icn3d.hAtoms);

    //me.hlSeq(Object.keys(residueHash));
    // speed up with chain highlight
    for (var i = 0, il = commandnameArray.length; i < il; ++i) {
        var commandname = commandnameArray[i];
        if (Object.keys(me.icn3d.chains).indexOf(commandname) !== -1) {
            me.hlSeqInChain(commandname);
        }
        else {
            var residueArray = [];

            if (me.icn3d.defNames2Residues[commandname] !== undefined && me.icn3d.defNames2Residues[commandname].length > 0) {
                residueArray = me.icn3d.defNames2Residues[commandname];
            }

            var residueHash = {};
            if (me.icn3d.defNames2Atoms[commandname] !== undefined && me.icn3d.defNames2Atoms[commandname].length > 0) {
                for (var j = 0, jl = me.icn3d.defNames2Atoms[commandname].length; j < jl; ++j) {
                    var serial = me.icn3d.defNames2Atoms[commandname][j];
                    var atom = me.icn3d.atoms[serial];
                    var resid = atom.structure + '_' + atom.chain + '_' + atom.resi;

                    residueHash[resid] = 1;
                }

                residueArray = residueArray.concat(Object.keys(residueHash));
            }

            me.hlSeq(residueArray);
        }
    }

    //me.changeSeqColor(Object.keys(residueHash));
};

// update highlight in 2D window
iCn3DUI.prototype.updateHl2D = function (chainArray2d) {
    var me = this;
    me.removeHl2D();

    if (chainArray2d === undefined) {
        var chainHash = me.icn3d.getChainsFromAtoms(me.icn3d.hAtoms);
        chainArray2d = Object.keys(chainHash);
    }

    if (chainArray2d !== undefined) {
        for (var i = 0, il = chainArray2d.length; i < il; ++i) {
            var hlatoms = me.icn3d.intHash(me.icn3d.chains[chainArray2d[i]], me.icn3d.hAtoms);
            var ratio = 1.0 * Object.keys(hlatoms).length / Object.keys(me.icn3d.chains[chainArray2d[i]]).length;

            var firstAtom = me.icn3d.getFirstAtomObj(hlatoms);
            if (me.icn3d.alnChains[chainArray2d[i]] !== undefined) {
                var alignedAtoms = me.icn3d.intHash(me.icn3d.alnChains[chainArray2d[i]], hlatoms);
                if (Object.keys(alignedAtoms).length > 0) firstAtom = me.icn3d.getFirstAtomObj(alignedAtoms);
            }
            var color = (firstAtom !== undefined && firstAtom.color !== undefined) ? '#' + firstAtom.color.getHexString() : '#FFFFFF';

            var target = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] rect[class='icn3d-hlnode']");
            var base = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] rect[class='icn3d-basenode']");
            if (target !== undefined) {
                me.highlightNode('rect', target, base, ratio);
                $(target).attr('fill', color);
            }

            target = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] circle[class='icn3d-hlnode']");
            base = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] circle[class='icn3d-basenode']");
            if (target !== undefined) {
                me.highlightNode('circle', target, base, ratio);
                $(target).attr('fill', color);
            }

            target = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] polygon[class='icn3d-hlnode']");
            base = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] polygon[class='icn3d-basenode']");

            if (target !== undefined) {
                me.highlightNode('polygon', target, base, ratio);
                $(target).attr('fill', color);
            }
        }
    }

    if (me.lineArray2d !== undefined) {
        for (var i = 0, il = me.lineArray2d.length; i < il; i += 2) {
            $("#" + me.pre + "dl_2ddgm g[chainid1=" + me.lineArray2d[i] + "][chainid2=" + me.lineArray2d[i + 1] + "] line").attr('stroke', me.ORANGE);
        }
    }

    // update the previously highlisghted atoms for switching between all and selection
    me.icn3d.prevHighlightAtoms = me.icn3d.cloneHash(me.icn3d.hAtoms);

    if (Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) me.setMode('selection');
};

// update highlight in the menu of defined sets
iCn3DUI.prototype.updateHlMenus = function (commandnameArray) {
    var me = this;
    if (commandnameArray === undefined) commandnameArray = [];

    var definedAtomsHtml = me.setAtomMenu(commandnameArray);

    if ($("#" + me.pre + "atomsCustom").length) {
        $("#" + me.pre + "atomsCustom").html(definedAtomsHtml);
    }
};

iCn3DUI.prototype.setAtomMenu = function (commandnameArray) {
    var me = this;
    var html = "";

    var nameArray1 = Object.keys(me.icn3d.defNames2Residues);
    var nameArray2 = Object.keys(me.icn3d.defNames2Atoms);

    var nameArray = nameArray1.concat(nameArray2).sort();

    //for(var i in me.icn3d.defNames2Atoms) {
    for (var i = 0, il = nameArray.length; i < il; ++i) {
        var name = nameArray[i];

        if (commandnameArray.indexOf(name) != -1) {
            html += "<option value='" + name + "' selected='selected'>" + name + "</option>";
        }
        else {
            html += "<option value='" + name + "'>" + name + "</option>";
        }
    }

    return html;
};

iCn3DUI.prototype.setPredefinedInMenu = function () {
    var me = this;
    // predefined sets: all chains
    me.setChainsInMenu();

    // predefined sets: proteins,nucleotides, chemicals
    me.setProtNuclLigInMenu();

    if (me.cfg.align !== undefined && me.bFullUi) {
        me.selectResidueList(me.consHash1, me.conservedName1, me.conservedName1, false, false);
        me.selectResidueList(me.consHash2, me.conservedName2, me.conservedName2, false, false);

        me.selectResidueList(me.nconsHash1, me.nonConservedName1, me.nonConservedName1, false, false);
        me.selectResidueList(me.nconsHash2, me.nonConservedName2, me.nonConservedName2, false, false);

        me.selectResidueList(me.nalignHash1, me.notAlignedName1, me.notAlignedName1, false, false);
        me.selectResidueList(me.nalignHash2, me.notAlignedName2, me.notAlignedName2, false, false);

        // for alignment, show aligned residues, chemicals, and ions
        var dAtoms = {};
        for (var alignChain in me.icn3d.alnChains) {
            dAtoms = me.icn3d.unionHash(dAtoms, me.icn3d.alnChains[alignChain]);
        }

        var residuesHash = {}, chains = {};
        for (var i in dAtoms) {
            var atom = me.icn3d.atoms[i];

            var chainid = atom.structure + '_' + atom.chain;
            var resid = chainid + '_' + atom.resi;
            residuesHash[resid] = 1;
            chains[chainid] = 1;
        }

        var commandname = 'aligned_protein';
        var commanddescr = 'aligned protein and nucleotides';
        var select = "select " + me.residueids2spec(Object.keys(residuesHash));

        //me.addCustomSelection(Object.keys(residuesHash), Object.keys(dAtoms), commandname, commanddescr, select, true);
        me.addCustomSelection(Object.keys(residuesHash), commandname, commanddescr, select, true);
    }
};

iCn3DUI.prototype.hlSeq = function (residueArray) {
    var me = this;
    // update annotation windows and alignment sequences
    var chainHash = {};
    for (var i = 0, il = residueArray.length; i < il; ++i) {
        var pickedResidue = residueArray[i];
        if ($("[id$=" + me.pre + pickedResidue + "]").length !== 0) {
            $("[id$=" + me.pre + pickedResidue + "]").addClass('icn3d-highlightSeq');
        }

        var pos = pickedResidue.lastIndexOf('_');
        var chainid = pickedResidue.substr(0, pos);

        chainHash[chainid] = 1;
    }

    for (var chainid in chainHash) {
        if ($("#giseq_summary_" + me.pre + chainid).length !== 0) {
            $("#giseq_summary_" + me.pre + chainid).addClass('icn3d-highlightSeqBox');
        }
    }
};

iCn3DUI.prototype.hlSeqInChain = function (chainid) {
    var me = this;
    // update annotation windows and alignment sequences
    for (var i = 0, il = me.icn3d.chainsSeq[chainid].length; i < il; ++i) {
        var resi = me.icn3d.chainsSeq[chainid][i].resi;
        var pickedResidue = chainid + '_' + resi;

        //if($("[id$=" + me.pre + pickedResidue + "]").length !== 0) {
        //  $("[id$=" + me.pre + pickedResidue + "]").addClass('icn3d-highlightSeq');
        //}
        // too expensive to highlight all annotations
        if ($("#giseq_" + me.pre + pickedResidue).length !== 0) {
            $("#giseq_" + me.pre + pickedResidue).addClass('icn3d-highlightSeq');
        }
    }

    if ($("#giseq_summary_" + me.pre + chainid).length !== 0) {
        $("#giseq_summary_" + me.pre + chainid).addClass('icn3d-highlightSeqBox');
    }
};

iCn3DUI.prototype.toggleHighlight = function () {
    var me = this;
    //me.setLogCmd("toggle highlight", true);

    if (me.icn3d.prevHighlightObjects.length > 0 || me.icn3d.prevHighlightObjects_ghost.length > 0) { // remove
        me.clearHighlight();
    }
    else { // add
        me.showHighlight();
    }

    me.setLogCmd("toggle highlight", true);
};

iCn3DUI.prototype.clearHighlight = function () {
    var me = this;
    me.icn3d.labels['picking'] = [];
    me.icn3d.draw();

    me.icn3d.removeHlObjects();
    me.removeHl2D();
    me.icn3d.render();

    me.removeSeqChainBkgd();
    me.removeSeqResidueBkgd();

    me.bSelectResidue = false;
};

iCn3DUI.prototype.showHighlight = function () {
    var me = this;
    me.icn3d.addHlObjects();
    me.updateHlAll();
    me.bSelectResidue = true;
};

iCn3DUI.prototype.highlightChains = function (chainArray) {
    var me = this;
    me.icn3d.removeHlObjects();
    me.removeHl2D();

    me.icn3d.addHlObjects();
    me.updateHl2D(chainArray);

    var residueHash = {};
    for (var c = 0, cl = chainArray.length; c < cl; ++c) {
        var chainid = chainArray[c];
        for (var i in me.icn3d.chainsSeq[chainid]) { // get residue number
            var resObj = me.icn3d.chainsSeq[chainid][i];
            var residueid = chainid + "_" + resObj.resi;

            if (resObj.name !== '' && resObj.name !== '-') {
                residueHash[residueid] = 1;
            }
        }
    }

    me.hlSeq(Object.keys(residueHash));
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.setTools = function () {
    var me = this;
    var html = "";

    html += "  <div id='" + me.pre + "selection' style='display:none;'><div style='position:absolute; z-index:555; float:left; display:table-row; margin: 32px 0px 0px 3px;'>";
    html += "    <table style='margin-top: 3px; width:100px;'><tr valign='center'>";

    html += me.setTools_base();

    // add custom buttons here
    // ...

    html += "    </tr></table>";
    html += "  </div></div>";

    return html;
};

iCn3DUI.prototype.setButton = function (buttonStyle, id, title, text) {
    var me = this;
    var bkgdColor = me.isMobile() ? ' background-color:#DDDDDD;' : '';
    return "<div style='margin:3px 0px 0px 10px;'><button style='-webkit-appearance:" + buttonStyle + "; height:36px;" + bkgdColor + "' id='" + me.pre + id + "'><span style='white-space:nowrap' class='icn3d-commandTitle' title='" + title + "'>" + text + "</span></button></div>";
};

iCn3DUI.prototype.setTools_base = function () {
    var me = this;
    // second row
    var html = "";

    var buttonStyle = me.isMobile() ? 'none' : 'button';

    html += "      <td valign='top'>" + me.setButton(buttonStyle, 'definedsets', 'Save Image', 'Save<br/>Image') + "</td>";

    if (me.cfg.cid === undefined) {
        //html += "      <td valign='top'>" + me.setButton(buttonStyle, 'definedSets', 'Select defined structure, chain, and custom sets', 'Defined <br/>Sets') + "</td>";
        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'definedsets', 'Defined Sets', 'Defined<br/>Sets') + "</td>";

        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'show_annotations', 'View sequences and annotations for each chain', 'View Sequences<br/>& Annotations') + "</td>";

        if (me.cfg.align !== undefined) {
            html += "      <td valign='top'>" + me.setButton(buttonStyle, 'show_alignsequences', 'View the sequences of the aligned structures', 'Aligned<br/>Sequences') + "</td>";
        }

        if (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined) {
            html += "      <td valign='top'>" + me.setButton(buttonStyle, 'show_2ddgm', 'View the interactions of the structure', 'View<br/>Interactions') + "</td>";
        }

        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'chemicalbindingshow', 'View Chemical Binding', 'View Chemical<br/>Binding') + "</td>";

        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'alternate', 'Alternate the structures', 'Alternate<br/>(Key \"a\")') + "</td>";
    }

    html += "      <td valign='top'>" + me.setButton(buttonStyle, 'show_selected', 'View ONLY the selected atoms', 'View Only<br/>Selection') + "</td>";

    html += "      <td valign='top'>" + me.setButton(buttonStyle, 'toggleHighlight', 'Turn on and off the 3D highlight in the viewer', 'Toggle<br/>Highlight') + "</td>";

    if (me.cfg.cid === undefined) {
        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'removeLabels', 'Remove Labels', 'Remove<br/>Labels') + "</td>";
    }

    return html;
};

iCn3DUI.prototype.setTopMenusHtml = function (id) {
    var me = this;
    var html = "";

    html += "<div style='position:relative;'>";
    html += "  <!--https://forum.jquery.com/topic/looking-for-a-jquery-horizontal-menu-bar-->";
    html += "  <div id='" + me.pre + "mnlist' style='position:absolute; z-index:999; float:left; display:table-row; margin-top: -2px;'>";
    html += "    <table border='0' cellpadding='0' cellspacing='0' width='100'><tr>";

    html += "    <td valign='top'>" + me.setMenu1() + "</td>";
    html += "    <td valign='top'>" + me.setMenu2() + "</td>";
    html += "    <td valign='top'>" + me.setMenu2b() + "</td>";
    html += "    <td valign='top'>" + me.setMenu3() + "</td>";
    html += "    <td valign='top'>" + me.setMenu4() + "</td>";
    html += "    <td valign='top'>" + me.setMenu5() + "</td>";
    //html += "    <td valign='top'>" + me.setMenu5b() + "</td>";
    html += "    <td valign='top'>" + me.setMenu6() + "</td>";

    html += "    <td valign='top'><div style='position:relative; margin-left:6px;'><label class='icn3d-switch'><input id='" + me.pre + "modeswitch' type='checkbox'><div class='icn3d-slider icn3d-round' style='width:34px; height:18px; margin: 6px 0px 0px 3px;' title='Left (\"All atoms\"): Style and color menu options will be applied to all atoms in the structure&#13;Right (\"Selection\"): Style and color menu options will be applied only to selected atoms'></div></label>";
    html += "    <div class='icn3d-commandTitle' style='min-width:40px; margin-top: 3px; white-space: nowrap;'><span id='" + me.pre + "modeall' title='Style and color menu options will be applied to all atoms in the structure'>All atoms&nbsp;&nbsp;</span><span id='" + me.pre + "modeselection' class='icn3d-modeselection' style='display:none;' title='Style and color menu options will be applied only to selected atoms'>Selection&nbsp;&nbsp;</span></div></div></td>";

    //html += '    <td valign="top"><div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:10px;"><div style="width:20px; display:inline-block; margin-left:6px;"><span id="' + me.pre +  'selection_expand" class="ui-icon ui-icon-plus icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre +  'selection_shrink" class="ui-icon ui-icon-minus icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div> Tools</div></td>';

    //html += '    <td valign="top"><div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:10px;"><span id="' + me.pre +  'selection_expand" class="icn3d-expand icn3d-link" title="Expand"><span class="ui-icon ui-icon-plus"></span> Show Tools</span><span id="' + me.pre +  'selection_shrink" class="icn3d-shrink icn3d-link" style="display:none;" title="Shrink"><span class="ui-icon ui-icon-minus"></span> Hide Tools</span></div></td>';
    html += '    <td valign="top"><div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:10px; border-left:solid 1px #888888"><span id="' + me.pre + 'selection_expand" class="icn3d-expand icn3d-link" title="Expand">&nbsp;&nbsp;Show Toolbar&nbsp;&nbsp;</span><span id="' + me.pre + 'selection_shrink" class="icn3d-shrink icn3d-link" style="display:none;" title="Shrink">&nbsp;&nbsp;Hide Toolbar&nbsp;&nbsp;</span></div></td>';

    html += '    <td valign="top"><div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:8px; border-left:solid 1px #888888">&nbsp;&nbsp;<input type="text" id="' + me.pre + 'search_seq" size="10" placeholder="one-letter seq."> <button style="white-space:nowrap;" id="' + me.pre + 'search_seq_button">Search Seq.</button> <a href="https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#selectb" target="_blank" title="Specification tips">?</a></div></td>';

    html += "  </tr>";
    html += "  </table>";
    html += "  </div>";

    html += me.setTools();

    // show title at the top left corner
    html += "  <div id='" + me.pre + "title' class='icn3d-commandTitle' style='font-size:1.2em; font-weight:normal; position:absolute; z-index:1; float:left; display:table-row; margin: 85px 0px 0px 5px; color: " + me.GREYD + "'></div>";
    html += "  <div id='" + me.pre + "viewer' style='position:relative; width:100%; height:100%; background-color: " + me.GREYD + ";'>";
    html += "   <div id='" + me.pre + "mnLogSection'>";
    html += "    <div style='height: " + me.MENU_HEIGHT + "px;'></div>";
    //        html += "    <div style='height: " + me.MENU_HEIGHT + "px;'></div>";

    html += "   </div>";

    //$("#" + me.divid).css('background-color', me.GREYD);

    if (me.cfg.mmtfid === undefined) {
        if (me.realHeight < 300) {
            html += "    <div id='" + me.pre + "wait' style='position:absolute; top:100px; left:50px; font-size: 1.2em; color: #444444;'>Loading the structure...</div>";
        }
        else {
            html += "    <div id='" + me.pre + "wait' style='position:absolute; top:180px; left:50px; font-size: 1.8em; color: #444444;'>Loading the structure...</div>";
        }
    }
    html += "    <canvas id='" + me.pre + "canvas' style='width:100%; height: 100%; background-color: #000;'>Your browser does not support WebGL.</canvas>";

    // separate for the log box
    if (me.cfg.showcommand === undefined || me.cfg.showcommand) {
        html += me.setLogWindow();
    }

    html += "  </div>";

    html += "</div>";

    html += me.setDialogs();

    html += me.setCustomDialogs();

    $("#" + id).html(html);

    // mn display
    $("accordion").accordion({ collapsible: true, active: false, heightStyle: "content" });
    $("accordion div").removeClass("ui-accordion-content ui-corner-all ui-corner-bottom ui-widget-content");

    $(".icn3d-mn").menu({ position: { my: "left top", at: "right top" } });
    $(".icn3d-mn").hover(function () { }, function () { $("accordion").accordion("option", "active", "none"); });

    $("#" + me.pre + "accordion1").hover(function () { $("#" + me.pre + "accordion1 div").css("display", "block"); }, function () { $("#" + me.pre + "accordion1 div").css("display", "none"); });

    $("#" + me.pre + "accordion2").hover(function () { $("#" + me.pre + "accordion2 div").css("display", "block"); }, function () { $("#" + me.pre + "accordion2 div").css("display", "none"); });

    $("#" + me.pre + "accordion2b").hover(function () { $("#" + me.pre + "accordion2b div").css("display", "block"); }, function () { $("#" + me.pre + "accordion2b div").css("display", "none"); });

    $("#" + me.pre + "accordion3").hover(function () { $("#" + me.pre + "accordion3 div").css("display", "block"); }, function () { $("#" + me.pre + "accordion3 div").css("display", "none"); });

    $("#" + me.pre + "accordion4").hover(function () { $("#" + me.pre + "accordion4 div").css("display", "block"); }, function () { $("#" + me.pre + "accordion4 div").css("display", "none"); });

    $("#" + me.pre + "accordion5").hover(function () { $("#" + me.pre + "accordion5 div").css("display", "block"); }, function () { $("#" + me.pre + "accordion5 div").css("display", "none"); });

    //$("#" + me.pre + "accordion5b").hover( function(){ $("#" + me.pre + "accordion5b div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion5b div").css("display", "none"); } );

    $("#" + me.pre + "accordion6").hover(function () { $("#" + me.pre + "accordion6 div").css("display", "block"); }, function () { $("#" + me.pre + "accordion6 div").css("display", "none"); });
};

iCn3DUI.prototype.getLink = function (id, text) {
    var me = this;
    return "<li><span id='" + me.pre + id + "' class='icn3d-link'>" + text + "</span></li>";
};

iCn3DUI.prototype.getRadio = function (radioid, id, text, bChecked) {
    var me = this;
    var checkedStr = (bChecked !== undefined && bChecked) ? ' checked' : '';
    //return "<li><input type='radio' name='" + me.pre + radioid + "' id='" + me.pre + id + "'" + checkedStr + "><label for='" + me.pre + id + "'>" + text + "</label></li>";

    //https://stackoverflow.com/questions/17541614/use-images-instead-of-radio-buttons/17541916
    return "<li><label for='" + me.pre + id + "' class='icn3d-rad'><input type='radio' name='" + me.pre + radioid + "' id='" + me.pre + id + "'" + checkedStr + "><span class='ui-icon ui-icon-blank'></span> <span class='icn3d-rad-text'>" + text + "</span></label></li>";
};

iCn3DUI.prototype.setMenu1 = function () {
    var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion1'>";
    html += "<h3>File</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";
    html += "  <li><span>Retrieve by ID</span>";
    html += "    <ul>";
    html += me.getLink('mn1_mmdbid', 'MMDB ID');
    html += me.getLink('mn1_mmtfid', 'MMTF ID');
    html += me.getLink('mn1_pdbid', 'PDB ID');
    html += me.getLink('mn1_mmcifid', 'mmCIF ID');
    html += me.getLink('mn1_gi', 'NCBI gi');
    html += me.getLink('mn1_cid', 'PubChem CID');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Open File</span>";
    html += "    <ul>";
    html += me.getLink('mn1_pdbfile', 'PDB File');
    html += me.getLink('mn1_mmciffile', 'mmCIF File');
    html += me.getLink('mn1_mol2file', 'Mol2 File');
    html += me.getLink('mn1_sdffile', 'SDF File');
    html += me.getLink('mn1_xyzfile', 'XYZ File');
    html += me.getLink('mn1_urlfile', 'Url (Same Host) ');
    html += "      <li>-</li>";
    html += me.getLink('mn1_state', 'State/Script File');
    html += me.getLink('mn1_selection', 'Selection File');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span id='" + me.pre + "mn1_align' class='icn3d-link'>Open VAST<br>Alignment</span></li>";
    html += "  <li><span>3D Printing</span>";
    html += "    <ul>";
    if (me.cfg.cid === undefined) {
        html += me.getLink('mn1_exportVrmlStab', 'VRML (Color, W/  Stabilizers)');
        html += me.getLink('mn1_exportStlStab', 'STL (W/  Stabilizers)');
        html += "      <li>-</li>";
        html += me.getLink('mn1_exportVrml', 'VRML (Color)');
        html += me.getLink('mn1_exportStl', 'STL');
        html += "      <li>-</li>";
        html += me.getLink('mn1_stabilizerYes', 'Add All  Stabilizers');
        html += me.getLink('mn1_stabilizerNo', 'Remove All  Stabilizers');
        html += "      <li>-</li>";
        html += me.getLink('mn1_stabilizerOne', 'Add One  Stabilizer');
        html += me.getLink('mn1_stabilizerRmOne', 'Remove One  Stabilizer');
        html += "      <li>-</li>";
        html += me.getLink('mn1_thicknessSet', 'Set Thickness');
        html += me.getLink('mn1_thicknessReset', 'Reset Thickness');
    }
    else {
        html += me.getLink('mn1_exportVrml', 'VRML (Color)');
        html += me.getLink('mn1_exportStl', 'STL');
    }

    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Save Files</span>";
    html += "    <ul>";
    html += me.getLink('mn1_exportCanvas', 'PNG Image');
    html += me.getLink('mn1_exportState', 'State File');
    html += me.getLink('mn1_exportSelections', 'Selection File');
    html += me.getLink('mn1_exportCounts', 'Residue Counts');
    if (me.cfg.mmdbid !== undefined) {
        html += me.getLink('mn6_exportInteraction', 'Interaction List');
    }

    html += "    </ul>";
    html += "  </li>";

    html += me.getLink('mn1_sharelink', 'Share Link');

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu2 = function () {
    var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion2'>";
    html += "<h3>Select</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    html += me.getLink('mn2_definedsets', 'Defined Sets');
    html += me.getLink('mn2_selectall', 'All');
    //        if(me.cfg.cid === undefined) {
    //            html += me.getRadio('mn2_select', 'mn2_select_chain', 'Defined Sets');
    //        }
    html += me.getLink('mn2_aroundsphere', 'by Distance');
    html += me.getLink('mn2_selectcomplement', 'Inverse');
    html += me.getLink('mn2_command', 'Advanced');


    //html += "  <li><span>Selection Mode</span>";
    //html += "    <ul>";
    //html += me.getLink('mn6_modeall', 'Apply style, color,</span><br/><span>surface to all atoms');
    //html += me.getLink('mn6_modeselection', 'Apply style, color,</span><br/><span>surface only to selection');
    //html += "    </ul>";
    //html += "  </li>";


    if (me.cfg.cid === undefined) {
        html += "  <li><span>Select on 3D</span>";
        html += "    <ul>";

        html += "  <li>\"Alt\"+Click: start selection</li>";
        html += "  <li>\"Ctrl\"+Click: union selection</li>";
        html += "  <li>\"Shift\"+Click: range Selection</li>";
        html += "  <li>-</li>";
        html += me.getRadio('mn2_pk', 'mn2_pkChain', 'Chain');
        html += me.getRadio('mn2_pk', 'mn2_pkStrand', 'Strand/Helix');
        html += me.getRadio('mn2_pk', 'mn2_pkResidue', 'Residue', true);
        html += me.getRadio('mn2_pk', 'mn2_pkYes', 'Atom');
        html += "    </ul>";
        html += "  </li>";
    }
    else {
        html += "  <li><span>Picking with<br>\"Alt\" + Click</span>";
    }

    html += "  <li>-</li>";

    html += me.getLink('mn2_saveselection', 'Save Selection');
    html += me.getLink('clearall', 'Clear Selection');

    html += "  <li>-</li>";

    html += "      <li><span>Highlight Color</span>";
    html += "        <ul>";
    html += me.getRadio('mn2_hl_clr', 'mn2_hl_clrYellow', 'Yellow', true);
    html += me.getRadio('mn2_hl_clr', 'mn2_hl_clrGreen', 'Green');
    html += me.getRadio('mn2_hl_clr', 'mn2_hl_clrRed', 'Red');
    html += "        </ul>";
    html += "      </li>";
    html += "      <li><span>Highlight Style</span>";
    html += "        <ul>";

    html += me.getRadio('mn2_hl_style', 'mn2_hl_styleOutline', 'Outline', true);
    html += me.getRadio('mn2_hl_style', 'mn2_hl_styleObject', '3D Objects');
    html += me.getRadio('mn2_hl_style', 'mn2_hl_styleNone', 'No Highlight');

    html += "        </ul>";
    html += "      </li>";

    //html += me.getLink('toggleHighlight2', 'Toggle Highlight');

    html += "  <li><br/></li>";

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu2b = function () {
    var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion2b'>";
    html += "<h3>View</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    html += me.getLink('mn2_show_selected', 'View Only <br>Selection');
    html += me.getLink('mn2_selectedcenter', 'Zoom in <br>Selection');
    html += me.getLink('mn6_center', 'Center on <br>Selection');
    if (me.cfg.align !== undefined) {
        html += me.getLink('mn2_alternate', 'Alternate (Key \"a\")');
    }

    html += "  <li>-</li>";

    if (me.cfg.cid === undefined) {
        html += "  <li><span>Chem. Binding</span>";
        html += "    <ul>";
        html += me.getRadio('mn6_chemicalbinding', 'mn6_chemicalbindingshow', 'Show');
        html += me.getRadio('mn6_chemicalbinding', 'mn6_chemicalbindinghide', 'Hide', true);
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>H-Bonds to</span><br/><span>Selection</span>";
        html += "    <ul>";
        html += me.getRadio('mn6_hbonds', 'mn6_hbondsYes', 'Show');
        html += me.getRadio('mn6_hbonds', 'mn6_hbondsNo', 'Hide', true);
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>Disulfide Bonds</span>";
        html += "    <ul>";
        html += me.getRadio('mn6_ssbonds', 'mn6_ssbondsYes', 'Show', true);
        html += me.getRadio('mn6_ssbonds', 'mn6_ssbondsNo', 'Hide');
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>Cross-Linkages</span>";
        html += "    <ul>";
        html += me.getRadio('mn6_clbonds', 'mn6_clbondsYes', 'Show');
        html += me.getRadio('mn6_clbonds', 'mn6_clbondsNo', 'Hide', true);
        html += "    </ul>";
        html += "  </li>";

        if (me.cfg.mmtfid !== undefined || me.cfg.pdbid !== undefined || me.cfg.mmcifid !== undefined || me.cfg.mmdbid !== undefined) {
            html += "  <li id='" + me.pre + "assemblyWrapper'><span>Assembly</span>";
            html += "    <ul>";

            html += me.getRadio('mn6_assembly', 'mn6_assemblyYes', 'Biological Assembly', true);
            html += me.getRadio('mn6_assembly', 'mn6_assemblyNo', 'Asymmetric Unit');

            html += "    </ul>";
            html += "  </li>";
        }
    }

    html += "  <li><span>Distance</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_distance', 'mn6_distanceYes', 'Measure');
    html += me.getRadio('mn6_distance', 'mn6_distanceNo', 'Hide', true);
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Label</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_addlabel', 'mn6_addlabelYes', 'by Picking Atoms');
    html += me.getRadio('mn6_addlabel', 'mn6_addlabelSelection', 'per Selection');
    if (me.cfg.cid === undefined) {
        html += me.getRadio('mn6_addlabel', 'mn6_addlabelResidues', 'per Residue');
        html += me.getRadio('mn6_addlabel', 'mn6_addlabelChains', 'per Chain');
    }
    html += me.getRadio('mn6_addlabel', 'mn6_addlabelNo', 'Remove', true);
    html += "    </ul>";
    html += "  </li>";

    html += "  <li>-</li>";

    html += "  <li><span>Reset</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_reset', 'reset', 'All');
    html += me.getRadio('mn6_reset', 'mn6_resetOrientation', 'Orientation');
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Transform Hints</span>";
    html += "    <ul>";
    html += "      <li><span>Rotate</span>";
    html += "          <ul>";
    html += "<li>Left Mouse</li>";
    html += "<li>Key L: Left</li>";
    html += "<li>Key J: Right</li>";
    html += "<li>Key I: Up</li>";
    html += "<li>Key M: Down</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "      <li><span>Zoom</span>";
    html += "          <ul>";
    html += "<li>Middle Mouse</li>";
    html += "<li>Key Z: Zoom in</li>";
    html += "<li>Key X: Zoom out</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "      <li><span>Translate</span>";
    html += "          <ul>";
    html += "<li>Right Mouse</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Auto Rotation</span>";
    html += "    <ul>";
    html += me.getLink('mn6_rotateleft', 'Rotate Left');
    html += me.getLink('mn6_rotateright', 'Rotate Right');
    html += me.getLink('mn6_rotateup', 'Rotate Up');
    html += me.getLink('mn6_rotatedown', 'Rotate Down');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Camera</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_camera', 'mn6_cameraPers', 'Perspective', true);
    html += me.getRadio('mn6_camera', 'mn6_cameraOrth', 'Orthographic');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Fog</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_showfog', 'mn6_showfogYes', 'On');
    html += me.getRadio('mn6_showfog', 'mn6_showfogNo', 'Off', true);
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Slab</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_showslab', 'mn6_showslabYes', 'On');
    html += me.getRadio('mn6_showslab', 'mn6_showslabNo', 'Off', true);
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>XYZ-axes</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_showaxis', 'mn6_showaxisYes', 'Show');
    html += me.getRadio('mn6_showaxis', 'mn6_showaxisNo', 'Hide', true);
    html += "    </ul>";
    html += "  </li>";

    html += me.getLink('mn6_back', 'Undo');
    html += me.getLink('mn6_forward', 'Redo');

    html += "  <li><br/></li>";

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu3 = function () {
    var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion3'>";
    html += "<h3 id='" + me.pre + "style'>Style</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    if (me.cfg.cid === undefined) {
        html += "  <li><span>Proteins</span>";
        html += "    <ul>";
        if (me.cfg.align !== undefined) {
            html += me.getRadio('mn3_proteins', 'mn3_proteinsRibbon', 'Ribbon');
        }
        else {
            html += me.getRadio('mn3_proteins', 'mn3_proteinsRibbon', 'Ribbon', true);
        }

        html += me.getRadio('mn3_proteins', 'mn3_proteinsStrand', 'Strand');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsCylinder', 'Cylinder and Plate');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsSchematic', 'Schematic');

        if (me.cfg.align !== undefined) {
            html += me.getRadio('mn3_proteins', 'mn3_proteinsCalpha', 'C Alpha Trace', true);
        }
        else {
            html += me.getRadio('mn3_proteins', 'mn3_proteinsCalpha', 'C Alpha Trace');
        }

        html += me.getRadio('mn3_proteins', 'mn3_proteinsBfactor', 'B Factor Tube');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsLines', 'Lines');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsStick', 'Stick');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsBallstick', 'Ball and Stick');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsSphere', 'Sphere');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsNo', 'Hide');
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>Side Chains</span>";
        html += "    <ul>";

        html += me.getRadio('mn3_sidec', 'mn3_sidecLines', 'Lines');
        html += me.getRadio('mn3_sidec', 'mn3_sidecStick', 'Stick');
        html += me.getRadio('mn3_sidec', 'mn3_sidecBallstick', 'Ball and Stick');
        html += me.getRadio('mn3_sidec', 'mn3_sidecSphere', 'Sphere');
        html += me.getRadio('mn3_sidec', 'mn3_sidecNo', 'Hide', true);
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>Nucleotides</span>";
        html += "    <ul>";
        html += me.getRadio('mn3_nucl', 'mn3_nuclCartoon', 'Cartoon', true);
        html += me.getRadio('mn3_nucl', 'mn3_nuclPhos', "O3' Trace");
        html += me.getRadio('mn3_nucl', 'mn3_nuclSchematic', 'Schematic')
        html += me.getRadio('mn3_nucl', 'mn3_nuclLines', 'Lines');
        html += me.getRadio('mn3_nucl', 'mn3_nuclStick', 'Stick');
        html += me.getRadio('mn3_nucl', 'mn3_nuclBallstick', 'Ball and Stick');
        html += me.getRadio('mn3_nucl', 'mn3_nuclSphere', 'Sphere');
        html += me.getRadio('mn3_nucl', 'mn3_nuclNo', 'Hide');
        html += "    </ul>";
        html += "  </li>";
    }

    html += "  <li><span>Chemicals</span>";
    html += "    <ul>";
    html += me.getRadio('mn3_lig', 'mn3_ligLines', 'Lines');
    if (me.cfg.cid === undefined) {
        html += me.getRadio('mn3_lig', 'mn3_ligStick', 'Stick', true);
        html += me.getRadio('mn3_lig', 'mn3_ligBallstick', 'Ball and Stick');
    }
    else {
        html += me.getRadio('mn3_lig', 'mn3_ligStick', 'Stick');
        html += me.getRadio('mn3_lig', 'mn3_ligBallstick', 'Ball and Stick', true);
    }
    html += me.getRadio('mn3_lig', 'mn3_ligSchematic', 'Schematic');
    html += me.getRadio('mn3_lig', 'mn3_ligSphere', 'Sphere');
    html += me.getRadio('mn3_lig', 'mn3_ligNo', 'Hide');
    html += "    </ul>";
    html += "  </li>";


    html += "  <li><span>Ions</span>";
    html += "    <ul>";
    html += me.getRadio('mn3_ions', 'mn3_ionsSphere', 'Sphere', true);
    html += me.getRadio('mn3_ions', 'mn3_ionsDot', 'Dot');
    html += me.getRadio('mn3_ions', 'mn3_ionsNo', 'Hide');
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Water</span>";
    html += "    <ul>";
    html += me.getRadio('mn3_water', 'mn3_waterSphere', 'Sphere');
    html += me.getRadio('mn3_water', 'mn3_waterDot', 'Dot');
    html += me.getRadio('mn3_water', 'mn3_waterNo', 'Hide', true);
    html += "    </ul>";
    html += "  </li>";

    html += "  <li>-</li>";

    html += "  <li><span>Surface Type</span>";
    html += "    <ul>";
    html += me.getRadio('mn5_surface', 'mn5_surfaceVDW', 'Van der Waals');
    html += me.getRadio('mn5_surface', 'mn5_surfaceVDWContext', 'VDW with Context');
    html += me.getRadio('mn5_surface', 'mn5_surfaceMolecular', 'Molecular Surface');
    html += me.getRadio('mn5_surface', 'mn5_surfaceMolecularContext', 'MS with Context');
    html += me.getRadio('mn5_surface', 'mn5_surfaceSAS', 'Solvent Accessible');
    html += me.getRadio('mn5_surface', 'mn5_surfaceSASContext', 'SA with Context');
    html += "    </ul>";
    html += "  </li>";

    html += me.getLink('mn5_surfaceNo', 'Remove Surface');

    html += "  <li><span>Surface Opacity</span>";
    html += "    <ul>";
    html += me.getRadio('mn5_opacity', 'mn5_opacity10', '1.0', true);
    html += me.getRadio('mn5_opacity', 'mn5_opacity09', '0.9');
    html += me.getRadio('mn5_opacity', 'mn5_opacity08', '0.8');
    html += me.getRadio('mn5_opacity', 'mn5_opacity07', '0.7');
    html += me.getRadio('mn5_opacity', 'mn5_opacity06', '0.6');
    html += me.getRadio('mn5_opacity', 'mn5_opacity05', '0.5');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Surface <br>Wireframe</span>";
    html += "    <ul>";
    html += me.getRadio('mn5_wireframe', 'mn5_wireframeYes', 'Yes');
    html += me.getRadio('mn5_wireframe', 'mn5_wireframeNo', 'No', true);
    html += "    </ul>";
    html += "  </li>";

    html += "  <li>-</li>";

    html += "  <li><span>Background</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_bkgd', 'mn6_bkgdTransparent', 'Transparent', true);
    html += me.getRadio('mn6_bkgd', 'mn6_bkgdBlack', 'Black');
    html += me.getRadio('mn6_bkgd', 'mn6_bkgdGrey', 'Grey');
    html += me.getRadio('mn6_bkgd', 'mn6_bkgdWhite', 'White');
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><br/></li>";

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu4 = function () {
    var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion4'>";
    html += "<h3 id='" + me.pre + "color'>Color</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    if (me.cfg.cid === undefined) {
        html += me.getRadio('mn4_clr', 'mn4_clrSpectrum', 'Spectrum');
        html += me.getRadio('mn4_clr', 'mn4_clrSS', 'Secondary');

        html += me.getRadio('mn4_clr', 'mn4_clrCharge', 'Charge');
        html += me.getRadio('mn4_clr', 'mn4_clrHydrophobic', 'Hydrophobic');

        html += me.getRadio('mn4_clr', 'mn4_clrChain', 'Chain', true);

        html += me.getRadio('mn4_clr', 'mn4_clrResidue', 'Residue');
        html += me.getRadio('mn4_clr', 'mn4_clrAtom', 'Atom');

        if (me.cfg.align !== undefined) {
            html += me.getRadio('mn4_clr', 'mn4_clrConserved', 'Identity');
        }

    }
    else {
        html += me.getRadio('mn4_clr', 'mn4_clrAtom', 'Atom', true);
    }

    html += "  <li>-</li>";
    html += "  <li><span style='padding-left:2em;'>Unicolor</span>";
    html += "    <ul>";
    html += me.getRadio('mn4_clr', 'mn4_clrRed', 'Red');
    html += me.getRadio('mn4_clr', 'mn4_clrGreen', 'Green');
    html += me.getRadio('mn4_clr', 'mn4_clrBlue', 'Blue');
    html += me.getRadio('mn4_clr', 'mn4_clrMagenta', 'Magenta');
    html += me.getRadio('mn4_clr', 'mn4_clrYellow', 'Yellow');
    html += me.getRadio('mn4_clr', 'mn4_clrCyan', 'Cyan');
    html += me.getRadio('mn4_clr', 'mn4_clrWhite', 'White');
    html += me.getRadio('mn4_clr', 'mn4_clrGrey', 'Grey');
    html += "    </ul>";
    html += "  <li>-</li>";
    html += me.getRadio('mn4_clr', 'mn4_clrCustom', 'Color Picker');
    html += "  <li><br/></li>";
    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu5 = function () {
    var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion5'>";
    html += "<h3 id='" + me.pre + "windows' style='font-size:1.2em'>&nbsp;Windows</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    if (me.cfg.cid === undefined) {
        html += me.getLink('mn6_selectannotations', 'View Sequences<br>& Annotations');

        if (me.cfg.align !== undefined) {
            html += me.getLink('mn2_alignment', 'View Aligned<br>Sequences');
        }

        //html += me.getLink('mn2_selectresidues', 'View Sequences');
        if (me.cfg.mmdbid !== undefined || me.cfg.align !== undefined) {
            html += me.getLink('mn2_2ddgm', 'View Interactions');
        }
    }

    if (me.cfg.cid !== undefined) {
        html += "  <li><span>Links</span>";
        html += "    <ul>";
        html += me.getLink('mn1_link_structure', 'Compound Summary');
        html += me.getLink('mn1_link_vast', 'Similar Compounds');
        html += me.getLink('mn1_link_bind', 'Structures Bound');
        html += "    </ul>";
        html += "  </li>";
    }
    else {
        html += "  <li><span>Links</span>";
        html += "    <ul>";
        html += me.getLink('mn1_link_structure', 'Structure Summary');
        html += me.getLink('mn1_link_vast', 'Similar Structures');
        html += me.getLink('mn1_link_pubmed', 'Literature');
        html += me.getLink('mn1_link_protein', 'Protein');
        //html += me.getLink('mn1_link_gene', 'Gene');
        //html += me.getLink('mn1_link_chemicals', 'Chemicals');
        html += "    </ul>";
        html += "  </li>";
    }

    html += "  <li><br/></li>";

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu6 = function () {
    var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion6'>";
    html += "<h3>Help</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    html += "  <li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/docs/icn3d_about.html' target='_blank'>About iCn3D</a></li>";

    html += "  <li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/docs/icn3d_help.html' target='_blank'>Help Doc</a></li>";

    html += "  <li><span>Web APIs</span>";
    html += "    <ul>";

    html += "<li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#HowToUse' target='_blank'>How to Use</a></li>";
    html += "<li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#parameters' target='_blank'>URL Parameters</a></li>";
    html += "<li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#commands' target='_blank'>Commands</a></li>";
    html += "    </ul>";
    html += "  </li>";

    html += "  <li>-</li>";

    html += "  <li><span>Transform Hints</span>";
    html += "    <ul>";
    html += "      <li><span>Rotate</span>";
    html += "          <ul>";
    html += "<li>Left Mouse</li>";
    html += "<li>Key L: Left</li>";
    html += "<li>Key J: Right</li>";
    html += "<li>Key I: Up</li>";
    html += "<li>Key M: Down</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "      <li><span>Zoom</span>";
    html += "          <ul>";
    html += "<li>Middle Mouse</li>";
    html += "<li>Key Z: Zoom in</li>";
    html += "<li>Key X: Zoom out</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "      <li><span>Translate</span>";
    html += "          <ul>";
    html += "<li>Right Mouse</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#HowToUseStep5' target='_blank'>Selection Hints</a></li>";

    html += "  <li><br/></li>";
    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setLogWindow = function () {
    var me = this;
    var html = "";

    html += "  <div id='" + me.pre + "cmdlog' style='float:left; margin-top: -5px; width: 100%;'>";

    html += "    <textarea id='" + me.pre + "logtext' rows='2' style='width: 100%; height: " + me.CMD_HEIGHT + "px; padding: 0px; border: 0px; background-color: " + me.GREYD + ";'></textarea>";
    html += "  </div>";

    return html;
};

iCn3DUI.prototype.setDialogs = function () {
    var me = this;
    var html = "";

    html += "<!-- dialog will not be part of the form -->";
    html += "<div id='" + me.pre + "alldialogs' class='icn3d-hidden icn3d-dialog'>";

    // filter for large structure
    //html += "<div id='" + me.pre + "dl_filter' style='overflow:auto; position:relative;'>";
    //html += "  <div style='text-align:center; margin-bottom:10px;'><button id='" + me.pre + "filter'><span style='white-space:nowrap'><b>Show Structure</b></span></button>";
    //html += "<button id='" + me.pre + "highlight_3d_dgm' style='margin-left:10px;'><span style='white-space:nowrap'><b>Highlight</b></span></button></div>";
    //html += "  <div id='" + me.pre + "dl_filter_table' class='icn3d-box'>";
    //html += "  </div>";
    //html += "</div>";

    html += "<div id='" + me.pre + "dl_2ddgm' class='icn3d-dl_2ddgm'>";
    html += "</div>";

    if (me.cfg.align !== undefined) {
        html += "<div id='" + me.pre + "dl_alignment' style='background-color:white;'>";
        html += "  <div id='" + me.pre + "dl_sequence2' class='icn3d-dl_sequence'>";
        html += "  </div>";
        html += "</div>";
    }

    html += "<div id='" + me.pre + "dl_definedsets'>";
    html += "    <b>Defined Sets:</b> <br/>";
    html += "    <select id='" + me.pre + "atomsCustom' multiple size='6' style='min-width:100px;'>";
    html += "    </select>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_command'>";
    html += "  <table width='500'><tr><td valign='top'><table>";
    html += "<tr><td align='right'><b>Select:</b></td><td><input type='text' id='" + me.pre + "command' placeholder='$[structures].[chains]:[residues]@[atoms]' size='30'></td></tr>";
    html += "<tr><td align='right'><b>Name:</b></td><td><input type='text' id='" + me.pre + "command_name' placeholder='my_selection' size='30'></td></tr>";
    //html += "<tr><td align='right'><b>Description:</b></td><td><input type='text' id='" + me.pre + "command_desc' placeholder='description about my selection' size='30'></td></tr>";
    html += "<tr><td colspan='2' align='center'><button id='" + me.pre + "command_apply'><b>Save Selection</b></button></td></tr>";
    html += "  </table></td>";

    html += "  </tr>";

    html += "  <tr><td>";

    html += 'Specification Tips: <div style="width:20px; margin-top:6px; display:inline-block;"><span id="' + me.pre + 'specguide_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'specguide_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div><br>';

    html += "<div id='" + me.pre + "specguide' style='display:none;' class='icn3d-box'>";

    html += "  <b>Specification:</b> In the selection \"$1HHO,4N7N.A,B,C:5-10,KRDE,chemicals@CA,C\":";
    html += "  <ul><li>\"$1HHO,4N7N\" uses \"$\" to indicate structure selection.<br/>";
    html += "  <li>\".A,B,C\" uses \".\" to indicate chain selection.<br/>";
    html += "  <li>\":5-10,KRDE,chemicals\" uses \":\" to indicate residue selection. Residue selection could be residue number (5-10), one-letter sequence (KRDE), or predefined names: \"proteins\", \"nucleotides\", \"chemicals\", \"ions\", and \"water\".<br/>";
    html += "  <li>\"@CA,C\" uses \"@\" to indicate atom selection.<br/>";
    html += "  <li>Partial definition is allowed, e.g., \":1-10\" selects all residue IDs 1-10 in all chains.<br/></ul>";
    html += "  <b>Set Operation:</b>";
    html += "  <ul><li>Users can select multiple items in \"All Selections\" above.<br/>";
    html += "  <li>Different selections can be unioned (with \"<b>or</b>\", default), intersected (with \"<b>and</b>\"), or negated (with \"<b>not</b>\"). For example, \":1-10 or :K\" selects all residues 1-10 and all Lys residues. \":1-10 and :K\" selects all Lys residues in the range of residue number 1-10. \":1-10 or not :K\" selects all residues 1-10, which are not Lys residues.</ul>";
    html += "  <b>Full commands in url or command window:</b>";
    html += "  <ul><li>Select without saving the set: select $1HHO,4N7N.A,B,C:5-10,KRDE,chemicals@CA,C<br/>";
    //html += "  <li>Select and save: select $1HHO,4N7N.A,B,C:5-10,KRDE,chemicals@CA,C | name my_name | description my_description</ul>";
    html += "  <li>Select and save: select $1HHO,4N7N.A,B,C:5-10,KRDE,chemicals@CA,C | name my_name</ul>";

    html += "</div>";

    html += "  </td></tr></table>";

    html += "</div>";

    html += "<div id='" + me.pre + "dl_mmtfid'>";
    html += "MMTF ID: <input type='text' id='" + me.pre + "mmtfid' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_mmtf'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_pdbid'>";
    html += "PDB ID: <input type='text' id='" + me.pre + "pdbid' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_pdb'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_pdbfile'>";
    html += "PDB File: <input type='file' id='" + me.pre + "pdbfile' size=8> ";
    html += "<button id='" + me.pre + "reload_pdbfile'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_align'>";
    html += "Enter the PDB IDs or MMDB IDs of two structures that have been found to be similar by <A HREF=' https://www.ncbi.nlm.nih.gov/Structure/VAST/vast.shtml'>VAST</A> or <A HREF=' https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi'>VAST+</A> : <br/><br/>ID1: <input type='text' id='" + me.pre + "alignid1' value='1HHO' size=8>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ID2: <input type='text' id='" + me.pre + "alignid2' value='4N7N' size=8><br/><br/>";
    html += "<button id='" + me.pre + "reload_align_refined'>Invariant Substructure Superposed</button>&nbsp;&nbsp;&nbsp;<button id='" + me.pre + "reload_align_ori'>All Matching Molecules Superposed</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_mol2file'>";
    html += "Mol2 File: <input type='file' id='" + me.pre + "mol2file' size=8> ";
    html += "<button id='" + me.pre + "reload_mol2file'>Load</button>";
    html += "</div>";
    html += "<div id='" + me.pre + "dl_sdffile'>";
    html += "SDF File: <input type='file' id='" + me.pre + "sdffile' size=8> ";
    html += "<button id='" + me.pre + "reload_sdffile'>Load</button>";
    html += "</div>";
    html += "<div id='" + me.pre + "dl_xyzfile'>";
    html += "XYZ File: <input type='file' id='" + me.pre + "xyzfile' size=8> ";
    html += "<button id='" + me.pre + "reload_xyzfile'>Load</button>";
    html += "</div>";
    html += "<div id='" + me.pre + "dl_urlfile'>";
    html += "File type: ";
    html += "<select id='" + me.pre + "filetype'>";
    html += "<option value='pdb' selected>pdb</option>";
    html += "<option value='mol2'>mol2</option>";
    html += "<option value='sdf'>sdf</option>";
    html += "<option value='xyz'>xyz</option>";
    html += "</select><br/>";
    html += "URL in the same host: <input type='text' id='" + me.pre + "urlfile' size=20><br/> ";
    html += "<button id='" + me.pre + "reload_urlfile'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_mmciffile'>";
    html += "mmCIF File: <input type='file' id='" + me.pre + "mmciffile' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_mmciffile'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_mmcifid'>";
    html += "mmCIF ID: <input type='text' id='" + me.pre + "mmcifid' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_mmcif'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_mmdbid'>";
    html += "MMDB ID: <input type='text' id='" + me.pre + "mmdbid' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_mmdb'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_gi'>";
    html += "Protein gi: <input type='text' id='" + me.pre + "gi' value='1310960' size=8> ";
    html += "<button id='" + me.pre + "reload_gi'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_cid'>";
    html += "PubChem CID: <input type='text' id='" + me.pre + "cid' value='2244' size=8> ";
    html += "<button id='" + me.pre + "reload_cid'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_state'>";
    html += "State file: <input type='file' id='" + me.pre + "state'><br/>";
    html += "<button id='" + me.pre + "reload_state' style='margin-top: 6px;'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_selection'>";
    html += "Selection file: <input type='file' id='" + me.pre + "selectionfile'><br/>";
    html += "<button id='" + me.pre + "reload_selectionfile' style='margin-top: 6px;'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_clr'>";
    html += "Click in the input box to use the color picker:<br><br> ";
    html += "Custom Color: <input type='text' id='" + me.pre + "colorcustom' value='FF0000' size=8> ";
    html += "<button id='" + me.pre + "applycustomcolor'>Apply</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_hbonds'>";
    html += "<div style='width:400px;'>To show hydrogen bonds between other residues and the current selection, please select the threshold of H-bonds.</div><br/>";
    html += "  <span style='white-space:nowrap;font-weight:bold;'>Threshold: <select id='" + me.pre + "hbondthreshold'>";
    html += "  <option value='3.2'>3.2</option>";
    html += "  <option value='3.3'>3.3</option>";
    html += "  <option value='3.4'>3.4</option>";
    html += "  <option value='3.5' selected>3.5</option>";
    html += "  <option value='3.6'>3.6</option>";
    html += "  <option value='3.7'>3.7</option>";
    html += "  <option value='3.8'>3.8</option>";
    html += "  <option value='3.9'>3.9</option>";
    html += "  <option value='4.0'>4.0</option>";
    html += "  </select> &#197;</span> <span style='white-space:nowrap; margin-left:30px;'><button id='" + me.pre + "applyhbonds'>Display</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_aroundsphere'>";
    html += "  <span style='white-space:nowrap'>1. Sphere with a radius: <input type='text' id='" + me.pre + "radius_aroundsphere' value='4' size='2'> &#197;</span><br/>";
    html += "  <span style='white-space:nowrap'>2. <button id='" + me.pre + "applypick_aroundsphere'>Display</button> the sphere around currently selected atoms</span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_addlabel'>";
    html += "1. Text: <input type='text' id='" + me.pre + "labeltext' value='Text' size=4><br/>";
    html += "2. Size: <input type='text' id='" + me.pre + "labelsize' value='18' size=4 maxlength=2><br/>";
    html += "3. Color: <input type='text' id='" + me.pre + "labelcolor' value='ffff00' size=4><br/>";
    html += "4. Background: <input type='text' id='" + me.pre + "labelbkgd' value='cccccc' size=4><br/>";
    html += "<span style='white-space:nowrap'>5. Pick TWO atoms while holding \"Alt\" key</span><br/>";
    html += "<span style='white-space:nowrap'>6. <button id='" + me.pre + "applypick_labels'>Display</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_addlabelselection'>";
    html += "1. Text: <input type='text' id='" + me.pre + "labeltext2' value='Text' size=4><br/>";
    html += "2. Size: <input type='text' id='" + me.pre + "labelsize2' value='18' size=4 maxlength=2><br/>";
    html += "3. Color: <input type='text' id='" + me.pre + "labelcolor2' value='ffff00' size=4><br/>";
    html += "4. Background: <input type='text' id='" + me.pre + "labelbkgd2' value='cccccc' size=4><br/>";
    html += "<span style='white-space:nowrap'>5. <button id='" + me.pre + "applyselection_labels'>Display</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_distance'>";
    html += "  <span style='white-space:nowrap'>1. Pick TWO atoms while holding \"Alt\" key</span><br/>";
    html += "  <span style='white-space:nowrap'>2. Color: <input type='text' id='" + me.pre + "distancecolor' value='ffff00' size=4><br/>";
    html += "  <span style='white-space:nowrap'>3. <button id='" + me.pre + "applypick_measuredistance'>Display</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_stabilizer'>";
    html += "  <span style='white-space:nowrap'>1. Pick TWO atoms while holding \"Alt\" key</span><br/>";
    html += "  <span style='white-space:nowrap'>2. Color: <input type='text' id='" + me.pre + "stabilizercolor' value='ffffff' size=4><br/>";
    html += "  <span style='white-space:nowrap'>3. <button id='" + me.pre + "applypick_stabilizer'>Add</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_stabilizer_rm'>";
    html += "  <span style='white-space:nowrap'>1. Pick TWO atoms while holding \"Alt\" key</span><br/>";
    html += "  <span style='white-space:nowrap'>2. <button id='" + me.pre + "applypick_stabilizer_rm'>Remove</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_thickness'>";
    html += "<b>Line Radius</b>: <input type='text' id='" + me.pre + "linerad' value='1' size=4>&nbsp;&nbsp;&nbsp;(for stabilizers, hydrogen bonds, distance lines, default 0.1)<br/>";
    html += "<b>Coil Radius</b>: <input type='text' id='" + me.pre + "coilrad' value='1.2' size=4>&nbsp;&nbsp;&nbsp;(for coils, default 0.3)<br/>";
    html += "<b>Stick Radius</b>: <input type='text' id='" + me.pre + "stickrad' value='0.8' size=4>&nbsp;&nbsp;&nbsp;(for sticks, default 0.4)<br/>";
    html += "<b>Trace Radius</b>: <input type='text' id='" + me.pre + "tracerad' value='1' size=4>&nbsp;&nbsp;&nbsp;(for C alpha trace, O3' trace, default 0.2)<br/>";

    html += "<b>Ribbon Thickness</b>: <input type='text' id='" + me.pre + "ribbonthick' value='1' size=4>&nbsp;&nbsp;&nbsp;(for helix and sheet ribbons, nucleotide ribbons, default 0.2)<br/>";
    html += "<b>Protein Ribbon Width</b>: <input type='text' id='" + me.pre + "prtribbonwidth' value='2.0' size=4>&nbsp;&nbsp;&nbsp;(for helix and sheet ribbons, default 1.3)<br/>";
    html += "<b>Nucleotide Ribbon Width</b>: <input type='text' id='" + me.pre + "nucleotideribbonwidth' value='1.4' size=4>&nbsp;&nbsp;&nbsp;(for nucleotide ribbons, default 0.8)<br/>";

    html += "<b>Ball Scale</b>: <input type='text' id='" + me.pre + "ballscale' value='0.6' size=4>&nbsp;&nbsp;&nbsp;(for styles 'Ball and Stick' and 'Dot', default 0.3)<br/>";

    html += "<span style='white-space:nowrap'><button id='" + me.pre + "apply_thickness'>Preview</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_addtrack'>";
    html += "     <input type='hidden' id='" + me.pre + "track_chainid' value=''>";

    html += "    <div id='" + me.pre + "dl_addtrack_tabs' style='border:0px;'>";
    html += "      <ul>";
    html += "        <li><a href='#" + me.pre + "tracktab5'>Current Selection</a></li>";
    html += "        <li><a href='#" + me.pre + "tracktab2'>FASTA</a></li>";
    html += "        <li><a href='#" + me.pre + "tracktab3'>BED file</a></li>";
    html += "        <li><a href='#" + me.pre + "tracktab4'>Custom</a></li>";
    html += "        <li><a href='#" + me.pre + "tracktab1'>NCBI gi/Accession</a></li>";
    html += "      </ul>";
    html += "      <div id='" + me.pre + "tracktab1'>";
    html += "NCBI gi/Accession: <input type='text' id='" + me.pre + "track_gi' placeholder='gi' size=16> <br><br>";
    html += "<button id='" + me.pre + "addtrack_button1'>Add Track</button>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "tracktab2'>";
    html += "FASTA sequence: <br><textarea id='" + me.pre + "track_fasta' rows='5' style='width: 100%; height: " + (2 * me.MENU_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
    html += "<button id='" + me.pre + "addtrack_button2'>Add Track</button>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "tracktab3'>";
    html += "BED file: <input type='file' id='" + me.pre + "track_bed' size=16> <br><br>";
    html += "<button id='" + me.pre + "addtrack_button3'>Add Track</button>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "tracktab4'>";
    html += "Track Title: <input type='text' id='" + me.pre + "track_title' placeholder='track title' size=16> <br><br>";
    html += "Track Text (e.g., \"152 G, 155-156 RR\" defines a character \"G\" at the position 152 and two continuous characters \"RR\" at positions from 155 to 156. The starting position is 1): <br>";
    html += "<textarea id='" + me.pre + "track_text' rows='5' style='width: 100%; height: " + (2 * me.MENU_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
    html += "<button id='" + me.pre + "addtrack_button4'>Add Track</button>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "tracktab5'>";
    html += "Track Title: <input type='text' id='" + me.pre + "track_selection' placeholder='track title' size=16> <br><br>";
    html += "<button id='" + me.pre + "addtrack_button5'>Add Track</button>";
    html += "      </div>";

    html += "    </div>";

    html += "</div>";

    html += "<div id='" + me.pre + "dl_saveselection'>";
    var index = (me.icn3d) ? Object.keys(me.icn3d.defNames2Atoms).length : 1;
    var suffix = '';
    html += "Name: <input type='text' id='" + me.pre + "seq_command_name" + suffix + "' value='seq_" + index + "' size='5'> <br>";
    //html += "Description: <input type='text' id='" + me.pre + "seq_command_desc" + suffix + "' value='seq_desc_" + index + "' size='10'> <br>";
    html += "<button style='white-space:nowrap;' id='" + me.pre + "seq_saveselection" + suffix + "'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "seq_clearselection" + suffix + "'>Clear</button><br/><br/>";
    html += "</div>";


    html += "<div id='" + me.pre + "dl_copyurl'>";
    html += "Please copy one of the URLs below. They work the same way.<br><br>";
    html += "Original URL with commands: <br><textarea id='" + me.pre + "ori_url' rows='4' style='width:100%'></textarea><br><br>";
    html += "Short URL: <br><input type='text' id='" + me.pre + "short_url' value='' style='width:100%'><br><br>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_selectannotations' class='icn3d-annotation' style='background-color:white;'>";

    html += "    <div id='" + me.pre + "dl_annotations_tabs'>";

    /*
        html += "    <table border=0><tr>";
        html += "    <td valign='top' width='100'>";
        html += "        <div style='margin-top:28px; white-space: nowrap;'><span id='" + me.pre + "viewdetail' style='display:none;' title='Expand the width of the annotation window to view the residue details'><b>Detailed View</b></span><span id='" + me.pre + "overview' class='icn3d-viewselection' title='Shrink the width of the annotaion window to overview'><b>Overview</b></span></div>";
        html += "        <label class='icn3d-switch'><input id='" + me.pre + "viewswitch' type='checkbox'><div class='icn3d-slider icn3d-round' style='width:34px; height:18px; margin: 16px 0px 0px 30px;' title='Left (\"Detailed View\")&#13;Right (\"Overview\")'></div></label>";
        html += "    </td>";
        html += "    <td>";
        html += "        <div style='border-left:1px solid #ccc; width:1px; height:40px;'></div>";
        html += "    </td>";
        html += "    <td>";
    */

    /*
        html += "        <div style='white-space: nowrap;'><span id='" + me.pre + "viewdetail' class='icn3d-large'><b>Sequence Details</b></span>";
        html += "        <label class='icn3d-switch'><input id='" + me.pre + "viewswitch' type='checkbox'><div class='icn3d-slider icn3d-round' style='width:34px; height:18px; display:inline-block; margin: 6px 0px 0px 145px;' title='Left (\"Detailed View\")&#13;Right (\"Overview\")'></div></label>";
        html += "        <span id='" + me.pre + "overview' style='margin-left:50px;' class='icn3d-viewselection icn3d-large'><b>Graphic Summary</b></span>";
    
        html += "<button style='white-space:nowrap; margin-left:50px' id='" + me.pre + "showallchains'>Show All Chains</button></div>";
    */

    html += "<div id='" + me.pre + "dl_anno_view_tabs' style='border:0px; height:33px;'>";
    html += "      <ul>";
    html += "        <li><a href='#" + me.pre + "anno_tmp1' id='" + me.pre + "anno_summary'>Summary</a></li>";
    html += "        <li><a href='#" + me.pre + "anno_tmp2' id='" + me.pre + "anno_details'>Details</a></li>";
    html += "      </ul>";
    html += "      <div id='" + me.pre + "anno_tmp1'>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "anno_tmp2'>";
    html += "      </div>";
    html += "</div>";

    html += "      <div class='icn3d-box'><table border=0><tr><td><b>Annotations:&nbsp;</b></td>";
    html += "        <td style='min-width:60px;'><input type='checkbox' id='" + me.pre + "anno_all'>All&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:130px;'><input type='checkbox' id='" + me.pre + "anno_cdd' checked>Conserved Domains&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:60px;'><input type='checkbox' id='" + me.pre + "anno_clinvar'>ClinVar&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:130px;'><input type='checkbox' id='" + me.pre + "anno_binding'>Functional Sites&nbsp;&nbsp;</td>";
    html += "      </tr><tr><td></td>";
    html += "        <td style='min-width:60px;'><input type='checkbox' id='" + me.pre + "anno_custom'>Custom&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:130px;'><input type='checkbox' id='" + me.pre + "anno_3dd'>3D Domains&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:60px;'><input type='checkbox' id='" + me.pre + "anno_snp'>SNPs&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:130px;'><input type='checkbox' id='" + me.pre + "anno_interact'>Interactions&nbsp;&nbsp;</td>";
    html += "        <td></td>";
    html += "      </tr></table></div>";

    html += "<button style='white-space:nowrap; margin-left:5px;' id='" + me.pre + "showallchains'>Show All Chains</button><br>";
    //    html += "    </td>";
    //    html += "    </tr></table>";

    html += "    <div id='" + me.pre + "seqguide_wrapper' style='display:none'><br>" + me.setSequenceGuide("2") + "</div>";

    // add note about assembly
    //html = "     <div id='" + me.pre + "assembly_note' class='icn3d-annoLargeTitle'><br>Only the asymmetric unit is shown in the sequence window.</div>";

    html += "    </div><br/><hr><br>";

    html += "    <div id='" + me.pre + "dl_annotations'>";
    html += "    </div>";
    html += "</div>";

    html += "</div>";
    html += "<!--/form-->";

    return html;
};

iCn3DUI.prototype.setSequenceGuide = function (suffix, bShown) {
    var me = this;
    var sequencesHtml = '';

    var index = (me.icn3d) ? Object.keys(me.icn3d.defNames2Atoms).length : 1;

    if (bShown) {
        sequencesHtml += "<div id='" + me.pre + "seqguide" + suffix + "'>";
    }
    else {
        sequencesHtml += '<div style="width:20px; margin-left:3px; display:inline-block;"><span id="' + me.pre + 'seqguide' + suffix + '_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'seqguide' + suffix + '_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div> ';

        //sequencesHtml += "<div style='min-width:200px; display:inline-block;'><b>Selection:</b> Name: <input type='text' id='" + me.pre + "seq_command_name" + suffix + "' value='seq_" + index + "' size='5'> &nbsp;&nbsp;Description: <input type='text' id='" + me.pre + "seq_command_desc" + suffix + "' value='seq_desc_" + index + "' size='10'> &nbsp;&nbsp;<button style='white-space:nowrap;' id='" + me.pre + "seq_saveselection" + suffix + "'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "seq_clearselection" + suffix + "'>Clear</button></div><br/>";
        sequencesHtml += "<div style='min-width:200px; display:inline-block;'><b>Selection:</b> Name: <input type='text' id='" + me.pre + "seq_command_name" + suffix + "' value='seq_" + index + "' size='5'> &nbsp;&nbsp;<button style='white-space:nowrap;' id='" + me.pre + "seq_saveselection" + suffix + "'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "seq_clearselection" + suffix + "'>Clear</button></div><br/>";

        sequencesHtml += "<div id='" + me.pre + "seqguide" + suffix + "' style='display:none; white-space:normal;' class='icn3d-box'>";
    }

    if (!me.isMobile()) {
        sequencesHtml += "<b>Select on 1D sequences:</b> drag to select, drag again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/><br/>";

        sequencesHtml += "<b>Select on 2D interaction diagram:</b> click on the nodes or lines. The nodes are chains and can be united with the Ctrl key. The lines are interactions and can NOT be united. Each click on the lines selects half of the lines, i.e., select the interacting residues in one of the two chains. The selected residues are saved in the \"Select -> Advanced\" menu.<br/><br/>";

        sequencesHtml += "<b>Select on 3D structures:</b> hold \"Alt\" and use mouse to pick, click the second time to deselect, hold \"Ctrl\" to union selection, hold \"Shift\" to select a range, press the up/down arrow to switch among atom/residue/strand/chain/structure, click \"Save Selection\" to save the current selection.<br/><br/>";

        sequencesHtml += "<b>Save the current selection</b> (either on 3D structure, 2D interactions, or 1D sequence): open the menu \"Select -> Save Selection\", specify the name and description for the selection, and click \"Save\".<br/><br/>";
    }
    else {
        sequencesHtml += "<b>Select Sequences:</b> touch to select, touch again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/><br/>";
    }

    var resCategories = "<b>Residue labeling:</b> standard residue with coordinates: UPPER case letter; nonstandard residue with coordinates: the first UPPER case letter plus a period except that water residue uses the letter 'O'; residue missing coordinates: lower case letter.";
    var scroll = (me.isMac() && !me.isMobile()) ? "<br/><br/><b>Turn on scroll bar:</b> System preferences -> General -> show scroll bars -> check Always" : "";

    sequencesHtml += resCategories + scroll + "<br/></div>";

    return sequencesHtml;
};

iCn3DUI.prototype.getAlignSequencesAnnotations = function (alignChainArray, bUpdateHighlightAtoms, residueArray, bShowHighlight) {
    var me = this;
    var resCategories = "<b>Residue labeling:</b> aligned residue with coordinates: UPPER case letter; non-aligned residue with coordinates: lower case letter which can be highlighted; residue missing coordinates: lower case letter which can NOT be highlighted.";
    var scroll = (me.isMac() && !me.isMobile()) ? "<br/><b>Turn on scroll bar:</b> System preferences -> General -> show scroll bars -> check Always" : "";

    var sequencesHtml;

    if (!me.isMobile()) {
        sequencesHtml = "<b>Select on 1D sequences:</b> drag to select, drag again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/>";

        sequencesHtml += "<b>Select on 2D interaction diagram:</b> click on the nodes or lines. The nodes are chains and can be united with the Ctrl key. The lines are interactions and can NOT be united. Each click on the lines selects half of the lines, i.e., select the interacting residues in one of the two chains. The selected residues are saved in the \"Select -> Advanced\" menu.<br/><br/>";

        sequencesHtml += "<b>Select on 3D structures:</b> hold \"Alt\" and use mouse to pick, click the second time to deselect, hold \"Ctrl\" to union selection, hold \"Shift\" to select a range, press the up/down arrow to switch among atom/residue/strand/chain/structure, click \"Save Selection\" to save the current selection.<br/>";

        sequencesHtml += "<b>Save the current selection</b> (either on 3D structure, 2D interactions, or 1D sequence): open the menu \"Select -> Save Selection\", specify the name and description for the selection, and click \"Save\".<br/><br/>";
    }
    else {
        sequencesHtml = "<b>Select Aligned Sequences:</b> touch to select, touch again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/>";
    }

    //sequencesHtml += "<div style='min-width:200px;'><b>Selection:</b> Name: <input type='text' id='" + me.pre + "alignseq_command_name' value='alseq_" + Object.keys(me.icn3d.defNames2Atoms).length + "' size='10'> &nbsp;&nbsp;Description: <input type='text' id='" + me.pre + "alignseq_command_desc' value='alseq_desc_" + Object.keys(me.icn3d.defNames2Atoms).length + "' size='20'> <button style='white-space:nowrap;' id='" + me.pre + "alignseq_saveselection'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "alignseq_clearselection'>Clear</button></div><br/>";
    sequencesHtml += "<div style='min-width:200px;'><b>Selection:</b> Name: <input type='text' id='" + me.pre + "alignseq_command_name' value='alseq_" + Object.keys(me.icn3d.defNames2Atoms).length + "' size='10'> &nbsp;&nbsp;<button style='white-space:nowrap;' id='" + me.pre + "alignseq_saveselection'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "alignseq_clearselection'>Clear</button></div><br/>";

    sequencesHtml += resCategories + scroll + "<br/>";

    var maxSeqCnt = 0;

    var chainHash = {};
    if (alignChainArray !== undefined) {
        for (var i = 0, il = alignChainArray.length; i < il; ++i) {
            chainHash[alignChainArray[i]] = 1;
        }
    }

    for (var i in me.icn3d.alnChains) {
        var bHighlightChain = (alignChainArray !== undefined && chainHash.hasOwnProperty(i)) ? true : false;

        if (bHighlightChain && (bUpdateHighlightAtoms === undefined || bUpdateHighlightAtoms)) {
            me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.alnChains[i]);
        }

        var resiHtmlArray = [], seqHtml = "";
        var seqLength = (me.icn3d.alnChainsSeq[i] !== undefined) ? me.icn3d.alnChainsSeq[i].length : 0;

        if (seqLength > maxSeqCnt) maxSeqCnt = seqLength;

        var dashPos = i.indexOf('_');
        var structure = i.substr(0, dashPos);
        var chain = i.substr(dashPos + 1);

        seqHtml += "<span class='icn3d-residueNum' title='starting residue number'>" + me.icn3d.alnChainsSeq[i][0].resi + "</span>";
        var bHighlightChain = (alignChainArray !== undefined && chainHash.hasOwnProperty(i)) ? true : false;

        for (var k = 0, kl = seqLength; k < kl; ++k) {
            // resiId is empty if it's gap
            var resiId = 'N/A', resIdFull = '', color = '#000';
            if (me.icn3d.alnChainsSeq[i][k].resi !== '' && !isNaN(me.icn3d.alnChainsSeq[i][k].resi)) {
                resiId = me.icn3d.alnChainsSeq[i][k].resi;
                resIdFull = structure + "_" + chain + "_" + resiId;
                color = me.icn3d.alnChainsSeq[i][k].color;
            }

            var classForAlign = "class='icn3d-residue"; // used to identify a residue when clicking a residue in sequence

            //if( (bShowHighlight === undefined || bShowHighlight) && (bHighlightChain || (me.icn3d.alnChainsSeq[i][k].aligned === 2 && residueArray !== undefined && resIdFull !== '' && residueArray.indexOf(resIdFull) !== -1) ) ) {
            if ((bShowHighlight === undefined || bShowHighlight) && (bHighlightChain || (residueArray !== undefined && resIdFull !== '' && residueArray.indexOf(resIdFull) !== -1))) {
                classForAlign = "class='icn3d-residue icn3d-highlightSeq";
            }

            // class for alignment: cons, ncons, nalign
            if (resIdFull === '') {
                classForAlign += "'";
            }
            else {
                classForAlign += " " + me.icn3d.alnChainsSeq[i][k].class + "'";
            }

            var colorRes;
            if (!me.icn3d.residues.hasOwnProperty(resIdFull)) {
                colorRes = '#000000;';
            }
            else {
                var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.residues[resIdFull]);
                colorRes = (firstAtom.color !== undefined) ? '#' + firstAtom.color.getHexString() + ';' : '#000000;';
            }

            if (colorRes.toUpperCase() === '#FFFFFF;') colorRes = me.GREYD;

            var bWithCoord = (resIdFull !== '') ? true : false;

            if (bWithCoord) {
                if (me.icn3d.alnChainsSeq[i][k].resi != -1) {
                    // add "align" in front of id so that full sequence and aligned sequence will not conflict
                    seqHtml += "<span id='align_" + me.pre + resIdFull + "' " + classForAlign + " style='color:" + colorRes + "' title='" + me.icn3d.alnChainsSeq[i][k].resn + me.icn3d.alnChainsSeq[i][k].resi + "'>" + me.icn3d.alnChainsSeq[i][k].resn + "</span>";
                }
                else {
                    seqHtml += "<span>" + me.icn3d.alnChainsSeq[i][k].resn + "</span>";
                }
            }
            else {
                seqHtml += "<span title='" + me.icn3d.alnChainsSeq[i][k].resn + me.icn3d.alnChainsSeq[i][k].resi + "'>" + me.icn3d.alnChainsSeq[i][k].resn + "</span>";
            }

        }
        seqHtml += "<span class='icn3d-residueNum' title='ending residue number'>" + me.icn3d.alnChainsSeq[i][seqLength - 1].resi + "</span>";

        // the first chain stores all annotations
        var annoLength = (me.icn3d.alnChainsAnno[i] !== undefined) ? me.icn3d.alnChainsAnno[i].length : 0;

        for (var j = 0, jl = annoLength; j < jl; ++j) {
            resiHtmlArray[j] = "";

            var chainid = (j == 0) ? me.icn3d.alnChainsAnTtl[i][4][0] : i; // bottom secondary, j == 0: chain2,  next secondary, j == 1: chain1,

            resiHtmlArray[j] += "<span class='icn3d-residueNum'></span>"; // a spot corresponding to the starting and ending residue number
            for (var k = 0, kl = me.icn3d.alnChainsAnno[i][j].length; k < kl; ++k) {
                var text = me.icn3d.alnChainsAnno[i][j][k];

                if (text == 'H' || text == 'E' || text == 'c' || text == 'o') {

                    if (text == 'H') {
                        if (k % 2 == 0) {
                            resiHtmlArray[j] += '<span class="icn3d-helix">&nbsp;</span>';
                        }
                        else {
                            resiHtmlArray[j] += '<span class="icn3d-helix2">&nbsp;</span>';
                        }
                    }
                    else if (text == 'E') {
                        if (me.icn3d.alnChainsSeq[chainid][k] !== undefined) {
                            //var resiId = me.icn3d.alnChainsSeq[i][k].resi;
                            var resiId = me.icn3d.alnChainsSeq[chainid][k].resi;
                            var resIdFull = chainid + "_" + resiId;

                            if (me.icn3d.residues.hasOwnProperty(resIdFull)) {
                                var atom = me.icn3d.getFirstAtomObj(me.icn3d.residues[resIdFull]);

                                if (atom.ssend) {
                                    resiHtmlArray[j] += '<span class="icn3d-sheet2">&nbsp;</span>';
                                }
                                else {
                                    resiHtmlArray[j] += '<span class="icn3d-sheet">&nbsp;</span>';
                                }
                            }
                        }
                    }
                    else if (text == 'c') {
                        resiHtmlArray[j] += '<span class="icn3d-coil">&nbsp;</span>';
                    }
                    else if (text == 'o') {
                        resiHtmlArray[j] += '<span class="icn3d-other">&nbsp;</span>';
                    }
                    else {
                        resiHtmlArray[j] += "<span></span>";
                    }
                }
                else {
                    resiHtmlArray[j] += "<span>" + text + "</span>";
                }
                //resiHtmlArray[j] += "<span>" + me.icn3d.alnChainsAnno[i][j][k] + "</span>";
            }
            resiHtmlArray[j] += "<span class='icn3d-residueNum'></span>"; // a spot corresponding to the starting and ending residue number
        }

        var chainidTmp = i, title = (me.icn3d.pdbid_chain2title !== undefined) ? me.icn3d.pdbid_chain2title[i] : '';

        // add markers and residue numbers
        for (var j = annoLength - 1; j >= 0; --j) {
            var annotitle = me.icn3d.alnChainsAnTtl[i][j][0];
            if (annotitle == 'SS') annotitle = '';
            //sequencesHtml += "<div class='icn3d-residueLine' style='white-space:nowrap;'><div class='icn3d-seqTitle' chain='" + i + "' anno='" + j + "'>" + annotitle + "</div>" + resiHtmlArray[j] + "<br/></div>";
            sequencesHtml += "<div class='icn3d-residueLine' style='white-space:nowrap;'><div class='icn3d-seqTitle' anno='" + j + "'>" + annotitle + "</div>" + resiHtmlArray[j] + "<br/></div>";
        }

        sequencesHtml += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" chain="' + i + '" anno="sequence" title="' + title + '">' + chainidTmp + ' </div><span class="icn3d-seqLine">' + seqHtml + '</span><br/>';
    }

    return { "sequencesHtml": sequencesHtml, "maxSeqCnt": maxSeqCnt };
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.openDialogHalfWindow = function (id, title, dialogWidth, bForceResize) {
    var me = this;
    var twoddgmWidth = 170;

    me.resizeCanvas(me.WIDTH - dialogWidth - me.LESSWIDTH, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, bForceResize);

    height = me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT;
    width = dialogWidth;

    var position;
    if (me.cfg.showmenu) {
        //position ={ my: "left top", at: "right top+80", of: "#" + me.pre + "viewer", collision: "none" };
        position = { my: "left top", at: "right top+40", of: "#" + me.pre + "viewer", collision: "none" };
    }
    else {
        position = { my: "left top", at: "right top", of: "#" + me.pre + "viewer", collision: "none" };
    }

    // disable resize
    me.cfg.resize = false;

    window.dialog = $("#" + id).dialog({
        autoOpen: true,
        title: title,
        height: height,
        width: width,
        modal: false,
        position: position,
        close: function (e) {
            // determine whether dialogs initilaized
            var bSelectannotationsInit = $('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content'); // initialized
            var bAlignmentInit = $('#' + me.pre + 'dl_alignment').hasClass('ui-dialog-content'); // initialized
            var bTwoddgmInit = $('#' + me.pre + 'dl_2ddgm').hasClass('ui-dialog-content'); // initialized
            var bSetsInit = $('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content'); // initialized

            var bSelectannotationsInit2 = false, bAlignmentInit2 = false, bTwoddgmInit2 = false, bSetsInit2 = false;
            if (bSelectannotationsInit) bSelectannotationsInit2 = $('#' + me.pre + 'dl_selectannotations').dialog('isOpen');
            if (bAlignmentInit) bAlignmentInit2 = $('#' + me.pre + 'dl_alignment').dialog('isOpen');
            if (bTwoddgmInit) bTwoddgmInit2 = $('#' + me.pre + 'dl_2ddgm').dialog('isOpen');
            if (bSetsInit) bSetsInit2 = $('#' + me.pre + 'dl_definedsets').dialog('isOpen');

            if ((id === me.pre + 'dl_selectannotations' && (!bAlignmentInit2))
                || (id === me.pre + 'dl_alignment' && (!bSelectannotationsInit2))
            ) {
                if (bTwoddgmInit2 || bSetsInit2) {
                    me.resizeCanvas(me.WIDTH - me.LESSWIDTH - twoddgmWidth, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);

                    if (bTwoddgmInit2) me.openDialog2Ddgm(me.pre + 'dl_2ddgm');
                    if (bSetsInit2) me.openDialog2Ddgm(me.pre + 'dl_definedsets');
                }
                else {
                    me.resizeCanvas(me.WIDTH - me.LESSWIDTH, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);
                }
            }
        },
        resize: function (e) {
            if (id == me.pre + 'dl_selectannotations') {
                me.hideFixedTitle();
            }
        }
    });
};

iCn3DUI.prototype.openDialog2Ddgm = function (id, inHeight) {
    var me = this;
    var twoddgmWidth = 170;
    var at, title;
    if (id === me.pre + 'dl_definedsets') {
        at = "right top";
        title = 'Select sets';
    }
    else if (id === me.pre + 'dl_2ddgm') {
        at = "right top+190";
        title = 'Interactions';
    }

    //var position ={ my: "left top", at: at, of: "#" + me.pre + "canvas", collision: "none" };
    var position = { my: "left top+" + me.MENU_HEIGHT, at: at, of: "#" + me.pre + "viewer", collision: "none" };

    var height = 'auto';

    window.dialog = $('#' + id).dialog({
        autoOpen: true,
        title: title,
        height: height,
        width: twoddgmWidth,
        modal: false,
        position: position,
        close: function (e) {
            // determine whether dialogs initilaized
            var bSelectannotationsInit = $('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content'); // initialized
            var bAlignmentInit = $('#' + me.pre + 'dl_alignment').hasClass('ui-dialog-content'); // initialized
            var bTwoddgmInit = $('#' + me.pre + 'dl_2ddgm').hasClass('ui-dialog-content'); // initialized
            var bSetsInit = $('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content'); // initialized

            var bSelectannotationsInit2 = false, bAlignmentInit2 = false, bTwoddgmInit2 = false, bSetsInit2 = false;
            if (bSelectannotationsInit) bSelectannotationsInit2 = $('#' + me.pre + 'dl_selectannotations').dialog('isOpen');
            if (bAlignmentInit) bAlignmentInit2 = $('#' + me.pre + 'dl_alignment').dialog('isOpen');
            if (bTwoddgmInit) bTwoddgmInit2 = $('#' + me.pre + 'dl_2ddgm').dialog('isOpen');
            if (bSetsInit) bSetsInit2 = $('#' + me.pre + 'dl_definedsets').dialog('isOpen');

            if ((!bSelectannotationsInit2) && (!bAlignmentInit2)) {
                me.resizeCanvas(me.WIDTH - me.LESSWIDTH, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);
            }
        }
    });
};

iCn3DUI.prototype.openDialog = function (id, title) {
    var me = this;
    var width = 400, height = 150;
    var twoddgmWidth = 170;

    var bSelectannotationsInit = $('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content'); // initialized
    var bAlignmentInit = $('#' + me.pre + 'dl_alignment').hasClass('ui-dialog-content'); // initialized
    var bTwoddgmInit = $('#' + me.pre + 'dl_2ddgm').hasClass('ui-dialog-content'); // initialized
    var bSetsInit = $('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content'); // initialized

    var bSelectannotationsInit2 = false, bAlignmentInit2 = false, bTwoddgmInit2 = false, bSetsInit2 = false;
    if (bSelectannotationsInit) bSelectannotationsInit2 = $('#' + me.pre + 'dl_selectannotations').dialog('isOpen');
    if (bAlignmentInit) bAlignmentInit2 = $('#' + me.pre + 'dl_alignment').dialog('isOpen');
    if (bTwoddgmInit) bTwoddgmInit2 = $('#' + me.pre + 'dl_2ddgm').dialog('isOpen');
    if (bSetsInit) bSetsInit2 = $('#' + me.pre + 'dl_definedsets').dialog('isOpen');

    if (id === me.pre + 'dl_selectannotations' || id === me.pre + 'dl_alignment') {
        var dialogWidth = 0.5 * (me.WIDTH - me.LESSWIDTH) - twoddgmWidth * 0.5;

        if (me.WIDTH - me.LESSWIDTH >= me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) {
            me.openDialogHalfWindow(id, title, dialogWidth, true);

            if (bTwoddgmInit2 || bSetsInit2) {
                me.resizeCanvas(me.WIDTH - me.LESSWIDTH - dialogWidth - twoddgmWidth, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);

                if (bTwoddgmInit2) me.openDialog2Ddgm(me.pre + 'dl_2ddgm');
                if (bSetsInit2) me.openDialog2Ddgm(me.pre + 'dl_definedsets');
            }
        }
        else {
            me.resizeCanvas(me.WIDTH - me.LESSWIDTH, (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) * 0.5, true);

            height = (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) * 0.5;

            width = me.WIDTH - me.LESSWIDTH;

            var position = { my: "left top", at: "left bottom+32", of: "#" + me.pre + "canvas", collision: "none" };

            window.dialog = $("#" + id).dialog({
                autoOpen: true,
                title: title,
                height: height,
                width: width,
                modal: false,
                position: position,
                close: function (e) {
                    // determine whether dialogs initilaized
                    var bSelectannotationsInit = $('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content'); // initialized
                    var bAlignmentInit = $('#' + me.pre + 'dl_alignment').hasClass('ui-dialog-content'); // initialized
                    var bTwoddgmInit = $('#' + me.pre + 'dl_2ddgm').hasClass('ui-dialog-content'); // initialized
                    var bSetsInit = $('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content'); // initialized

                    var bSelectannotationsInit2 = false, bAlignmentInit2 = false, bTwoddgmInit2 = false, bSetsInit2 = false;
                    if (bSelectannotationsInit) bSelectannotationsInit2 = $('#' + me.pre + 'dl_selectannotations').dialog('isOpen');
                    if (bAlignmentInit) bAlignmentInit2 = $('#' + me.pre + 'dl_alignment').dialog('isOpen');
                    if (bTwoddgmInit) bTwoddgmInit2 = $('#' + me.pre + 'dl_2ddgm').dialog('isOpen');
                    if (bSetsInit) bSetsInit2 = $('#' + me.pre + 'dl_definedsets').dialog('isOpen');

                    if ((id === me.pre + 'dl_selectannotations' && (!bAlignmentInit2))
                        || (id === me.pre + 'dl_alignment' && (!bSelectannotationsInit2))
                    ) {
                        if (bTwoddgmInit2 || bSetsInit2) {
                            me.resizeCanvas(me.WIDTH - me.LESSWIDTH - twoddgmWidth, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);

                            if (bTwoddgmInit2) me.openDialog2Ddgm(me.pre + 'dl_2ddgm');
                            if (bSetsInit2) me.openDialog2Ddgm(me.pre + 'dl_definedsets');
                        }
                        else {
                            me.resizeCanvas(me.WIDTH - me.LESSWIDTH, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);
                        }
                    }
                },
                resize: function (e) {
                    if (id == me.pre + 'dl_selectannotations') {
                        me.hideFixedTitle();
                    }
                }
            });
        }
    }
    else {
        height = 'auto';
        width = 'auto';

        if (id === me.pre + 'dl_addtrack') {
            width = '50%';
        }

        var position;

        if (id === me.pre + 'dl_2ddgm' || id === me.pre + 'dl_definedsets') {
            var tmpWidth = 0;
            if (me.WIDTH - me.LESSWIDTH >= me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) {
                if (bSelectannotationsInit2 || bAlignmentInit2) {
                    tmpWidth = 0.5 * (me.WIDTH - me.LESSWIDTH) - twoddgmWidth * 0.5;
                }
                me.resizeCanvas(me.WIDTH - me.LESSWIDTH - tmpWidth - twoddgmWidth, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);
                me.openDialog2Ddgm(id);
            }
            else {
                me.resizeCanvas(me.WIDTH - me.LESSWIDTH - tmpWidth - twoddgmWidth, (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) * 0.5, true);
                me.openDialog2Ddgm(id, (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) * 0.5);
            }
        }
        else {
            if (me.isMobile()) {
                position = { my: "left top", at: "left bottom-50", of: "#" + me.pre + "canvas", collision: "none" };
            }
            else {
                position = { my: "left top", at: "left top+50", of: "#" + me.pre + "canvas", collision: "none" };
            }

            window.dialog = $("#" + id).dialog({
                autoOpen: true,
                title: title,
                height: height,
                width: width,
                modal: false,
                position: position
            });
        }
    }

    $(".ui-dialog .ui-button span")
        .removeClass("ui-icon-closethick")
        .addClass("ui-icon-close");
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// draw 2D dgm for MMDB ID
// Used as a reference the work at 2016 ISMB hackathon: https://github.com/NCBI-Hackathons/3D_2D_Rep_Structure
// bUpdate: redraw 2Ddiagramfor the displayed structure
iCn3DUI.prototype.draw2Ddgm = function (data, mmdbid, structureIndex, bUpdate) {
    var me = this;
    // only show the 2D diagrams for displayed structures

    // reduce the size from 300 to 150
    var factor = 0.5;

    // set molid2chain
    var molid2chain = {}, molid2color = {}, molid2name = {}, chainid2molid = {};
    var chainNameHash = {};

    if (data === undefined) return '';

    for (var molid in data.moleculeInfor) {
        var color = '#' + ('000000' + data.moleculeInfor[molid].color.toString(16)).slice(- 6);
        var chainName = data.moleculeInfor[molid].chain.trim();
        if (chainNameHash[chainName] === undefined) {
            chainNameHash[chainName] = 1;
        }
        else {
            ++chainNameHash[chainName];
        }

        var chainNameFinal = (chainNameHash[chainName] === 1) ? chainName : chainName + chainNameHash[chainName].toString();
        var chainid = mmdbid + '_' + chainNameFinal;

        molid2chain[molid] = chainid;
        molid2color[molid] = color;
        molid2name[molid] = data.moleculeInfor[molid].name;

        chainid2molid[chainid] = molid;
    }

    // save the interacting residues
    if (bUpdate === undefined || !bUpdate) {
        for (var i = 0, il = data['intracResidues'].length; i < il; ++i) {
            var pair = data['intracResidues'][i];

            var index = 0;
            var chainid1, chainid2;

            for (var molid in pair) {
                //molid = parseInt(molid);

                var chainid;

                chainid = molid2chain[molid];
                if (index === 0) {
                    chainid1 = chainid;
                }
                else {
                    chainid2 = chainid;
                }

                ++index;
            }

            index = 0;
            for (var molid in pair) {
                var resArray = pair[molid];

                var fisrtChainid, secondChainid;
                if (index === 0) {
                    fisrtChainid = chainid1;
                    secondChainid = chainid2;
                }
                else {
                    fisrtChainid = chainid2;
                    secondChainid = chainid1;
                }

                if (me.chainids2resids[fisrtChainid] === undefined) {
                    me.chainids2resids[fisrtChainid] = {};
                }

                if (me.chainids2resids[fisrtChainid][secondChainid] === undefined) {
                    me.chainids2resids[fisrtChainid][secondChainid] = [];
                }

                for (var j = 0, jl = resArray.length; j < jl; ++j) {
                    var res = resArray[j];
                    var resid = me.mmdbMolidResid2mmdbChainResi[mmdbid.toUpperCase() + '_' + molid + '_' + res];

                    me.chainids2resids[fisrtChainid][secondChainid].push(resid);
                }

                // update me.chainname2residues
                if (me.chainname2residues === undefined) me.chainname2residues = {};

                var chainid2 = secondChainid;

                var atom2 = me.icn3d.getFirstAtomObj(me.icn3d.chains[chainid2]);
                //if(me.chainname2residues[chainid2] === undefined) me.chainname2residues[chainid2] = {};

                var type2;
                if (me.icn3d.chemicals.hasOwnProperty(atom2.serial)) { // 1. chemical interacting with proteins
                    type2 = 'chemical';
                }
                else if (me.icn3d.nucleotides.hasOwnProperty(atom2.serial)) { // 2. DNA interacting with proteins
                    type2 = 'nucleotide';
                }
                else if (me.icn3d.ions.hasOwnProperty(atom2.serial)) { // 3. ions interacting with proteins
                    type2 = 'ion';
                }
                else if (me.icn3d.proteins.hasOwnProperty(atom2.serial)) { // 4. protein interacting with proteins
                    type2 = 'protein';
                }

                var name = chainid2.substr(chainid2.indexOf('_') + 1) + "(" + type2 + ")";

                if (me.chainname2residues[fisrtChainid] === undefined) me.chainname2residues[fisrtChainid] = {};

                me.chainname2residues[fisrtChainid][name] = me.chainids2resids[fisrtChainid][secondChainid];


                ++index;
            }
        }
    }

    var html = "<div id='#" + me.pre + mmdbid + "'>";

    html += "<b>" + mmdbid.toUpperCase() + "</b><br/>";

    html += "<svg viewBox='0,0,150,150'>";
    var strokecolor = '#000000';
    var strokewidth = '1';
    var linestrokewidth = '2';
    var textcolor = '#000000';
    var fontsize = '10';
    var smallfontsize = '8';
    var adjustx = 0, adjusty = 4, smalladjustx = 1, smalladjusty = 2, halfLetHigh = 6;

    var posHash = {};
    var lines = [];

    var nodeHtml = "";

    var alignedAtomArray = [];

    var displayedMolids = {};
    if (bUpdate !== undefined && bUpdate) {
        // get all displayed chains
        for (var i in me.icn3d.dAtoms) {
            var atom = me.icn3d.atoms[i];
            var chainid = atom.structure + '_' + atom.chain;
            var molid = chainid2molid[chainid];

            displayedMolids[molid] = 1;
        }
    }

    for (var molid in data.intrac) {
        // if redraw2d diagram and the molid is not displayed, skip
        if (bUpdate !== undefined && bUpdate && !displayedMolids.hasOwnProperty(molid)) continue;

        var dgm = data.intrac[molid];
        var color = "#FFFFFF";
        var oricolor = molid2color[molid];
        var alignNum = "";
        if (structureIndex !== undefined && structureIndex === 0) {
            if (me.alignmolid2color !== undefined && me.alignmolid2color[0].hasOwnProperty(molid)) {
                //color = me.alignmolid2color[0][molid];
                alignNum = me.alignmolid2color[0][molid];
                oricolor = "#FF0000";
            }
            else {
                oricolor = "#FFFFFF";
            }
        }
        else if (structureIndex !== undefined && structureIndex === 1) {
            if (me.alignmolid2color !== undefined && me.alignmolid2color[1].hasOwnProperty(molid)) {
                //color = me.alignmolid2color[1][molid];
                alignNum = me.alignmolid2color[1][molid];
                oricolor = "#FF0000";
            }
            else {
                oricolor = "#FFFFFF";
            }
        }

        var chainid;

        chainid = molid2chain[molid];

        var chainname = molid2name[molid];

        var chain = ' ', oriChain = ' ';
        if (chainid !== undefined) {
            var pos = chainid.indexOf('_');
            oriChain = chainid.substr(pos + 1);

            if (oriChain.length > 1) {
                chain = oriChain.substr(0, 1) + '..';
            }
            else {
                chain = oriChain;
            }
        }
        else {
            chainid = 'Misc';
        }

        if (oricolor === undefined) {
            oricolor = '#FFFFFF';
        }

        for (var i = 0, il = dgm.intrac.length; i < il; ++i) {
            lines.push([molid, dgm.intrac[i]]);
        }

        var ratio = 1.0;
        if (me.icn3d.alnChains[chainid] !== undefined) {
            //ratio = 1.0 * Object.keys(me.icn3d.alnChains[chainid]).length / Object.keys(me.icn3d.chains[chainid]).length;
            var alignedAtomCnt = 0;
            for (var i in me.icn3d.alnChains[chainid]) {
                var colorStr = me.icn3d.atoms[i].color.getHexString().toUpperCase();
                if (colorStr === 'FF0000' || colorStr === '00FF00') {
                    ++alignedAtomCnt;
                }
            }
            ratio = 1.0 * alignedAtomCnt / Object.keys(me.icn3d.chains[chainid]).length;
        }
        if (ratio < 0.2) ratio = 0.2;

        if (dgm.shape === 'rect') {
            var x = dgm.coords[0] * factor;
            var y = dgm.coords[1] * factor;
            var width = dgm.coords[2] * factor - x;
            var height = dgm.coords[3] * factor - y;

            nodeHtml += "<g class='icn3d-node' chainid='" + chainid + "' >";
            nodeHtml += "<title>Chain " + oriChain + ": " + chainname + "</title>";
            // place holder
            nodeHtml += "<rect class='icn3d-basenode' x='" + x + "' y='" + y + "' width='" + width + "' height='" + height + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";
            // highlight
            nodeHtml += "<rect class='icn3d-hlnode' x='" + (x + width / 2.0 * (1 - ratio)).toString() + "' y='" + (y + height / 2.0 * (1 - ratio)).toString() + "' width='" + (width * ratio).toString() + "' height='" + (height * ratio).toString() + "' fill='" + oricolor + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

            nodeHtml += "<text x='" + (x + width / 2 - adjustx).toString() + "' y='" + (y + height / 2 + adjusty).toString() + "' style='fill:" + textcolor + "; font-size:" + fontsize + "; text-anchor:middle' >" + chain + "</text>";

            if (alignNum !== "") nodeHtml += "<text x='" + (x + width / 2 - adjustx).toString() + "' y='" + (y + height + adjusty + halfLetHigh).toString() + "' style='fill:" + oricolor + "; font-size:" + smallfontsize + "; font-weight:bold; text-anchor:middle' >" + alignNum + "</text>";

            nodeHtml += "</g>";

            posHash[molid] = [x + width / 2, y + height / 2];
        }
        else if (dgm.shape === 'circle') {
            var x = dgm.coords[0] * factor;
            var y = dgm.coords[1] * factor;
            var r = dgm.coords[2] * factor;

            nodeHtml += "<g class='icn3d-node' chainid='" + chainid + "' >";
            nodeHtml += "<title>Chain " + oriChain + ": " + chainname + "</title>";
            nodeHtml += "<circle class='icn3d-basenode' cx='" + x + "' cy='" + y + "' r='" + r + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' class='icn3d-node' chainid='" + chainid + "' />";

            nodeHtml += "<circle class='icn3d-hlnode' cx='" + x + "' cy='" + y + "' r='" + (r * ratio).toString() + "' fill='" + oricolor + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

            nodeHtml += "<text x='" + (x - adjustx).toString() + "' y='" + (y + adjusty).toString() + "' style='fill:" + textcolor + "; font-size:" + fontsize + "; text-anchor:middle' >" + chain + "</text>";

            if (alignNum !== "") nodeHtml += "<text x='" + (x - adjustx).toString() + "' y='" + (y + r + adjusty + halfLetHigh).toString() + "' style='fill:" + oricolor + "; font-size:" + smallfontsize + "; font-weight:bold; text-anchor:middle' >" + alignNum + "</text>";

            nodeHtml += "</g>";

            posHash[molid] = [x, y];
        }
        else if (dgm.shape === 'poly') {
            var x0 = dgm.coords[0] * factor;
            var y0 = dgm.coords[1] * factor;
            var x1 = dgm.coords[2] * factor;
            var y1 = dgm.coords[3] * factor;
            var x2 = dgm.coords[4] * factor;
            var y2 = dgm.coords[5] * factor;
            var x3 = dgm.coords[6] * factor;
            var y3 = dgm.coords[7] * factor;

            var x = x0, y = y1;


            nodeHtml += "<g class='icn3d-node' chainid='" + chainid + "' >";
            nodeHtml += "<title>Chain " + oriChain + ": " + chainname + "</title>";
            nodeHtml += "<polygon class='icn3d-basenode' points='" + x0 + ", " + y0 + "," + x1 + ", " + y1 + "," + x2 + ", " + y2 + "," + x3 + ", " + y3 + "' x0='" + x0 + "' y0='" + y0 + "' x1='" + x1 + "' y1='" + y1 + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

            nodeHtml += "<polygon class='icn3d-hlnode' points='" + x0 + ", " + (y + (y0 - y) * ratio).toString() + "," + (x + (x1 - x) * ratio).toString() + ", " + y1 + "," + x0 + ", " + (y - (y0 - y) * ratio).toString() + "," + (x - (x1 - x) * ratio).toString() + ", " + y1 + "' fill='" + oricolor + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

            nodeHtml += "<text x='" + (x0 + smalladjustx).toString() + "' y='" + (y1 + smalladjusty).toString() + "' style='fill:" + textcolor + "; font-size:" + smallfontsize + "; text-anchor:middle' >" + chain + "</text>";

            if (alignNum !== "") nodeHtml += "<text x='" + (x0 + smalladjustx).toString() + "' y='" + (y0 + smalladjusty + halfLetHigh).toString() + "' style='fill:" + oricolor + "; font-size:" + smallfontsize + "; font-weight:bold; text-anchor:middle' >" + alignNum + "</text>";

            nodeHtml += "</g>";

            posHash[molid] = [x0, y1];
        }
    }

    for (var i = 0, il = lines.length; i < il; ++i) {
        var pair = lines[i];

        // if redraw2d diagram and the molid is not displayed, skip
        if (bUpdate !== undefined && bUpdate && (!displayedMolids.hasOwnProperty(pair[0]) || !displayedMolids.hasOwnProperty(pair[1]))) continue;

        var node1 = posHash[parseInt(pair[0])];
        var node2 = posHash[parseInt(pair[1])];

        if (node1 === undefined || node2 === undefined) continue;

        var chainid1, chainid2;

        chainid1 = molid2chain[pair[0]];
        chainid2 = molid2chain[pair[1]];

        var pos1 = chainid1.indexOf('_');
        var pos2 = chainid2.indexOf('_');

        var chain1 = chainid1.substr(pos1 + 1);
        var chain2 = chainid2.substr(pos2 + 1);

        var x1 = node1[0], y1 = node1[1], x2 = node2[0], y2 = node2[1], xMiddle = (x1 + x2) * 0.5, yMiddle = (y1 + y2) * 0.5;

        //if(me.icn3d.bSSOnly) { // the condensed view with only secondary structure information
        //    html += "<g chainid1='" + chainid1 + "' chainid2='" + chainid2 + "' >";
        //    html += "<title>Interactions NOT shown in the condensed view</title>";
        //    html += "<line x1='" + x1 + "' y1='" + y1 + "' x2='" + x2 + "' y2='" + y2 + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "' /></g>";
        //}
        //else {
        html += "<g class='icn3d-interaction' chainid1='" + chainid1 + "' chainid2='" + chainid2 + "' >";
        html += "<title>Interaction of chain " + chain1 + " with chain " + chain2 + "</title>";
        html += "<line x1='" + x1 + "' y1='" + y1 + "' x2='" + xMiddle + "' y2='" + yMiddle + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "' /></g>";

        html += "<g class='icn3d-interaction' chainid1='" + chainid2 + "' chainid2='" + chainid1 + "' >";
        html += "<title>Interaction of chain " + chain2 + " with chain " + chain1 + "</title>";
        html += "<line x1='" + xMiddle + "' y1='" + yMiddle + "' x2='" + x2 + "' y2='" + y2 + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "' /></g>";
        //}
    }

    html += nodeHtml;

    html += "</svg>";
    html += "</div>";

    me.html2ddgm += html;

    $("#" + me.pre + "dl_2ddgm").html(me.html2ddgm);

    return html;
};

iCn3DUI.prototype.set2DdgmNote = function (bAlign) {
    var me = this;
    var html = "<div style='width:150px'><b>Nodes</b>:<br>";
    //html += "<span style='margin-right:18px;'>&#9675;</span>Protein<br>";
    //html += "<span style='margin-right:18px;'>&#9633;</span>Nucleotide<br>";
    //html += "<span style='margin-right:18px;'>&#9671;</span>Chemical<br>";

    html += "<span style='margin-right:18px;'>&#9711;</span>Protein<br>";
    html += "<span style='margin-right:18px;'>&#9633;</span>Nucleotide<br>";
    html += "<span style='margin-right:18px;'>&#9674;</span>Chemical<br>";

    html += "<b>Lines</b>:<br> Interactions at 4 &#197;<br>"
    if (bAlign !== undefined && bAlign) html += "<b>Numbers in red</b>:<br> Aligned chains"
    html += "</div><br/>";

    return html;
};

iCn3DUI.prototype.highlightNode = function (type, highlight, base, ratio) {
    var me = this;
    if (ratio < 0.2) ratio = 0.2;
    var strokeWidth = 3; // default 1

    if (type === 'rect') {
        $(highlight).attr('stroke', me.ORANGE);
        $(highlight).attr('stroke-width', strokeWidth);

        var x = Number($(base).attr('x'));
        var y = Number($(base).attr('y'));
        var width = Number($(base).attr('width'));
        var height = Number($(base).attr('height'));
        $(highlight).attr('x', x + width / 2.0 * (1 - ratio));
        $(highlight).attr('y', y + height / 2.0 * (1 - ratio));
        $(highlight).attr('width', width * ratio);
        $(highlight).attr('height', height * ratio);
    }
    else if (type === 'circle') {
        $(highlight).attr('stroke', me.ORANGE);
        $(highlight).attr('stroke-width', strokeWidth);

        $(highlight).attr('r', Number($(base).attr('r')) * ratio);
    }
    else if (type === 'polygon') {
        $(highlight).attr('stroke', me.ORANGE);
        $(highlight).attr('stroke-width', strokeWidth);

        var x = Number($(base).attr('x0'));
        var y = Number($(base).attr('y1'));
        var x0 = Number($(base).attr('x0'));
        var y0 = Number($(base).attr('y0'));
        var x1 = Number($(base).attr('x1'));
        var y1 = Number($(base).attr('y1'));
        $(highlight).attr('points', x0 + ", " + (y + (y0 - y) * ratio).toString() + ", " + (x + (x1 - x) * ratio).toString() + ", " + y1 + ", " + x0 + ", " + (y - (y0 - y) * ratio).toString() + ", " + (x - (x1 - x) * ratio).toString() + ", " + y1);
    }
};

iCn3DUI.prototype.click2Ddgm = function () {
    var me = this;
    $("#" + me.pre + "dl_2ddgm").on("click", ".icn3d-node", function (e) {
        e.stopImmediatePropagation();
        if (Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) me.setMode('selection');

        me.bClickInteraction = false;

        var chainid = $(this).attr('chainid');

        // clear all nodes
        if (!me.icn3d.bCtrl && !me.icn3d.bShift) {
            me.removeSelection();

            // me.lineArray2d is used to highlight lines in 2D diagram
            me.lineArray2d = [];
        }

        //$(this).find('rect').attr('stroke', me.ORANGE);
        //$(this).find('circle').attr('stroke', me.ORANGE);
        //$(this).find('polygon').attr('stroke', me.ORANGE);

        var ratio = 1.0;
        if (me.icn3d.alnChains[chainid] !== undefined) ratio = 1.0 * Object.keys(me.icn3d.alnChains[chainid]).length / Object.keys(me.icn3d.chains[chainid]).length;

        var target = $(this).find("rect[class='icn3d-hlnode']");
        var base = $(this).find("rect[class='icn3d-basenode']");
        me.highlightNode('rect', target, base, ratio);

        target = $(this).find("circle[class='icn3d-hlnode']");
        base = $(this).find("circle[class='icn3d-basenode']");
        me.highlightNode('circle', target, base, ratio);

        target = $(this).find("polygon[class='icn3d-hlnode']");
        base = $(this).find("polygon[class='icn3d-basenode']");
        me.highlightNode('polygon', target, base, ratio);

        if (!me.icn3d.bCtrl && !me.icn3d.bShift) {
            me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.chains[chainid]);
        }
        else {
            me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[chainid]);
        }

        /*
                // highlight on 3D structure
                me.icn3d.removeHlObjects();
        
                me.icn3d.addHlObjects();
        
                // highlight on 2D diagram
                if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
                    me.chainArray2d = [chainid];
                }
                else {
                    if(me.chainArray2d === undefined) me.chainArray2d = [];
                    me.chainArray2d.push(chainid);
                }
        
                // highlight residues in annotation window and alignment window
                var residueArray = [];
                for(var i = 0, il = me.chainArray2d.length; i < il; ++i) {
                    var chainid = me.chainArray2d[i];
                    for(var j = 0, jl = me.icn3d.chainsSeq[chainid].length; j < jl; ++j) {
                        residueArray.push(chainid + '_' + me.icn3d.chainsSeq[chainid][j].resi);
                    }
                }
        
                me.hlSeq(residueArray);
        */

        // get the name array
        if (!me.icn3d.bCtrl && !me.icn3d.bShift) {
            me.chainArray2d = [chainid];
        }
        else {
            if (me.chainArray2d === undefined) me.chainArray2d = [];
            me.chainArray2d.push(chainid);
        }

        me.updateHlAll(me.chainArray2d);

        // show selected chains in annotation window
        me.showAnnoSelectedChains();

        var select = "select chain " + chainid;
        me.setLogCmd(select, true);

        me.bSelectResidue = false;
    });

    $("#" + me.pre + "dl_2ddgm").on("click", ".icn3d-interaction", function (e) {
        e.stopImmediatePropagation();
        if (Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) me.setMode('selection');

        // clear all nodes
        //if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
        //    me.removeSelection();
        //}

        me.bClickInteraction = true;

        var chainid1 = $(this).attr('chainid1');
        var chainid2 = $(this).attr('chainid2');

        $(this).find('line').attr('stroke', me.ORANGE);

        // interaction of chain1 with chain2, only show the part of chain1 interacting with chain2
        me.selectInteraction(chainid1, chainid2);

        // show selected chains in annotation window
        me.showAnnoSelectedChains();

        var select = "select interaction " + chainid1 + "," + chainid2;
        me.setLogCmd(select, true);

        me.bClickInteraction = false;
    });
};

iCn3DUI.prototype.selectInteraction = function (chainid1, chainid2) {
    var me = this;
    me.removeHl2D();
    me.icn3d.removeHlObjects();

    if (!me.icn3d.bCtrl && !me.icn3d.bShift) {
        // me.lineArray2d is used to highlight lines in 2D diagram
        me.lineArray2d = [chainid1, chainid2];
    }
    else {
        if (me.lineArray2d === undefined) me.lineArray2d = [];
        me.lineArray2d.push(chainid1);
        me.lineArray2d.push(chainid2);
    }

    me.selectInteractionAtoms(chainid1, chainid2);

    me.icn3d.addHlObjects();

    me.updateHlAll();
};

iCn3DUI.prototype.selectInteractionAtoms = function (chainid1, chainid2) {
    var me = this; // me.icn3d.pAtom is set already
    var radius = 4;

    // method 2. Retrieved from the cgi (This previously had problems in sharelink where the data from ajax is async. Now the data is from the same cgi as the atom data and there is no problem.)
    var residueArray = me.chainids2resids[chainid1][chainid2];

    if (!me.icn3d.bCtrl && !me.icn3d.bShift) me.icn3d.hAtoms = {};

    for (var i = 0, il = residueArray.length; i < il; ++i) {
        me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[residueArray[i]]);
    }

    var commandname, commanddesc;
    if (Object.keys(me.icn3d.structures).length > 1) {
        commandname = "inter_" + chainid1 + "_" + chainid2;
    }
    else {
        var pos1 = chainid1.indexOf('_');
        var pos2 = chainid2.indexOf('_');

        commandname = "inter_" + chainid1.substr(pos1 + 1) + "_" + chainid2.substr(pos2 + 1);
    }

    commanddesc = "select the atoms in chain " + chainid1 + " interacting with chain " + chainid2 + " in a distance of " + radius + " angstrom";

    var select = "select interaction " + chainid1 + "," + chainid2;

    me.addCustomSelection(residueArray, commandname, commanddesc, select, true);

    var nameArray = [commandname];
};




/*!
 * ==========================================================
 *  COLOR PICKER PLUGIN 1.3.9
 * ==========================================================
 * Author: Taufik Nurrohman <https://github.com/tovic>
 * License: MIT
 * ----------------------------------------------------------
 */

(function (win, doc, NS) {

    var instance = '__instance__',
        first = 'firstChild',
        delay = setTimeout;

    function is_set(x) {
        return typeof x !== "undefined";
    }

    function is_string(x) {
        return typeof x === "string";
    }

    function is_object(x) {
        return typeof x === "object";
    }

    function object_length(x) {
        return Object.keys(x).length;
    }

    function edge(a, b, c) {
        if (a < b) return b;
        if (a > c) return c;
        return a;
    }

    function num(i, j) {
        return parseInt(i, j || 10);
    }

    function round(i) {
        return Math.round(i);
    }

    // [h, s, v] ... 0 <= h, s, v <= 1
    function HSV2RGB(a) {
        var h = +a[0],
            s = +a[1],
            v = +a[2],
            r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        i = i || 0;
        q = q || 0;
        t = t || 0;
        switch (i % 6) {
            case 0:
                r = v, g = t, b = p;
                break;
            case 1:
                r = q, g = v, b = p;
                break;
            case 2:
                r = p, g = v, b = t;
                break;
            case 3:
                r = p, g = q, b = v;
                break;
            case 4:
                r = t, g = p, b = v;
                break;
            case 5:
                r = v, g = p, b = q;
                break;
        }
        return [round(r * 255), round(g * 255), round(b * 255)];
    }

    function HSV2HEX(a) {
        return RGB2HEX(HSV2RGB(a));
    }

    // [r, g, b] ... 0 <= r, g, b <= 255
    function RGB2HSV(a) {
        var r = +a[0],
            g = +a[1],
            b = +a[2],
            max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            d = max - min,
            h, s = (max === 0 ? 0 : d / max),
            v = max / 255;
        switch (max) {
            case min:
                h = 0;
                break;
            case r:
                h = (g - b) + d * (g < b ? 6 : 0);
                h /= 6 * d;
                break;
            case g:
                h = (b - r) + d * 2;
                h /= 6 * d;
                break;
            case b:
                h = (r - g) + d * 4;
                h /= 6 * d;
                break;
        }
        return [h, s, v];
    }

    function RGB2HEX(a) {
        var s = +a[2] | (+a[1] << 8) | (+a[0] << 16);
        s = '000000' + s.toString(16);
        return s.slice(-6);
    }

    // rrggbb or rgb
    function HEX2HSV(s) {
        return RGB2HSV(HEX2RGB(s));
    }

    function HEX2RGB(s) {
        if (s.length === 3) {
            s = s.replace(/./g, '$&$&');
        }
        return [num(s[0] + s[1], 16), num(s[2] + s[3], 16), num(s[4] + s[5], 16)];
    }

    // convert range from `0` to `360` and `0` to `100` in color into range from `0` to `1`
    function _2HSV_pri(a) {
        return [+a[0] / 360, +a[1] / 100, +a[2] / 100];
    }

    // convert range from `0` to `1` into `0` to `360` and `0` to `100` in color
    function _2HSV_pub(a) {
        return [round(+a[0] * 360), round(+a[1] * 100), round(+a[2] * 100)];
    }

    // convert range from `0` to `255` in color into range from `0` to `1`
    function _2RGB_pri(a) {
        return [+a[0] / 255, +a[1] / 255, +a[2] / 255];
    }

    // *
    function parse(x) {
        if (is_object(x)) return x;
        var rgb = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i.exec(x),
            hsv = /\s*hsv\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)\s*$/i.exec(x),
            hex = x[0] === '#' && x.match(/^#([\da-f]{3}|[\da-f]{6})$/i);
        if (hex) {
            return HEX2HSV(x.slice(1));
        } else if (hsv) {
            return _2HSV_pri([+hsv[1], +hsv[2], +hsv[3]]);
        } else if (rgb) {
            return RGB2HSV([+rgb[1], +rgb[2], +rgb[3]]);
        }
        return [0, 1, 1]; // default is red
    }

    (function ($) {

        // plugin version
        $.version = '1.3.9';

        // collect all instance(s)
        $[instance] = {};

        // plug to all instance(s)
        $.each = function (fn, t) {
            return delay(function () {
                var ins = $[instance], i;
                for (i in ins) {
                    fn(ins[i], i, ins);
                }
            }, t === 0 ? 0 : (t || 1)), $;
        };

        // static method(s)
        $.parse = parse;
        $._HSV2RGB = HSV2RGB;
        $._HSV2HEX = HSV2HEX;
        $._RGB2HSV = RGB2HSV;
        $._HEX2HSV = HEX2HSV;
        $._HEX2RGB = function (a) {
            return _2RGB_pri(HEX2RGB(a));
        };
        $.HSV2RGB = function (a) {
            return HSV2RGB(_2HSV_pri(a));
        };
        $.HSV2HEX = function (a) {
            return HSV2HEX(_2HSV_pri(a));
        };
        $.RGB2HSV = function (a) {
            return _2HSV_pub(RGB2HSV(a));
        };
        $.RGB2HEX = RGB2HEX;
        $.HEX2HSV = function (s) {
            return _2HSV_pub(HEX2HSV(s));
        };
        $.HEX2RGB = HEX2RGB;

    })(win[NS] = function (target, events, parent) {

        var b = doc.body,
            h = doc.documentElement,
            $ = this,
            $$ = win[NS],
            _ = false,
            hooks = {},
            picker = doc.createElement('div'),
            on_down = "touchstart mousedown",
            on_move = "touchmove mousemove",
            on_up = "touchend mouseup",
            on_resize = "orientationchange resize";

        // return a new instance if `CP` was called without the `new` operator
        if (!($ instanceof $$)) {
            return new $$(target, events);
        }

        // store color picker instance to `CP.__instance__`
        $$[instance][target.id || target.name || object_length($$[instance])] = $;

        // trigger color picker panel on click by default
        if (!is_set(events) || events === true) {
            events = on_down;
        }

        // add event
        function on(ev, el, fn) {
            ev = ev.split(/\s+/);
            for (var i = 0, ien = ev.length; i < ien; ++i) {
                el.addEventListener(ev[i], fn, false);
            }
        }

        // remove event
        function off(ev, el, fn) {
            ev = ev.split(/\s+/);
            for (var i = 0, ien = ev.length; i < ien; ++i) {
                el.removeEventListener(ev[i], fn);
            }
        }

        // get mouse/finger coordinate
        function point(el, e) {
            var T = 'touches',
                X = 'clientX',
                Y = 'clientY',
                x = !!e[T] ? e[T][0][X] : e[X],
                y = !!e[T] ? e[T][0][Y] : e[Y],
                o = offset(el);
            return {
                x: x - o.l,
                y: y - o.t
            };
        }

        // get position
        function offset(el) {
            var left, top, rect;
            if (el === win) {
                left = win.pageXOffset || h.scrollLeft;
                top = win.pageYOffset || h.scrollTop;
            } else {
                rect = el.getBoundingClientRect();
                left = rect.left;
                top = rect.top;
            }
            return {
                l: left,
                t: top
            };
        }

        // get closest parent
        function closest(a, b) {
            while ((a = a.parentElement) && a !== b);
            return a;
        }

        // prevent default
        function prevent(e) {
            if (e) e.preventDefault();
        }

        // get dimension
        function size(el) {
            return el === win ? {
                w: win.innerWidth,
                h: win.innerHeight
            } : {
                w: el.offsetWidth,
                h: el.offsetHeight
            };
        }

        // get color data
        function get_data(a) {
            return _ || (is_set(a) ? a : false);
        }

        // set color data
        function set_data(a) {
            _ = a;
        }

        // add hook
        function add(ev, fn, id) {
            if (!is_set(ev)) return hooks;
            if (!is_set(fn)) return hooks[ev];
            if (!is_set(hooks[ev])) hooks[ev] = {};
            if (!is_set(id)) id = object_length(hooks[ev]);
            return hooks[ev][id] = fn, $;
        }

        // remove hook
        function remove(ev, id) {
            if (!is_set(ev)) return hooks = {}, $;
            if (!is_set(id)) return hooks[ev] = {}, $;
            return delete hooks[ev][id], $;
        }

        // trigger hook
        function trigger(ev, a, id) {
            if (!is_set(hooks[ev])) return $;
            if (!is_set(id)) {
                for (var i in hooks[ev]) {
                    hooks[ev][i].apply($, a);
                }
            } else {
                if (is_set(hooks[ev][id])) {
                    hooks[ev][id].apply($, a);
                }
            }
            return $;
        }

        // initialize data ...
        set_data($$.parse(target.getAttribute('data-color') || target.value || [0, 1, 1]));

        // generate color picker pane ...
        picker.className = 'color-picker';
        picker.innerHTML = '<div class="color-picker-control"><span class="color-picker-h"><i></i></span><span class="color-picker-sv"><i></i></span></div>';
        var c = picker[first].children,
            HSV = get_data([0, 1, 1]), // default is red
            H = c[0],
            SV = c[1],
            H_point = H[first],
            SV_point = SV[first],
            start_H = 0,
            start_SV = 0,
            drag_H = 0,
            drag_SV = 0,
            left = 0,
            top = 0,
            P_W = 0,
            P_H = 0,
            v = HSV2HEX(HSV),
            set;

        // on update ...
        function trigger_(k, x) {
            if (!k || k === "h") {
                trigger("change:h", x);
            }
            if (!k || k === "sv") {
                trigger("change:sv", x);
            }
            trigger("change", x);
        }

        // is visible?
        function visible() {
            return picker.parentNode;
        }

        // create
        function create(first, bucket) {
            if (!first) {
                (parent || bucket || b).appendChild(picker), $.visible = true;
            }
            P_W = size(picker).w;
            P_H = size(picker).h;
            var SV_size = size(SV),
                SV_point_size = size(SV_point),
                H_H = size(H).h,
                SV_W = SV_size.w,
                SV_H = SV_size.h,
                H_point_H = size(H_point).h,
                SV_point_W = SV_point_size.w,
                SV_point_H = SV_point_size.h;
            if (first) {
                picker.style.left = picker.style.top = '-9999px';
                function click(e) {
                    var t = e.target,
                        is_target = t === target || closest(t, target) === target;
                    if (is_target) {
                        create();
                    } else {
                        $.exit();
                    }
                    trigger(is_target ? "enter" : "exit", [$]);
                }
                if (events !== false) {
                    on(events, target, click);
                }
                $.create = function () {
                    return create(1), trigger("create", [$]), $;
                };
                $.destroy = function () {
                    if (events !== false) {
                        off(events, target, click);
                    }
                    $.exit(), set_data(false);
                    return trigger("destroy", [$]), $;
                };
            } else {
                fit();
            }
            set = function () {
                HSV = get_data(HSV), color();
                H_point.style.top = (H_H - (H_point_H / 2) - (H_H * +HSV[0])) + 'px';
                SV_point.style.right = (SV_W - (SV_point_W / 2) - (SV_W * +HSV[1])) + 'px';
                SV_point.style.top = (SV_H - (SV_point_H / 2) - (SV_H * +HSV[2])) + 'px';
            };
            $.exit = function (e) {
                if (visible()) {
                    visible().removeChild(picker);
                    $.visible = false;
                }
                off(on_down, H, down_H);
                off(on_down, SV, down_SV);
                off(on_move, doc, move);
                off(on_up, doc, stop);
                off(on_resize, win, fit);
                return $;
            };
            function color(e) {
                var a = HSV2RGB(HSV),
                    b = HSV2RGB([HSV[0], 1, 1]);
                SV.style.backgroundColor = 'rgb(' + b.join(',') + ')';
                set_data(HSV);
                prevent(e);
            };
            set();
            function do_H(e) {
                var y = edge(point(H, e).y, 0, H_H);
                HSV[0] = (H_H - y) / H_H;
                H_point.style.top = (y - (H_point_H / 2)) + 'px';
                color(e);
            }
            function do_SV(e) {
                var o = point(SV, e),
                    x = edge(o.x, 0, SV_W),
                    y = edge(o.y, 0, SV_H);
                HSV[1] = 1 - ((SV_W - x) / SV_W);
                HSV[2] = (SV_H - y) / SV_H;
                SV_point.style.right = (SV_W - x - (SV_point_W / 2)) + 'px';
                SV_point.style.top = (y - (SV_point_H / 2)) + 'px';
                color(e);
            }
            function move(e) {
                if (drag_H) {
                    do_H(e), v = HSV2HEX(HSV);
                    if (!start_H) {
                        trigger("drag:h", [v, $]);
                        trigger("drag", [v, $]);
                        trigger_("h", [v, $]);
                    }
                }
                if (drag_SV) {
                    do_SV(e), v = HSV2HEX(HSV);
                    if (!start_SV) {
                        trigger("drag:sv", [v, $]);
                        trigger("drag", [v, $]);
                        trigger_("sv", [v, $]);
                    }
                }
                start_H = 0,
                    start_SV = 0;
            }
            function stop(e) {
                var t = e.target,
                    k = drag_H ? "h" : "sv",
                    a = [HSV2HEX(HSV), $],
                    is_target = t === target || closest(t, target) === target,
                    is_picker = t === picker || closest(t, picker) === picker;
                if (!is_target && !is_picker) {
                    // click outside the target or picker element to exit
                    if (visible() && events !== false) $.exit(), trigger("exit", [$]), trigger_(0, a);
                } else {
                    if (is_picker) {
                        trigger("stop:" + k, a);
                        trigger("stop", a);
                        trigger_(k, a);
                    }
                }
                drag_H = 0,
                    drag_SV = 0;
            }
            function down_H(e) {
                start_H = 1,
                    drag_H = 1,
                    move(e), prevent(e);
                trigger("start:h", [v, $]);
                trigger("start", [v, $]);
                trigger_("h", [v, $]);
            }
            function down_SV(e) {
                start_SV = 1,
                    drag_SV = 1,
                    move(e), prevent(e);
                trigger("start:sv", [v, $]);
                trigger("start", [v, $]);
                trigger_("sv", [v, $]);
            }
            if (!first) {
                on(on_down, H, down_H);
                on(on_down, SV, down_SV);
                on(on_move, doc, move);
                on(on_up, doc, stop);
                on(on_resize, win, fit);
            }
        } create(1);

        delay(function () {
            var a = [HSV2HEX(HSV), $];
            trigger("create", a);
            trigger_(0, a);
        }, 0);

        // fit to window
        $.fit = function (o) {
            var w = size(win),
                y = size(h),
                screen_w = w.w - y.w, // vertical scroll bar
                screen_h = w.h - h.clientHeight, // horizontal scroll bar
                ww = offset(win),
                to = offset(target);
            left = to.l + ww.l;
            top = to.t + ww.t + size(target).h; // drop!
            if (is_object(o)) {
                is_set(o[0]) && (left = o[0]);
                is_set(o[1]) && (top = o[1]);
            } else {
                var min_x = ww.l,
                    min_y = ww.t,
                    max_x = ww.l + w.w - P_W - screen_w,
                    max_y = ww.t + w.h - P_H - screen_h;
                left = edge(left, min_x, max_x) >> 0;
                top = edge(top, min_y, max_y) >> 0;
            }
            picker.style.left = left + 'px';
            picker.style.top = top + 'px';
            return trigger("fit", [$]), $;
        };

        // for event listener ID
        function fit() {
            return $.fit();
        }

        // set hidden color picker data
        $.set = function (a) {
            if (!is_set(a)) return get_data();
            if (is_string(a)) {
                a = $$.parse(a);
            }
            return set_data(a), set(), $;
        };

        // alias for `$.set()`
        $.get = function (a) {
            return get_data(a);
        };

        // register to global ...
        $.target = target;
        $.picker = picker;
        $.visible = false;
        $.on = add;
        $.off = remove;
        $.fire = trigger;
        $.hooks = hooks;
        $.enter = function (bucket) {
            return create(0, bucket);
        };

        // return the global object
        return $;

    });

})(window, document, 'CP');
